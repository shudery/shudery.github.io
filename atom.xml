<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Daguo&#39;s blog</title>
  <subtitle>Hello guy, welcome!</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://shudery.cn/"/>
  <updated>2019-05-26T11:54:18.417Z</updated>
  <id>http://shudery.cn/</id>
  
  <author>
    <name>Daguo</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>LeetCode 刷题的正确姿势</title>
    <link href="http://shudery.cn/2019/04/15/%E7%AC%94%E8%AE%B0/LeetCode%E5%88%B7%E9%A2%98%E7%9A%84%E6%AD%A3%E7%A1%AE%E5%A7%BF%E5%8A%BF/"/>
    <id>http://shudery.cn/2019/04/15/笔记/LeetCode刷题的正确姿势/</id>
    <published>2019-04-14T16:00:00.000Z</published>
    <updated>2019-05-26T11:54:18.417Z</updated>
    
    <content type="html"><![CDATA[<h3 id="关于-LeetCode"><a href="#关于-LeetCode" class="headerlink" title="关于 LeetCode"></a>关于 LeetCode</h3><p><a href="https://leetcode.com/problemset/all/">LeetCode</a>是美国一个在线编程网站，也是一个在线判题(Online Judge)平台。拥有很好的在线编程体验，大量的算法题库以及活跃的答案讨论区。</p>
<p><a href="https://leetcode.com/problemset/all/">LeetCode</a>上的题目分为三个难度，除了 Hard 模式外大多比较基础，基本上不考察复杂的算法，大多是对基础知识应用，因此是程序员准备面试，入门和练习算法的不二之选，另外它在去年推出了<a href="https://leetcode-cn.com/problemset/all/">中文版</a>。</p>
<p>关于程序员练习算法的好处我就不赘述了，可以看看这篇文章： <a href="https://coolshell.cn/articles/12052.html">LeetCode 编程训练</a></p>
<h3 id="如何更好地刷题？"><a href="#如何更好地刷题？" class="headerlink" title="如何更好地刷题？"></a>如何更好地刷题？</h3><p>各大 OJ 平台都会提供相应的在线编辑器和测试用例。用户可以即时做题，运行代码，得到结果。不过我认为对于长期使用者来说，应该使做算法的过程<strong>本地化</strong>，这么做有如下这些好处：</p>
<ul>
<li>可以使用自己平时开发写代码的编辑器/IDE，更加习惯。</li>
<li>有语法提示和自动格式化，写代码更高效更规范。</li>
<li>本地断点调试很方便。</li>
<li>使用本地测试用例，可以针对性测试某个用例，同时避免在 OJ 平台的多次错误提交，降低你的 AC 成功率。</li>
<li>通过测试工具，对比不同解法的性能。</li>
<li>支持离线做题，可以将记录同步到 Git 进行版本管理。</li>
</ul>
<p>因此我写了一个本地化 LeetCode 刷题的库：<a href="https://github.com/shudery/leetCode">https://github.com/shudery/leetCode</a>，来获得上面的这些优势，让我可以更高效更方便地刷题，同时也记录了我的解题过程，我使用的编程语言为 JavaScript。</p>
<h3 id="开始使用"><a href="#开始使用" class="headerlink" title="开始使用"></a>开始使用</h3><p>将项目克隆到本地：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git clone git@github.com:shudery/leetCode.git</div></pre></td></tr></table></figure>
<p>你需要安装最新的 Nodejs 稳定版本，然后下载 npm 包依赖：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install</div></pre></td></tr></table></figure>
<p>PS：克隆下来的项目 problems 目录下有我的做题记录，可以重命名作为参考，也可以直接删除，记录你自己的解题记录</p>
<h3 id="新建算法题目"><a href="#新建算法题目" class="headerlink" title="新建算法题目"></a>新建算法题目</h3><p>通过一个简单的 shell 脚本，自动生成新题目的文件目录，根据模板生成相应文件，一个用来写算法的 <strong>index.js</strong> 和一个用来填写测试输入和输出的 <strong>test.js</strong>，并在 <strong>README.md</strong> 中插入一条相关的信息。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># ./crepro.sh &#123;题目序号&#125;-&#123;题目(-分隔单词)&#125; &#123;题目难度&#125;</div><div class="line">./crepro.sh 413-arithmetic-slices Medium</div></pre></td></tr></table></figure>
<p>PS：目前仅在 <strong>index.js</strong> 插入一些基本信息，还需要手动 copy 一下题目内容和测试用例到本地，并导出函数，后续考虑通过自动化爬虫抓取。</p>
<h3 id="测试算法题目"><a href="#测试算法题目" class="headerlink" title="测试算法题目"></a>测试算法题目</h3><p>使用测试框架 <strong>mocha</strong> 和断言库 <strong>chai</strong> 来验证算法是否通过所有测试用例，用 <strong>benchmark</strong> 来测试算法运行耗时。</p>
<p>测试相应题目很简单，只需要带上题目号，在命令行中执行：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 测试题号001，传入n=001，返回测试结果</span></div><div class="line">n=<span class="number">001</span> npm test</div><div class="line"><span class="comment">// 返回测试结果，包括算法性能</span></div><div class="line">n=<span class="number">001</span> npm run perf</div></pre></td></tr></table></figure>
<p><img src="/images/leetcode.png" alt="测试结果"></p>
<p>思路很简单，将目录结构下的 <strong>index.js</strong> 中的函数取出，用 <strong>test.js</strong> 中的输入数组作为参数传入执行，与输出结果做对比，以此判断算法是否通过：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> path = <span class="string">'./problems'</span>;</div><div class="line"><span class="keyword">const</span> problems = fs.readdirSync(path);</div><div class="line"><span class="keyword">const</span> num = process.env.n;</div><div class="line"></div><div class="line"><span class="keyword">if</span> (num) &#123;</div><div class="line">  <span class="comment">// 测试指定题目</span></div><div class="line">  <span class="keyword">const</span> reg = <span class="keyword">new</span> <span class="built_in">RegExp</span>(num);</div><div class="line">  <span class="keyword">const</span> problem = problems.find(val =&gt; reg.test(val));</div><div class="line">  runTest(problem);</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">  <span class="comment">// 测试所有题目</span></div><div class="line">  problems.forEach(problem =&gt; runTest(problem));</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</div><div class="line">/**</div><div class="line"> * 启动测试用例</div><div class="line"> * @param &#123;string&#125; problem 题目目录</div><div class="line"> */</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">runTest</span>(<span class="params">problem</span>) </span>&#123;</div><div class="line">  <span class="keyword">let</span> fns = <span class="built_in">require</span>(<span class="string">'./problems/'</span> + problem + <span class="string">'/index.js'</span>);</div><div class="line">  <span class="keyword">const</span> testCases = <span class="built_in">require</span>(<span class="string">'./problems/'</span> + problem + <span class="string">'/test.js'</span>);</div><div class="line">  <span class="comment">//将单个函数转为数组格式</span></div><div class="line">  <span class="keyword">if</span> (<span class="built_in">Object</span>.prototype.toString.call(fns) !== <span class="string">'[object Array]'</span>) &#123;</div><div class="line">    fns = [fns];</div><div class="line">  &#125;</div><div class="line">  <span class="comment">// 开始测试</span></div><div class="line">  describe(<span class="string">`test-problem: <span class="subst">$&#123;problem&#125;</span>`</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">// 将每个题目中导出的函数逐个执行测试用例</span></div><div class="line">    fns.forEach(fn =&gt; &#123;</div><div class="line">      <span class="comment">// 将多个测试用例逐个执行</span></div><div class="line">      testCases.forEach((testCase, testIndex) =&gt; &#123;</div><div class="line">        <span class="comment">// 如果该题目不需要测试则在module.exports =null即可</span></div><div class="line">        fn &amp;&amp;</div><div class="line">          it(<span class="string">`function:<span class="subst">$&#123;fn.name&#125;</span>  testCase-<span class="subst">$&#123;testIndex&#125;</span>`</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="comment">// 不能直接传入原始数组，不然testCase中的input被污染，影响下一个执行函数</span></div><div class="line">            <span class="keyword">const</span> arr = _.clone(testCase);</div><div class="line">            expect(fn.apply(<span class="literal">null</span>, arr.input)).to.deep.equal(arr.output);</div><div class="line">          &#125;);</div><div class="line">      &#125;);</div><div class="line">    &#125;);</div><div class="line">  &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>除了验证算法是否通过外，运行算法的耗时也很重要，在一些涉及到大量数据运算的题目中经常遇到算法正确性可以通过，但是由于超出运算时间而无法通过的情况，比如我在做<a href="https://leetcode-cn.com/problems/lru-cache/">LRU-Cache</a> 这道题目的时候，就因为使用了 <strong>forEach</strong> 这个方法而导致超时错误，后面经过测试对比算法的运算耗时，发现 <strong>forEach</strong> 在数据量很大时，性能远远不如 for 循环，改用 for 循环后该问题得到解决。</p>
<p>性能测试使用 <strong>benchmark</strong> 库，由于其 API 为链式调用，直接通过 eval 拼接字符串的方式来执行，每个算法的导出为一个数组，数组中可以有多个解法函数，测试多个函数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> fns = <span class="built_in">require</span>(<span class="string">'./problems/'</span> + problem + <span class="string">'/index.js'</span>);</div><div class="line"><span class="keyword">const</span> testCases = <span class="built_in">require</span>(<span class="string">'./problems/'</span> + problem + <span class="string">'/test.js'</span>);</div><div class="line">perfTest(problem, _.clone(testCases), fns);</div><div class="line"><span class="comment">/**</div><div class="line"> * 性能测试函数</div><div class="line"> * @param &#123;*&#125; problem 测试的题目目录</div><div class="line"> * @param &#123;*&#125; testCases 测试用例</div><div class="line"> * @param &#123;*&#125; fns 测试的函数</div><div class="line"> */</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">perfTest</span>(<span class="params">problem, testCases, fns</span>) </span>&#123;</div><div class="line">  logger((<span class="string">'&lt;--start fns speed test--&gt;'</span> + problem).underline + <span class="string">'\n'</span>);</div><div class="line">  <span class="comment">//非数组报错</span></div><div class="line">  isArray(problem, fns);</div><div class="line">  <span class="comment">// 运算耗时排名</span></div><div class="line">  <span class="keyword">const</span> timeRank = [];</div><div class="line">  <span class="comment">// 执行字符串</span></div><div class="line">  <span class="keyword">const</span> evalStr = fns.reduce(</div><div class="line">    (pre, cur, i) =&gt;</div><div class="line">      pre +</div><div class="line">      <span class="string">`.add("<span class="subst">$&#123;</div><div class="line">        cur.name</div><div class="line">      &#125;</span>", function() &#123;fns[<span class="subst">$&#123;i&#125;</span>].apply(null,testCases[0].input);&#125;)`</span>,</div><div class="line">    <span class="string">'suite'</span></div><div class="line">  );</div><div class="line">  <span class="built_in">eval</span>(evalStr)</div><div class="line">    .on(<span class="string">'cycle'</span>, event =&gt; handleCycle(event, timeRank))</div><div class="line">    .on(<span class="string">'complete'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">      <span class="comment">// 对运行时间排序</span></div><div class="line">      sort(timeRank);</div><div class="line">      <span class="keyword">const</span> label = [];</div><div class="line">      timeRank.forEach(result =&gt; &#123;</div><div class="line">        label.push(<span class="string">`<span class="subst">$&#123;result.name&#125;</span> &gt;&gt;&gt; <span class="subst">$&#123;result.time&#125;</span>`</span>);</div><div class="line">      &#125;);</div><div class="line">      logger(<span class="keyword">this</span>);</div><div class="line">      logger(<span class="string">`Allrank :\n<span class="subst">$&#123;label.join('\n')&#125;</span>`</span>.blue);</div><div class="line">      logger(<span class="string">`Fastest :\n<span class="subst">$&#123;this.filter('fastest').map('name')&#125;</span>`</span>.green);</div><div class="line">      logger(<span class="string">`Slowest :\n<span class="subst">$&#123;this.filter('slowest').map('name')&#125;</span>`</span>.red);</div><div class="line">    &#125;)</div><div class="line">    <span class="comment">// 这个选项与时间计算有关</span></div><div class="line">    .run(&#123; <span class="keyword">async</span>: <span class="literal">true</span> &#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleCycle</span>(<span class="params">event, timeRank</span>) </span>&#123;</div><div class="line">  <span class="keyword">const</span> info = <span class="built_in">String</span>(event.target);</div><div class="line">  logger(info.yellow);</div><div class="line">  timeRank.push(&#123;</div><div class="line">    name: info.split(<span class="string">' x '</span>)[<span class="number">0</span>],</div><div class="line">    time: info.split(<span class="string">' x '</span>)[<span class="number">1</span>].split(<span class="string">' ops/sec'</span>)[<span class="number">0</span>]</div><div class="line">  &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>不带题目号则测试所有题目：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">npm test</div><div class="line"><span class="comment">// 测试算法是否通过，并计算所有算法的性能，比较耗时</span></div><div class="line">npm run perf</div></pre></td></tr></table></figure>
<h3 id="调试算法题目"><a href="#调试算法题目" class="headerlink" title="调试算法题目"></a>调试算法题目</h3><p>在本地做题还有一个巨大的优势就是可以做断点调试。在 <strong>VSCode</strong> 之类的编辑器中打上断点，或者在代码中写 <strong>debugger</strong>，注意会执行一遍所有的算法测试用例，所以不要跨题目打多余的断点。执行如下命令：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm run debug</div></pre></td></tr></table></figure>
<p>PS：注意通常 OJ 平台上的一些数据类型转化都是封装好，对用户不可见的，本地化时需要实现这些数据结构的转化算法。目前已经实现 <strong>数组 –&gt; 链表</strong> 的转换函数 <strong>mapLinks</strong>， <strong>数组 –&gt; 二叉树</strong> 的转换函数 <strong>mapTree</strong>，在需要做转换的测试用例中，将输入参数传入转换函数即可。</p>
<h3 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h3><ul>
<li>算法题目内容的自动获取</li>
<li>算法空间性能的计算</li>
<li>支持函数调用式的测试用例格式</li>
<li>目前仅支持 JavaScript 的解法，可以兼容支持其他语言</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;关于-LeetCode&quot;&gt;&lt;a href=&quot;#关于-LeetCode&quot; class=&quot;headerlink&quot; title=&quot;关于 LeetCode&quot;&gt;&lt;/a&gt;关于 LeetCode&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode.com/prob
    
    </summary>
    
      <category term="笔记" scheme="http://shudery.cn/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="工具" scheme="http://shudery.cn/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="算法" scheme="http://shudery.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Webpack打包的基础原理</title>
    <link href="http://shudery.cn/2019/02/11/%E7%AC%94%E8%AE%B0/Webpack%E6%89%93%E5%8C%85%E7%9A%84%E5%9F%BA%E7%A1%80%E5%8E%9F%E7%90%86/"/>
    <id>http://shudery.cn/2019/02/11/笔记/Webpack打包的基础原理/</id>
    <published>2019-02-11T02:37:32.000Z</published>
    <updated>2019-02-13T11:45:49.414Z</updated>
    
    <content type="html"><![CDATA[<p>最近想学习一下 webpack 打包的基本原理，从官方文档找到了一个推荐链接：<a href="https://github.com/ronami/minipack">简单模块打包工具的细节说明</a></p>
<p>是一个精简的打包工具示例：minipack，里面的源码解释非常详细，介绍了一个打包工具库主要做的工作。我快速地阅读了一下源码，并做了一下翻译和总结。</p>
<p>简单来说打包就是从一个入口文件开始，根据模块引入的语法（例如 ES6 的 import，commonJS 的 require）找到所有的依赖模块，然后通过函数作用域隔离开并打包成一个单一文件。</p>
<p>当然 webpack 也支持多入口打包，已经输出多个 chunks 打包文件，这里只是实现最简单的打包器功能，只需分三步。</p>
<h3 id="1-找出单个模块的依赖文件"><a href="#1-找出单个模块的依赖文件" class="headerlink" title="1. 找出单个模块的依赖文件"></a>1. 找出单个模块的依赖文件</h3><p>在 minipack 中，没有选择直接对文件内容进行字符串解析，而是使用了 babylon 这个包来做语法解析。得到的抽象语法树 AST，处理文件中的 ImportDeclaration 语句，即可得到文件的依赖信息，</p>
<p>处理后同时给该文件打上标记 id，每个文件模块经过处理之后会返回一个如下结构的对象：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Return all information about this module.</span></div><div class="line"><span class="keyword">return</span> &#123;</div><div class="line">  id, <span class="comment">// 模块标识</span></div><div class="line">  filename, <span class="comment">// 模块文件的地址</span></div><div class="line">  dependencies, <span class="comment">// 模块的依赖文件列表</span></div><div class="line">  code <span class="comment">// 模块的代码内容</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h3 id="2-获取全部模块的依赖关系"><a href="#2-获取全部模块的依赖关系" class="headerlink" title="2. 获取全部模块的依赖关系"></a>2. 获取全部模块的依赖关系</h3><p>接下来需要将所有文件的依赖关系联系起来，输入一个入口模块的地址，已该模块作为起点，循环搜索各个文件的依赖，直到依赖链的底层，直接贴上我对源码的注解：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 获取全部模块的依赖关系</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">createGraph</span>(<span class="params">entry</span>) </span>&#123;</div><div class="line">  <span class="comment">// 结构化模块信息</span></div><div class="line">  <span class="keyword">const</span> mainAsset = createAsset(entry);</div><div class="line"></div><div class="line">  <span class="comment">// 存储模块信息到队列</span></div><div class="line">  <span class="keyword">const</span> queue = [mainAsset];</div><div class="line"></div><div class="line">  <span class="comment">// 使用迭代器来处理模块队列，当队列为空循环终止</span></div><div class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> asset <span class="keyword">of</span> queue) &#123;</div><div class="line">    <span class="comment">// 保存依赖关系</span></div><div class="line">    asset.mapping = &#123;&#125;;</div><div class="line">    <span class="keyword">const</span> dirname = path.dirname(asset.filename);</div><div class="line">    <span class="comment">// 处理依赖子模块</span></div><div class="line">    asset.dependencies.forEach(relativePath =&gt; &#123;</div><div class="line">      <span class="comment">// 相对路径转为绝对路径</span></div><div class="line">      <span class="keyword">const</span> absolutePath = path.join(dirname, relativePath);</div><div class="line"></div><div class="line">      <span class="comment">// 获取依赖子模块的信息</span></div><div class="line">      <span class="keyword">const</span> child = createAsset(absolutePath);</div><div class="line"></div><div class="line">      <span class="comment">// 将依赖关系通过path:id的形式保存</span></div><div class="line">      asset.mapping[relativePath] = child.id;</div><div class="line"></div><div class="line">      <span class="comment">// 存在依赖的子模块，即asset.dependencies不为空时，子模块入队列继续迭代</span></div><div class="line">      queue.push(child);</div><div class="line">    &#125;);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> queue;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="3-整合为单个文件"><a href="#3-整合为单个文件" class="headerlink" title="3. 整合为单个文件"></a>3. 整合为单个文件</h3><p>有了所有模块的依赖关系后，我们就可以将它们整合在一份文件中，通过 js 的 function 作用域去将各个模块隔离开来，仅暴露 module.exports 出来。</p>
<p>将依赖信息构造成一个以 id 的索引的数组，数组包括两个元素：一个是以 require 函数，module 和 exports 对象为入参的函数，一个是子依赖项的信息。重点在于实现 require 方法。</p>
<p>在 require 方法中，传入模块 id，根据模块 id 获取隔离作用域的执行函数 fn 以及依赖信息 mapping，预处理一下 require 函数，目的是将模块中 require 函数入参的相对地址转为 id，然后传入执行 fn，最后返回 module.exports 对象给上级调用。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">bundle</span>(<span class="params">graph</span>) </span>&#123;</div><div class="line">  <span class="keyword">let</span> modules = <span class="string">''</span>;</div><div class="line">  <span class="comment">// 将依赖图信息列表转为一个字符串</span></div><div class="line">  graph.forEach(mod =&gt; &#123;</div><div class="line">    modules += <span class="string">`<span class="subst">$&#123;mod.id&#125;</span>: [</div><div class="line">      function (require, module, exports) &#123;</div><div class="line">        <span class="subst">$&#123;mod.code&#125;</span></div><div class="line">      &#125;,</div><div class="line">      <span class="subst">$&#123;JSON.stringify(mod.mapping)&#125;</span>,</div><div class="line">    ],`</span>;</div><div class="line">  &#125;);</div><div class="line"></div><div class="line">  <span class="comment">// 实现一个自执行函数，注入modules信息</span></div><div class="line">  <span class="keyword">const</span> result = <span class="string">`</div><div class="line">    (function(modules) &#123;</div><div class="line">      function require(id) &#123;</div><div class="line">        const [fn, mapping] = modules[id];</div><div class="line"></div><div class="line">        function localRequire(name) &#123;</div><div class="line">          return require(mapping[name]);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        const module = &#123; exports : &#123;&#125; &#125;;</div><div class="line"></div><div class="line">        fn(localRequire, module, module.exports);</div><div class="line"></div><div class="line">        return module.exports;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      require(0);</div><div class="line">    &#125;)(&#123;<span class="subst">$&#123;modules&#125;</span>&#125;)</div><div class="line">  `</span>;</div><div class="line">  <span class="comment">// 返回单个文件输出</span></div><div class="line">  <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个方法显然是有一些瑕疵的，比如所有的模块执行 require 时都会执行一遍 require 模块的代码，可能会导致重复引入。不过通过对 require 方法的简单实现，已经足够让我们理解 webpack 这类打包工具的本质：就是通过函数来划分作用域，通过 module 以及 module.exports 来共享数据。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近想学习一下 webpack 打包的基本原理，从官方文档找到了一个推荐链接：&lt;a href=&quot;https://github.com/ronami/minipack&quot;&gt;简单模块打包工具的细节说明&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;是一个精简的打包工具示例：minipack，里面的源码解
    
    </summary>
    
      <category term="笔记" scheme="http://shudery.cn/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="工程化" scheme="http://shudery.cn/tags/%E5%B7%A5%E7%A8%8B%E5%8C%96/"/>
    
      <category term="工具" scheme="http://shudery.cn/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>基于qrcode开发二维码需求</title>
    <link href="http://shudery.cn/2018/08/14/%E7%AC%94%E8%AE%B0/%E5%9F%BA%E4%BA%8Eqrcode%E7%9A%84%E4%BA%8C%E7%BB%B4%E7%A0%81%E5%BC%80%E5%8F%91/"/>
    <id>http://shudery.cn/2018/08/14/笔记/基于qrcode的二维码开发/</id>
    <published>2018-08-14T15:08:15.000Z</published>
    <updated>2019-02-12T01:37:48.291Z</updated>
    
    <content type="html"><![CDATA[<p>记录实现一个二维码编码渲染的功能，支持将文本（包括 url 字符串在内的所有字节信息）转换为二维码图片并渲染，支持二维码嵌入 Logo 图片。</p>
<a id="more"></a>
<h2 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h2><p>二维码本质是一种密码算法，实现需求前，需要简单了解一下二维码的几个基本概念。</p>
<h3 id="编码模式："><a href="#编码模式：" class="headerlink" title="编码模式："></a>编码模式：</h3><ul>
<li>数字编码(Numeric mode)，支持数字 0-9 的编码；</li>
<li>字符编码(Alphanumeric mode)，支持包括数字 0-9，大写的 A 到 Z，注意没有小写，以及符号\$ % * + – . / : 包括空格的编码；</li>
<li>字节编码(Byte mode)，支持 0-255 的 ISO-8859-1 字符；<br>此外还有日文编码，混合编码等等。</li>
</ul>
<p>通常来说用字节编码可以满足大部分的业务场景，数字编码和字符编码的编码内容比较局限，但是可以支持更大的编码量。</p>
<h3 id="纠错码："><a href="#纠错码：" class="headerlink" title="纠错码："></a>纠错码：</h3><p>顾名思义，纠错码就是允许二维码存在一定数量错误的编码信息。编码后的如果有信息残缺，缺少部分点阵的像素，得益于纠错码，也能够正确的读取信息。利用二维码的这个特性，我们在不更改点阵像素分布的情况下，也可以实现在二维码上嵌入一张 logo 图片，而不影响二维码原本的信息读取。</p>
<p>二维码中有四种级别(L,M,Q,H)的纠错，也称容错系数，最低的级别是 L，它可以校准 7%的字码。之后是可以校准 15％的 M，然后是可以校准 25％的 Q，最后是可以校准 30％的 H。级别越高，纠错能力越强，当然也会牺牲更多的编码容量。</p>
<p>选择什么纠错等级，取决于我们要嵌入的 logo 图片相对二维码的占比大小。</p>
<p><img src="/images/qrcode/3.jpeg" alt=""></p>
<p>需要特别注意的是，二维码有三个带方块的角用于标记二维码的矩形大小，是不能遮挡的，挡住了二维码是无法被准确识别到的，有纠错码也无能为力。至于为什么是三个角而不是四个，是因为三个角就足够标识一个矩形了。通常来说，将嵌入 logo 放到图片正中央，长度最大为二维码边长的 2/7 左右，具体的计算方法是计算 logo 遮挡的像素个数/二维码信息区的像素个数不大于 30%。</p>
<p>二维码不同的 version 下的划区不同，真正存放编码信息的区域也不同。具体的区域信息可以查阅：<a href="https://coolshell.cn/articles/10590.html">二维码生成细节和原理</a></p>
<h3 id="Version-："><a href="#Version-：" class="headerlink" title="Version ："></a>Version ：</h3><p>我们平时看到的二维码有各种像素密度的，根据像素点二维码定义了 40 个尺寸，即 40 个 version</p>
<p><img src="/images/qrcode/2.png" alt=""></p>
<p>点阵越密麻，像素点越多，则 version 越大。最小的二维码是 21x21 像素，为 Version 1，25x25 像素大小为 Version 2，依此类推。 177x177 大小像素为 Version 40。<br>用 n 表示版本号，版本和像素的关系为 version n : <code>(21 + (n - 1) \* 4)^2 px</code></p>
<p>version 越大，可容纳的编码信息越多，根据纠错指数，编码模式和待转换的字符长度，可以确定渲染二维码的最小 version。version 应该在保证信息编码准确的情况下尽可能小，以提高渲染和识别的性能，二维码各版本的容量可以查阅：<a href="http://muyuchengfeng.xyz/%E4%BA%8C%E7%BB%B4%E7%A0%81-%E5%AD%97%E7%AC%A6%E5%AE%B9%E9%87%8F%E8%A1%A8/">字符容量表</a></p>
<p><img src="/images/qrcode/1.png" alt=""></p>
<h2 id="实现方案"><a href="#实现方案" class="headerlink" title="实现方案"></a>实现方案</h2><p>要快速实现二维码的编码转换，并根据容错系数，信息长度自动调整 version，并绘制成 canvas 图片，社区很早就有许多成熟方案了，并且都大同小异。项目采用了 github 上同类方案 star 就多的 jquery 插件 qrcode.js 来完成这些功能。</p>
<p>网页绘制二维码类似绘制一个黑白棋盘，通常来说有两种方案，一种是使用 canvas，一种是使用 table，table 性能恶心，尤其是在 IE9 以下的此类浏览器中，一般会选择 canvas 来进行绘制。qrcode.js 默认采用 canvas 进行绘制。</p>
<p>除了主要的编码转换和绘制功能，qrcode.js 插件还支持：</p>
<ul>
<li>utf-8 编码自动转换，解决部分 qrcode 扫描器不支持识别非 utf-8 字符的问题</li>
<li>可以自定义二维码的底色和前景色</li>
</ul>
<p>不过结合实际应用场景，还需要修改一下几个地方：</p>
<ul>
<li>logo 嵌入：功能需求</li>
<li>初始编码 version 调为 3：解决低 version 纠错码不够的问题</li>
</ul>
<p>logo 嵌入由于需要侵入改动的地方比较多，最终选择直接 qrcode 组件外部覆盖一层绝对定位的图层展示，qrcode 的源码只需要简单的添加一个 logoSrc 的传入参数，方便插件内部判断，插件源码_getTypeNumber 函数在判断 logoSrc 存在时，将初始 version 调整为 3，这是因为需求设计上 logo 图片 占比较大，在输入较少内容编码为 version1 或者 version2 时，即使纠错等级最大也无法准确识别：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">function _getTypeNumber(sText, nCorrectLevel, logoSrc) &#123;</div><div class="line">  // 嵌入logo时，nType初始值改为3，解决编码内容较少时，纠错码不够的问题</div><div class="line">  var nType = logoSrc ? 3 : 1;</div></pre></td></tr></table></figure>
<p>做完这些工作后，我们就只需要简单的调用 qrcode.js 来渲染二维码了。</p>
<h2 id="遗留问题"><a href="#遗留问题" class="headerlink" title="遗留问题"></a>遗留问题</h2><p>上线后续的测试发现，移动端多个二维码同屏时识别出的信息不准确：</p>
<p>通过渲染器生成二维码在移动端长按，弹出层选择识别二维码，如果手机屏幕同一屏内存在其他二维码图片，那么可能会错误解析为同屏内其他二维码的信息。</p>
<p>查谷歌发现是微信浏览器本身的一个策略导致的：长按图片后弹出识别二维码，识别的对象不是长按的图片，而是整个手机屏幕那一时刻的截屏。</p>
<p>主要有两个方案可以解决，交互层面：二维码加一层交互，点击二维码先触发一个全屏的浮层，再长按，这样整个屏幕就只有单个二维码。技术层面：识别同屏内的二维码，长按时隐藏其他所有二维码图片。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;记录实现一个二维码编码渲染的功能，支持将文本（包括 url 字符串在内的所有字节信息）转换为二维码图片并渲染，支持二维码嵌入 Logo 图片。&lt;/p&gt;
    
    </summary>
    
      <category term="笔记" scheme="http://shudery.cn/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="JavaScript" scheme="http://shudery.cn/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>Daguo的每周清单：第七期</title>
    <link href="http://shudery.cn/2018/04/01/%E6%80%BB%E7%BB%93/Daguo%E7%9A%84%E6%AF%8F%E5%91%A8%E6%B8%85%E5%8D%957/"/>
    <id>http://shudery.cn/2018/04/01/总结/Daguo的每周清单7/</id>
    <published>2018-04-01T05:32:17.000Z</published>
    <updated>2019-02-12T03:07:54.288Z</updated>
    
    <content type="html"><![CDATA[<p>这周朋友圈刷起了下雪的照片和视频，想起在成都四年还是没能一睹雪花纷飞的场景，很是遗憾啊。还以为广东会保持 18 度的秋天风格到过年，下午就收到了明天骤降 10 度的寒潮预警，怕冷的人瑟瑟发抖！</p>
<h2 id="前端基础"><a href="#前端基础" class="headerlink" title="前端基础"></a>前端基础</h2><ul>
<li><p><a href="https://mp.weixin.qq.com/s/nKvjsU2frT5NDU4DLWqvYg?scene=25#wechat_redirect">前后端分离实践</a></p>
<blockquote>
<p>一直以为前后端分离是业界常态，接触的项目比较多了之后，发现很多项目还是保持着和后端的强耦合，接口上依赖后端实现，不事先设计和 mock，部署上和后端 JAVA 代码打成包才能发布，不能独立发布等等情况还很多，很影响开发效率。除非项目就是一帮全栈工程师写的，否则我认为前后端分离应该积极的践行。</p>
</blockquote>
</li>
<li><p><a href="https://www.tuicool.com/wx/Z3uaMzA"><code>(a==1&amp;&amp;a==2&amp;&amp;a==3)</code>有可能是 true 吗？</a></p>
<blockquote>
<p>Javascript 确实神奇，很久以前看到过类似的 toString 的这种用法，但是再次接触到考这个知识点的一个变种题目还是觉得非常有趣。</p>
</blockquote>
</li>
</ul>
<h2 id="JavaScript-生态"><a href="#JavaScript-生态" class="headerlink" title="JavaScript 生态"></a>JavaScript 生态</h2><ul>
<li><a href="https://zhuanlan.zhihu.com/p/35151153?utm_source=wechat_session&amp;utm_medium=social&amp;from=timeline&amp;isappinstalled=0">微信小程序和 PWA 对比分析</a><blockquote>
<p>小程序和 PWA 有着很多相似的地方，技术上都是通过 Web 技术实现可实时更新和跨平台， 通过底层 android/微信的支持接口提供平台能力，可以离线使用 o，相比于传统的 APP 产品  有比较低的实现成本和高的可移植性，如果能处理好性能体验的问题，PWA 和微信小程序的生态都会得到迅速地发展。</p>
</blockquote>
</li>
</ul>
<h2 id="技术视野"><a href="#技术视野" class="headerlink" title="技术视野"></a>技术视野</h2><ul>
<li><p><a href="https://juejin.im/pin/5a695e3b51882563db3cb72d?utm_medium=pwapyq&amp;utm_source=weixinqun&amp;from=timeline">TensorFlow 发布面向 JavaScript 开发者的机器学习框架 TensorFlow.js</a></p>
<blockquote>
<p>随着谷歌的机器学习框架 TensorFlow 发布 TensorFlow.js，感觉 js 也把生态魔抓伸向了一直由 python 占领的机器学习领域，非常兴奋，先 mark 后学</p>
</blockquote>
</li>
<li><p><a href="https://mp.weixin.qq.com/s?__biz=MzIwNjQwMzUwMQ==&amp;mid=2247485752&amp;idx=1&amp;sn=c59b754ad87382c9bb0f67466036a830&amp;chksm=97236bfaa054e2ecf4f2c9b904c99f914b4124cd96bbef00638b2ebf083b0dacf85b9abcee4f&amp;mpshare=1&amp;scene=1&amp;srcid=0128yJYuM72IEU8mokTjIfoo#rd">Bootstrap 4 发布了，可是已经过气了呀</a></p>
<blockquote>
<p>Bootstrap 的第四号版本三年磨一剑，从 15 年开始 Bootstrap4 的第一个 alpha 到现在，说起来那会我还没入行呢，前端技术圈已经发生了翻天覆地的变化。 想起自己当年也是从 Bootstrap 开始撸起页面的，如今由于更新迭代缓慢，同质化和紧耦合，缺少语义而被人诟病，曾经的王者陨落，时代的眼泪啊。</p>
</blockquote>
</li>
</ul>
<h2 id="工程实践"><a href="#工程实践" class="headerlink" title="工程实践"></a>工程实践</h2><ul>
<li><p><a href="https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&amp;mid=2651228053&amp;idx=1&amp;sn=38e580fcf3d059120c4498cdaa4a20a0&amp;chksm=bd495e118a3ed707a0ef2320e748c81a673ec402bdd74969b653e45c3f8ee7d0ae5b6b13dd56&amp;mpshare=1&amp;scene=1&amp;srcid=0316Sj7aMWiooaoXiEEmbmuv#rd">用 JavaScript 写一个区块链</a></p>
<blockquote>
<p>通过用前端 er 熟悉的 javascript 写出来的区块链应用，实现了区块链的一些基础功能，学习理论后配上实践来理解总是更加容易。</p>
</blockquote>
</li>
<li><p><a href="#工程实践">本周开发手记</a></p>
<blockquote>
<p> 大公司的技术产品，尤其是内部应用产品往往采用非常陈旧的技术栈实现， 稳定可靠但是同时积累着一大堆技术债务，可维护性和代码结构越来越差，同时各个模块使用不同的前端技术，难以复用各种业务功能组件。 考虑到不同的前端 MVVM 框架有自己的一套组件系统，如何才能建立一个统一的通用的组件库，其他存量的系统可以  直接引用呢？比如我们统一建立一个 Vue 的组件库， 封装了一些 Vue 的业务功能组件， 那么其他的产品如果使用的是 react 或者 angular 要如何接入？ 一种方案是参考业界的将 Vue 组件库重构一个 react 版本和 angular 版本， 但是由于需要采用这种策略需要重构的工作量和人力完全无法匹配，我们目前暂时采用了第二种，就是直接引入 vue 组件依赖的包括 vue.js 在内的所有  文件， 好在 vue 所有的依赖加起来也就 100K， 这毫无疑问会影响原先页面的性能，所以我们也在积极地推部门使用同一的前端技术栈，这样就可以无缝使用组件库的组件了。除了性能问题，兼容性问题也是需要考虑的点，虽然现在通过在 index.html 绑定不同的 dom 可以实现各自框架的逻辑没有问题，但多个框架总是让我觉得不太放心。</p>
</blockquote>
</li>
</ul>
<h2 id="良心推荐"><a href="#良心推荐" class="headerlink" title="良心推荐"></a>良心推荐</h2><ul>
<li><p><a href="https://segmentfault.com/a/1190000004646121">KeystoneJS</a></p>
<blockquote>
<p>上周推荐了小程序的后端服务接口商城，除了小程序后端，我们经常在开发完页面之后需要做一个管理后台来可视化地操作我们的持久化数据，同时后端需要配置路由和数据库，所有的这一切 Keystone 都能帮助前端工程师解决，它基于 express，让前端又一次“全栈”。</p>
</blockquote>
</li>
<li><p><a href="https://item.jd.com/12176536.html">Vue2 实战教程</a></p>
<blockquote>
<p>来自梁睿坤大佬的实战经验书籍，Vue2 实战教程可以说是干货满满，通过实际项目讲解 Vue 开发一个项目需要注意的方法面面， 有很多概念解析很有想法，踩过的一些坑也是无私分享，本周看了三分之二，就忍不住强力推荐啦。</p>
</blockquote>
</li>
</ul>
<h2 id="效率工具"><a href="#效率工具" class="headerlink" title="效率工具"></a>效率工具</h2><ul>
<li><a href="http://cssreference.io/">CSS 用法快速搜索</a><blockquote>
<p>在知乎上看到的，可以快速搜索 CSS 的一些属性， 一般我通过模糊搜索找到自己有点忘了怎么用的一些属性，点进去后，神清气爽，所有的 demo 和注意事项都给你列出来了， 瞬间就加深了对属性的了解，而且界面非常好看。</p>
</blockquote>
</li>
</ul>
<h2 id="总结-amp-吐槽"><a href="#总结-amp-吐槽" class="headerlink" title="总结&amp;吐槽"></a>总结&amp;吐槽</h2><p>本周虽然每晚都是十点后回家，8106，好像是来部门后过得最忙的一周了吧， 但是感觉也是最充实的一周， 技术上做了很多技术方面的预研，学习了一些项目启动，工程化的方法论，通过试验写 demo 实践了许多存有疑惑的知识点。下周又有新的任务，要适应多核工作的局面，另外个位数的温度重回广东，还得适应下寒冷。下周想把我的大 F 带到公司去。</p>
<p>说起来好像接下来每周都要上 6 天班，知道年后回来的第二个星期，看来周末又出不了坂田这块地了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这周朋友圈刷起了下雪的照片和视频，想起在成都四年还是没能一睹雪花纷飞的场景，很是遗憾啊。还以为广东会保持 18 度的秋天风格到过年，下午就收到了明天骤降 10 度的寒潮预警，怕冷的人瑟瑟发抖！&lt;/p&gt;
&lt;h2 id=&quot;前端基础&quot;&gt;&lt;a href=&quot;#前端基础&quot; class=
    
    </summary>
    
      <category term="总结" scheme="http://shudery.cn/categories/%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="技术周报" scheme="http://shudery.cn/tags/%E6%8A%80%E6%9C%AF%E5%91%A8%E6%8A%A5/"/>
    
  </entry>
  
  <entry>
    <title>Daguo的每周清单：第六期</title>
    <link href="http://shudery.cn/2018/03/11/%E6%80%BB%E7%BB%93/Daguo%E7%9A%84%E6%AF%8F%E5%91%A8%E6%B8%85%E5%8D%956/"/>
    <id>http://shudery.cn/2018/03/11/总结/Daguo的每周清单6/</id>
    <published>2018-03-11T05:32:17.000Z</published>
    <updated>2019-02-12T03:07:54.288Z</updated>
    
    <content type="html"><![CDATA[<p>回广东工作后，再次感受到了 3 月初就可以穿短袖的气候，不过才热了几天就又冷了回去，马上就是要迎接回南天的到来了吧？还记得前年去广州实习的时候连续 3 个多月的梅雨天气，广东的雨季，也是久违了。</p>
<h2 id="前端基础"><a href="#前端基础" class="headerlink" title="前端基础"></a>前端基础</h2><ul>
<li><p><a href="https://zhuanlan.zhihu.com/p/33999571?utm_source=tuicool&amp;utm_medium=referral">谈谈 Vue 业务组件</a></p>
<blockquote>
<p>来自饿了么前端团队对于组件和业务组件封装的理解，通常在写业务代码的时候，我们需要对一些基础的组件库进行封装，最简单的添加个样式，修改一下颜色，或者添加个图标，很多基础组件没有提供出来接口，有时候还需要写一些比较有入侵性的代码，比如根据组件内部的结构样式，写一些样式来改变展示效果，添加一些自定义方法等。</p>
</blockquote>
</li>
<li><p><a href="https://juejin.im/post/58e3a5a0a0bb9f0069fc16bb">一劳永逸的搞定 flex 布局</a></p>
<blockquote>
<p>现在写页面布局我都倾向于用 flex 来搞定，真的非常好用，在旧版浏览器已经被普罗大众抛弃的今天，它兼容性不足的问题似乎微不足道了。</p>
</blockquote>
</li>
</ul>
<h2 id="技术视野"><a href="#技术视野" class="headerlink" title="技术视野"></a>技术视野</h2><ul>
<li><p><a href="https://qianduan.group/posts/5a8e62160cf6b624d2239ca7">前端神器：一行命令，React 组件转 Vue 组件!</a></p>
<blockquote>
<p>很久之前就在想像 element-ui 和 ant design 这些前端组件库，基于某种框架实现后，为了迎合市场需求，必然会提供出多种框架实现，比如 element 原本是基于 vue 的，后来也退出了基于 react 和 angular 的版本，组件开发团队是如何重构的呢？基于一种框架实现，了解另一种框架语法后自己一个个去重构吧？后来我看到 vue 和 react 都支持 render 函数去渲染逐渐，这是一些语法差异，完全可能通过映射关系编译成不同的参数写法。然后我就看到了这个转换的工具，虽然不能完全无缝地编译转换 React 组件，但是可以节约很多重构组件的时间，如果在转换地过程能输出 React 哪些东西无法映射转换为 Vue，并给出提示和方案就好了。</p>
</blockquote>
</li>
<li><p><a href="https://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&amp;mid=2651747630&amp;idx=1&amp;sn=dfb85acb20fbfcb4a8908917357be662&amp;chksm=bd12ac638a652575eb5e542e8159b903b8061ceeb32434ae50e2631a039eddc01e01b2837b95&amp;mpshare=1&amp;scene=1&amp;srcid=0308fhf1zmTBxZHHtSCHpRoN#rd">美团开源小程序开发框架 mpvue</a></p>
<blockquote>
<p>这也是一个代码的转换工具，将 vue 工程代码转为小程序。感觉现在前端轮子越来越多之后，基于 webpack 的一些转换编译工具突然就火了起来，其实这是很正常的现象，原先我们开发小程序需要了解小程序的语法不说，小程序开发工程对组件化的不支持，让很多习惯了前端工程化的 jser 感觉很别扭。mpvue 除了支持将 vue 语法直接转成小程序之外，使用前端统一的样式规范和标签集，让代码可以多端服用，不过现在还不支持 vue-router 这个比较重要的功能。原先的 wepy 其实也是解决相同的痛点，不过 wepy 只是基于 vue 的语法，但它并不是原生 vue 语法，还是有学习成本在。</p>
</blockquote>
</li>
<li><p><a href="https://zoumiaojiang.com/article/what-is-real-webpack-plugin/">看清楚真正的 Webpack 插件</a></p>
<blockquote>
<p>webpack 如今已经成为前端工程化事实上的基础，构建，打包，各种配置功能，如今已经很少看到曾经 gulp 和 grunt 的身影了，通过 loader 和 plugin 的不断丰富 webpack 的能力，像共同代码提取，markdown 文档解析，服务代理等等，让前端开发越来越规范化。</p>
</blockquote>
</li>
<li><p><a href="https://mp.weixin.qq.com/s?__biz=MzIwMzg1ODcwMw==&amp;mid=2247487547&amp;idx=1&amp;sn=ca3e0055978c4ad7d2deacc9503bdeaf&amp;chksm=96c9a65ba1be2f4d5854e3d9041fac2b87541ec30f6c3cb9bd4c70701788994c94234ba88308&amp;mpshare=1&amp;scene=1&amp;srcid=0309C6Wu3ECbEqDntnNYWe8o#rd">我模拟了一个用浏览器挖矿的代码，没多复杂但别走歪路</a></p>
<blockquote>
<p>区块链技术给予的启示，但我总觉得就是分布式计算的思想。</p>
</blockquote>
</li>
<li><p><a href="https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&amp;mid=2651227961&amp;idx=1&amp;sn=d4eb72b910281a18fc35581e0e39096f&amp;chksm=bd495ebd8a3ed7ab2dcc8d6bbfdd6f336f5b80a301cd3e7f92f56bdd3c95c749d9d6fd77282f&amp;mpshare=1&amp;scene=1&amp;srcid=0310Ep0q8srjqfcy2KsmGrlY#rd">危险的 target=”_blank” 与 “opener”</a></p>
<blockquote>
<p>前端的黑客技术总是给人惊喜，在非常简单的角落，用几个简单的 API 就能制造 web 攻击，之前完全没想到点外链跳转还有这种攻击操作，涨姿势了。</p>
</blockquote>
</li>
</ul>
<h2 id="良心推荐"><a href="#良心推荐" class="headerlink" title="良心推荐"></a>良心推荐</h2><ul>
<li><p><a href="https://eolinker.com/">eolinker:国产的 API 管理工具</a></p>
<blockquote>
<p>在线 API 文档，支持代码注释直接抽取为 API 文档并在线部署，可以导入 swagger 文件，支持 mock，自动化测试，减少前后端沟通成本。</p>
</blockquote>
</li>
<li><p><a href="https://medium.com/the-mission/the-105-best-tools-to-start-your-business-in-2018-1675a457b4de">The 105 Best Tools to Start Your Business in 2018</a></p>
<blockquote>
<p>创业团队必须知道的 105 款工具，几乎都来自美帝，不得不佩服这工具链实在是强大，亲测了几款都很好用。</p>
</blockquote>
</li>
<li><p><a href="https://github.com/alibaba/ice">飞冰 - 海量可复用物料，通过 GUI 工具极速构建中后台应用</a></p>
<blockquote>
<p>阿里开源的网页生成器，采用阿里淘宝内部最佳实践，统一工程目录和代码结构，解决淘宝的业务交接成本，目前支持的可复用物料，即组件是基于 React 的，阿里目前内部正在统一用 React 作为标准，但也像业界提供 Vue 相关的物料组件，后续支持。</p>
</blockquote>
</li>
</ul>
<h2 id="总结-amp-吐槽"><a href="#总结-amp-吐槽" class="headerlink" title="总结&amp;吐槽"></a>总结&amp;吐槽</h2><p>感觉现在在技术上遇到一些瓶颈，想要突破 还是需要静下心来细读一些文章，实践一些代码呀。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;回广东工作后，再次感受到了 3 月初就可以穿短袖的气候，不过才热了几天就又冷了回去，马上就是要迎接回南天的到来了吧？还记得前年去广州实习的时候连续 3 个多月的梅雨天气，广东的雨季，也是久违了。&lt;/p&gt;
&lt;h2 id=&quot;前端基础&quot;&gt;&lt;a href=&quot;#前端基础&quot; class
    
    </summary>
    
      <category term="总结" scheme="http://shudery.cn/categories/%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="技术周报" scheme="http://shudery.cn/tags/%E6%8A%80%E6%9C%AF%E5%91%A8%E6%8A%A5/"/>
    
  </entry>
  
  <entry>
    <title>Daguo的每周清单：第五期</title>
    <link href="http://shudery.cn/2018/02/25/%E6%80%BB%E7%BB%93/Daguo%E7%9A%84%E6%AF%8F%E5%91%A8%E6%B8%85%E5%8D%955/"/>
    <id>http://shudery.cn/2018/02/25/总结/Daguo的每周清单5/</id>
    <published>2018-02-25T05:32:17.000Z</published>
    <updated>2019-02-12T03:07:54.232Z</updated>
    
    <content type="html"><![CDATA[<p>新年开工第一周，没有收到开工红包，不过收到了之前去北京出差的补贴也是蛮开心的。这周很多同事都请假了，好多个工位都还是空荡荡的，任务比较少，不过下周开始应该又会变得忙碌了。</p>
<h2 id="前端基础"><a href="#前端基础" class="headerlink" title="前端基础"></a>前端基础</h2><ul>
<li><p><a href="https://zhuanlan.zhihu.com/p/33819883?utm_source=wechat_session&amp;utm_medium=social">ajax 跨域完全讲解</a></p>
<blockquote>
<p>由公司同事讲解的 ajax 跨域问题，录制成视频发布在慕课网，非常清晰，作为前端在完全理清跨域问题的同时，可以了解一下后端的编程过程以及解决跨域的方法。</p>
</blockquote>
</li>
<li><p><a href="https://segmentfault.com/a/1190000013331105?utm_source=index-hottest">面试的信心来源于过硬的基础</a></p>
<blockquote>
<p>总结了前端一些常见的问题技巧，有一些问题虽然没有遇到也没有试验过，不过给我在遇到问题的时候提供了很多相关的思路。</p>
</blockquote>
</li>
<li><p><a href="https://zhuanlan.zhihu.com/p/25589193?utm_source=wechat_session&amp;utm_medium=social">Vue.js 的实用技巧</a></p>
<blockquote>
<p>来自饿了么前端的 vue，前端使用技巧，饿了么的前端团队是国内 vue 玩得比较溜的，element-ui 也越来越受开发者的欢迎，通过饿了么前端技术博客了解到了许多 vue 开发过程中的问题和开发技巧。</p>
</blockquote>
</li>
<li><p><a href="https: //segmentfault.com/a/1190000013041329?utm_source=index-hottest">javascript 总结常用工具类的封装</a></p>
<blockquote>
<p>最近刚好在看司徒正美老师的《JavaScript 框架设计》，里面第一章就从类型判断这些基础函数讲起，各大框架/类库是如何封装函数的，这篇文章简单地总结了各种常用的工具函数，简洁好用，更关注实现的优雅，抛弃低版本 IE 的兼容性问题虽是大势所趋，但是曾经面对浏览器兼容的各种 hack 方法还是可以做一次了解，毕竟那曾经也是前端们的核心竞争力。</p>
</blockquote>
</li>
</ul>
<h2 id="技术视野"><a href="#技术视野" class="headerlink" title="技术视野"></a>技术视野</h2><ul>
<li><p><a href="https://mp.weixin.qq.com/s?__biz=MjM5MDE0Mjc4MA==&amp;mid=2651001305&amp;idx=1&amp;sn=1593b0a727a2f62de331165096274ff7&amp;chksm=bdbee98a8ac9609c932ccce1f760514bfc7903a0f6538c2e9834a7ea2f67d92f36409ebfe204&amp;mpshare=1&amp;scene=1&amp;srcid=0222RzGyi3QC71hswU6vmSMd#rd">春节假期技术圈都发生了哪些大新闻？</a></p>
<blockquote>
<p>春节回家除了胖三斤之外，还堕落了好多天，赶紧补一下春节期间技术圈的新闻。</p>
</blockquote>
</li>
<li><p><a href="https://github.com/sundy-li/wechat_brain">知乎答题王(头脑王者)辅助工具</a></p>
<blockquote>
<p>前端时间答题闯关可以说是火了一把，不过个人觉得了解那么多离日常生活太远的题目是一件很枯燥的事。这个项目爬了大量题目和答案，通过抓包更改手机端界面，自动地给答题者展示答案。之前还看到一个不是通过事先存储大量题目答案的，而是通过直接百度搜索，然后根据选项答案在搜索结果中出现的次数来判断哪一个是正常答案。</p>
</blockquote>
</li>
</ul>
<h2 id="工程实践"><a href="#工程实践" class="headerlink" title="工程实践"></a>工程实践</h2><ul>
<li><a href="https://github.com/lenve/vhr">vhr:前后端分离的人力资源管理系统</a><blockquote>
<p>一个管理系统，包括 element-ui 做的前端和 spring boot 做的后端，提供了许多管理系统应该具备的功能。之前简单学过一段时间 java，所以我也用 idea 把服务端代码跑了起来，再通过 datagrip 链接 mysql 数据库跑脚本生成数据。整个过程跑通非常简单，前端虽然没有提供足够的定制接口，但不失为一个可以拿来加工的管理系统，作为 github 摘抄员我默默地 star 了下来 </p>
</blockquote>
</li>
</ul>
<h2 id="总结-amp-吐槽"><a href="#总结-amp-吐槽" class="headerlink" title="总结&amp;吐槽"></a>总结&amp;吐槽</h2><p>今天戊戌年正月初十，党中央建议废除国家主席不得连任两届的规定，朋友圈刷屏，一个决定往往要由之后的历史来判断好坏，说的大概就是这种情况吧[捂脸]。</p>
<p>一个产品成功的关键是什么呢，互联网产品经历了这么多年的打磨，创业热潮一轮一轮下来，随着现在互联网红利骤降开始冷却，这里面产品的运作模式是什么，现在和以前一样吗，这是我最近想了解的问题啊。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;新年开工第一周，没有收到开工红包，不过收到了之前去北京出差的补贴也是蛮开心的。这周很多同事都请假了，好多个工位都还是空荡荡的，任务比较少，不过下周开始应该又会变得忙碌了。&lt;/p&gt;
&lt;h2 id=&quot;前端基础&quot;&gt;&lt;a href=&quot;#前端基础&quot; class=&quot;headerlink
    
    </summary>
    
      <category term="总结" scheme="http://shudery.cn/categories/%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="技术周报" scheme="http://shudery.cn/tags/%E6%8A%80%E6%9C%AF%E5%91%A8%E6%8A%A5/"/>
    
  </entry>
  
  <entry>
    <title>Daguo的每周清单：第四期</title>
    <link href="http://shudery.cn/2018/02/10/%E6%80%BB%E7%BB%93/Daguo%E7%9A%84%E6%AF%8F%E5%91%A8%E6%B8%85%E5%8D%954/"/>
    <id>http://shudery.cn/2018/02/10/总结/Daguo的每周清单4/</id>
    <published>2018-02-10T05:32:17.000Z</published>
    <updated>2019-02-12T03:07:54.232Z</updated>
    
    <content type="html"><![CDATA[<p>这周请假两天回家参加哥们的婚礼，时光恍惚，如今身旁的小伙伴都是谈婚论嫁的年纪了啊。<br>参加完婚礼后，因为刚刚搬新家，所以和老妈一起铺床单，整理了之前寄回家的书籍，然后就匆匆赶回深圳了，要奋斗到除夕前一天再回啦。</p>
<h2 id="前端基础"><a href="#前端基础" class="headerlink" title="前端基础"></a>前端基础</h2><ul>
<li><p><a href="https://mp.weixin.qq.com/s?__biz=MzAwNTAzMjcxNg==&amp;mid=2651425190&amp;idx=1&amp;sn=5f04ad6a295880236cd56a7ea2546443&amp;chksm=80dff7c5b7a87ed332a057a01d7730f345dc2fd7c110ef177663796ec2848ff785cc9e09933a&amp;mpshare=1&amp;scene=1&amp;srcid=0207ubosoNQaA9LvZx77cOqg#rd">React 中 setState() 为什么是异步的？</a></p>
<blockquote>
<p>从比较深的场景和框架内部实现解释为什么 React 中 setState 是异步的，React 模型更愿意保证内部的一致性和状态提升的安全性，而不总是追求代码的简洁性。</p>
</blockquote>
</li>
<li><p><a href="https://zhuanlan.zhihu.com/p/31360204">4 张动图解释为什么（什么时候）使用 Redux</a></p>
<blockquote>
<p> 当你纠结需不需要用的时候，那么还是用吧。这点学习成本还是可以接受的。这篇文章非常鲜明地描述了使用 Redux 的场景，自然而然地清楚了 Redux 解决的问题。</p>
</blockquote>
</li>
<li><p><a href="https://yugasun.com/post/you-dont-know-vuejs-6.html">你不知道的 Vuejs</a></p>
<blockquote>
<p> 前端有一个著名的 Javascript 系列：你不知道的 Javascript。偶然看到这个你不知道的 Vuejs，比较基础，但是又有别于官网，可以拿来入门 Vue。</p>
</blockquote>
</li>
<li><p><a href="https://zhuanlan.zhihu.com/p/33688711?utm_source=wechat_session&amp;utm_medium=social">三分钟学会用 js + css3 打造酷炫 3D 相册</a></p>
<blockquote>
<p>js 的能力越来越强大导致我常常忽略了 css 和 html，其实 css3 的能力是非常强大的，这一点毋庸置疑，这个教程利用景深控制照片 z 轴的思路实现炫酷的 3D 相册。</p>
</blockquote>
</li>
</ul>
<h2 id="JavaScript-生态"><a href="#JavaScript-生态" class="headerlink" title="JavaScript 生态"></a>JavaScript 生态</h2><ul>
<li><a href="https://segmentfault.com/a/1190000013241874">了解 NodeJS 看这一篇就够了</a><blockquote>
<p>Node 将 Javascirpt 带到了浏览器以外的地方，两年前刚学到 Node 就觉得它非常牛皮，极大地扩大了 JSer 的视野（事业），这篇介绍让我又一次复习了 Node 服务器的优势以及用 Node 开发 web 服务器的方法。</p>
</blockquote>
</li>
</ul>
<h2 id="技术视野"><a href="#技术视野" class="headerlink" title="技术视野"></a>技术视野</h2><ul>
<li><a href="https://www.ibm.com/developerworks/cn/iot/library/iot-lp101-get-started-develop-iot-home-automation/index.html">IOT 应用开发教程，基于 Node-RED</a><blockquote>
<p>家里老爸老妈换了新房子，添置了一些智能家居，让我对 Iot 物联网又燃起了兴趣，未来 AI 肯定是趋势，如何融入平民生活则是 AI 大潮爆发的关键，那么智能家居则是非常关键的一点，它确实可以提升生活的质量和幸福感，而且在我老家这种五线城市的小区，小市民都已经知道智能马桶，扫地机器人，而且也可以很好地接受它们，这也是我认为智能家居的生活离我们很近了的原因。</p>
</blockquote>
</li>
</ul>
<h2 id="工程实践"><a href="#工程实践" class="headerlink" title="工程实践"></a>工程实践</h2><ul>
<li><p><a href="https://zhuanlan.zhihu.com/p/30948290?utm_source=wechat_session&amp;utm_medium=social">从零开始搭建 Vue 组件库 VV-UI</a></p>
<blockquote>
<p>流行的前端组件库都具有一定的通用性，但是在实际的业务场景中往往需要对这些开源组件做一些修改和封装，这个时候需要有一个和组件工程联系的文档工程，可以用来测试组件的展示效果已经提供接口文档和在线例子。这个 VV-UI 基于 vue-markdown-loader 支持在 md 文件中直接使用 vue 组件，并渲染 template，和 element-ui 的文档工程类似，但是还没有支持锚点等 md 文件的常见转换功能。</p>
</blockquote>
</li>
<li><p><a href="https://segmentfault.com/a/1190000010976507">树莓派如何完全无头(无屏无网线无键盘鼠标)安装</a></p>
<blockquote>
<p>之前玩 Iot 的时候使用树莓派遇到一个问题就是没有买屏幕键盘和鼠标（无法根据 GUI 安装操作系统）如何安装系统并启动，这篇文章就是教你怎么做到无头启动的。</p>
</blockquote>
</li>
</ul>
<h2 id="良心推荐"><a href="#良心推荐" class="headerlink" title="良心推荐"></a>良心推荐</h2><ul>
<li><a href="https://movie.douban.com/subject/26307755/">季春奶奶</a><blockquote>
<p>昨天看一个广告又想起了这部电非常感人~ 豆瓣评述：讲述的是小时候因为遭遇事故而失踪的孙女，十年后再次和奶奶相遇的故事，充满了令人流泪的感动，她们身上的秘密也令人好奇。</p>
</blockquote>
</li>
</ul>
<h2 id="总结-amp-吐槽"><a href="#总结-amp-吐槽" class="headerlink" title="总结&amp;吐槽"></a>总结&amp;吐槽</h2><p>今天周末加班，补春节假期。回家和朋友聊到什么时候休假，都说除夕前一天，然后下意识会问，你们不是吗，法定工作日呀，公司应该都一样吧，哈哈哈。事实是很多人都已经提前请假回家了。春节快到了，附些和程序员相关的<a href="https://www.zhihu.com/question/39950844/answer/84041351">对联</a>，最近对其中这一段很有感触。。</p>
<p>上联：这个其实很简单。<br>下联：原理细节我不管。<br>横批：立马上线。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这周请假两天回家参加哥们的婚礼，时光恍惚，如今身旁的小伙伴都是谈婚论嫁的年纪了啊。&lt;br&gt;参加完婚礼后，因为刚刚搬新家，所以和老妈一起铺床单，整理了之前寄回家的书籍，然后就匆匆赶回深圳了，要奋斗到除夕前一天再回啦。&lt;/p&gt;
&lt;h2 id=&quot;前端基础&quot;&gt;&lt;a href=&quot;#前
    
    </summary>
    
      <category term="总结" scheme="http://shudery.cn/categories/%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="技术周报" scheme="http://shudery.cn/tags/%E6%8A%80%E6%9C%AF%E5%91%A8%E6%8A%A5/"/>
    
  </entry>
  
  <entry>
    <title>Daguo的每周清单：第三期</title>
    <link href="http://shudery.cn/2018/02/03/%E6%80%BB%E7%BB%93/Daguo%E7%9A%84%E6%AF%8F%E5%91%A8%E6%B8%85%E5%8D%953/"/>
    <id>http://shudery.cn/2018/02/03/总结/Daguo的每周清单3/</id>
    <published>2018-02-03T15:32:17.000Z</published>
    <updated>2019-02-12T03:07:54.288Z</updated>
    
    <content type="html"><![CDATA[<p> 周二晚上被临时通知去趟北京出差， 参加个研讨会，去了三天，原本的工作计划和学习计划都被打乱。虽然还没去过北京，有点小兴奋，但是因为太突然，什么装备都没有准备，在北京停留几天冻得够呛。还有，北京的糖葫芦是真的咯牙。出差回来后去参加小部门年会，破天荒地抽到一个千元红包，真是本命年行大运啊~</p>
<h2 id="前端基础"><a href="#前端基础" class="headerlink" title="前端基础"></a>前端基础</h2><ul>
<li><p><a href="https://www.liayal.com/article/5a6b07137de5e93eee4137ca?hmsr=toutiao.io&amp;utm_medium=toutiao.io&amp;utm_source=toutiao.io">扒一扒小程序的坑</a></p>
<blockquote>
<p>每次逛社区，基本上所有带有坑字的我都会看，很奇妙，做一个东西踩过的坑，很可能是作者多个下午踩出来的，读起来有吸取别人精华的感觉。如果有些坑你也踩过的话，很容易引发共鸣，然后再重新思考问题的原因。小程序其实还是有不少坑的，而且很多是小程序特有，不深入源码也不清楚为什么会出现那样的情况，这种坑往往特别浪费时间。</p>
</blockquote>
</li>
<li><p><a href="https://segmentfault.com/a/1190000013008420">VUE 使用中踩过的坑</a></p>
<blockquote>
<p>踩坑总结再来一发，偏基础，很多都知道了，但还是可以复习一遍。</p>
</blockquote>
</li>
<li><p><a href="https://juejin.im/post/5a6f1c0f518825733f6e4436?utm_medium=fe&amp;utm_source=weixinqun&amp;from=timeline">一百行 js，实现极简头脑王者辅助</a></p>
<blockquote>
<p> 之前愚人节做过一次拦截微信 web 端的人物头像地址，改成一张提示今天是愚人节不要受骗的图， 那个时候没有直接在微信做，应该手机端做抓包的配置没搞好。这个实践结合抓包和爬虫，快速搜索  答题选项在百度搜索问题后出现的次数，来指示正确的选项，挺好玩的 。</p>
</blockquote>
</li>
</ul>
<h2 id="JavaScript-生态"><a href="#JavaScript-生态" class="headerlink" title="JavaScript 生态"></a>JavaScript 生态</h2><ul>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzAwNTAzMjcxNg==&amp;mid=2651425182&amp;idx=1&amp;sn=f34e85da64ec0319831f3d6b08ff16b0&amp;chksm=80dff7fdb7a87eeb5b8dd766ada29b3c74102759f6f0ebf2370a199fb15110b27b2be4704e86&amp;mpshare=1&amp;scene=1&amp;srcid=02029M5pSRPbnn5D2dm5Dkx1#rd">前端 AI 之路: KerasJS 初探</a><blockquote>
<p>JS 如今攻陷多个领域，很多前沿技术都有涉水，但是在人工智能只一块，python 同样带有脚本的优势，而且在第三方库的支持上是 Node 远远不能及的。这个项目通过 Python 训练出来的神经网络模型，提供给 nodejs 识别圣诞老人头像，算是将 Nodejs 强行 AI 了一下，还是挺有意思的。</p>
</blockquote>
</li>
</ul>
<h2 id="技术视野"><a href="#技术视野" class="headerlink" title="技术视野"></a>技术视野</h2><ul>
<li><p><a href="https://mp.weixin.qq.com/s?__biz=MjM5NTEwMTAwNg==&amp;mid=2650213960&amp;idx=2&amp;sn=add902d089f977fc2fd3562d643971e9&amp;chksm=befe0e698989877f2e2c5a34e1d39bb5c96aa731421c1c29f4144265798656cd1b8fac3e6b25&amp;mpshare=1&amp;scene=1&amp;srcid=01303xeAjnTQKkxOpUZaGI0C#rd">多研究些架构，少谈些框架</a></p>
<blockquote>
<p>在外包团队开发项目中，前端微服务可以节约成本， 但是一个真正玩转起微服务的开发项目，会是一个怎样的工程水准呢？</p>
</blockquote>
</li>
<li><p><a href="https://www.w3ctrain.com/2018/02/01/javascript-event-loop/">How JavaScript Works？—— Event Loop</a></p>
<blockquote>
<p>被这个 Hexo theme 吸引了，然后看了一下写得很好，关于 Javascript 的 Event loop 深入了解后可以解决很多单线程问题。</p>
</blockquote>
</li>
</ul>
<h2 id="工程实践"><a href="#工程实践" class="headerlink" title="工程实践"></a>工程实践</h2><ul>
<li><p><a href="https://github.com/skyFi/weapp-starter">微信小程序开发最佳实践</a></p>
<blockquote>
<p>重点关注小程序生态下，代码结构和项目开发和语法组织与其他项目的区别。</p>
</blockquote>
</li>
<li><p><a href="https://segmentfault.com/a/1190000012345156">从放弃迅雷和 IDM 到自己开发下载工具</a></p>
<blockquote>
<p>动手开发下载工具，下片从此不再限流。</p>
</blockquote>
</li>
</ul>
<h2 id="总结-amp-吐槽"><a href="#总结-amp-吐槽" class="headerlink" title="总结&amp;吐槽"></a>总结&amp;吐槽</h2><p>有许多写了多年代码的互联网民工都已经非常厌倦写代码了，我常常思考，我以后会不会也这样子。现在因为还有很多除了做技术实现以外的事情要做，要管理外包团队，要给上级写材料，要给各个团队做支撑，确实很少有时间写代码了。</p>
<p>我现在反而非常渴望有写代码的时间，那就是我的全部或者大部分的工作内容，每个技术实现背后的技术我都想好好的研究透，然后灵活运用在各个技术领域，做到融汇贯通，我想要实现这样都是一辈子的事情吧。</p>
<p>做各种技术尝试和实现，不要做一些重复的燃料加工，想着如何漂亮地 coding，怎么做个 engineer 而不是 coder，想着怎样更好地实现那些重复的代码行和它内在的原理，这才是有意思的事情啊。这是我给自己的忠告，有时厌倦不是它不好，或者你不爱了，而是你不曾真正感受它的魅力。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt; 周二晚上被临时通知去趟北京出差， 参加个研讨会，去了三天，原本的工作计划和学习计划都被打乱。虽然还没去过北京，有点小兴奋，但是因为太突然，什么装备都没有准备，在北京停留几天冻得够呛。还有，北京的糖葫芦是真的咯牙。出差回来后去参加小部门年会，破天荒地抽到一个千元红包，真
    
    </summary>
    
      <category term="总结" scheme="http://shudery.cn/categories/%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="技术周报" scheme="http://shudery.cn/tags/%E6%8A%80%E6%9C%AF%E5%91%A8%E6%8A%A5/"/>
    
  </entry>
  
  <entry>
    <title>Daguo的每周清单：第二期</title>
    <link href="http://shudery.cn/2018/01/28/%E6%80%BB%E7%BB%93/Daguo%E7%9A%84%E6%AF%8F%E5%91%A8%E6%B8%85%E5%8D%952/"/>
    <id>http://shudery.cn/2018/01/28/总结/Daguo的每周清单2/</id>
    <published>2018-01-28T05:32:17.000Z</published>
    <updated>2019-02-12T03:07:54.288Z</updated>
    
    <content type="html"><![CDATA[<p>这周朋友圈刷起了下雪的照片和视频，想起在成都四年还是没能一睹雪花纷飞的场景，很是遗憾啊。还以为广东会保持 18 度的秋天风格到过年，下午就收到了明天骤降 10 度的寒潮预警，怕冷的人瑟瑟发抖！</p>
<h2 id="前端基础"><a href="#前端基础" class="headerlink" title="前端基础"></a>前端基础</h2><ul>
<li><p><a href="https://mp.weixin.qq.com/s/nKvjsU2frT5NDU4DLWqvYg?scene=25#wechat_redirect">前后端分离实践</a></p>
<blockquote>
<p>一直以为前后端分离是业界常态，接触的项目比较多了之后，发现很多项目还是保持着和后端的强耦合，接口上依赖后端实现，不事先设计和 mock，部署上和后端 JAVA 代码打成包才能发布，不能独立发布等等情况还很多，很影响开发效率。除非项目就是一帮全栈工程师写的，否则我认为前后端分离应该积极的践行。</p>
</blockquote>
</li>
<li><p><a href="https://www.tuicool.com/wx/Z3uaMzA"><code>(a==1&amp;&amp;a==2&amp;&amp;a==3)</code>有可能是 true 吗？</a></p>
<blockquote>
<p>Javascript 确实神奇，很久以前看到过类似的 toString 的这种用法，但是再次接触到考这个知识点的一个变种题目还是觉得非常有趣。</p>
</blockquote>
</li>
</ul>
<h2 id="JavaScript-生态"><a href="#JavaScript-生态" class="headerlink" title="JavaScript 生态"></a>JavaScript 生态</h2><ul>
<li><a href="http://blog.csdn.net/baidu_browser/article/details/64440238">微信小程序和 PWA 对比分析</a><blockquote>
<p>小程序和 PWA 有着很多相似的地方，技术上都是通过 Web 技术实现可实时更新和跨平台， 通过底层 android/微信的支持接口提供平台能力，可以离线使用 o，相比于传统的 APP 产品  有比较低的实现成本和高的可移植性，如果能处理好性能体验的问题，PWA 和微信小程序的生态都会得到迅速地发展。</p>
</blockquote>
</li>
</ul>
<h2 id="技术视野"><a href="#技术视野" class="headerlink" title="技术视野"></a>技术视野</h2><ul>
<li><p><a href="https://juejin.im/pin/5a695e3b51882563db3cb72d?utm_medium=pwapyq&amp;utm_source=weixinqun&amp;from=timeline">iOS 支持 service worker 的意义</a></p>
<blockquote>
<p>我从不怀疑 PWA 会快速发展，毕竟 Google 有 android 的平台优势，加上 Chrome 的推动，现在 OS 和 iOS 也为支持 PWA 跨出了重要的一步。</p>
</blockquote>
</li>
<li><p><a href="https://mp.weixin.qq.com/s?__biz=MzIwNjQwMzUwMQ==&amp;mid=2247485752&amp;idx=1&amp;sn=c59b754ad87382c9bb0f67466036a830&amp;chksm=97236bfaa054e2ecf4f2c9b904c99f914b4124cd96bbef00638b2ebf083b0dacf85b9abcee4f&amp;mpshare=1&amp;scene=1&amp;srcid=0128yJYuM72IEU8mokTjIfoo#rd">Bootstrap 4 发布了，可是已经过气了呀</a></p>
<blockquote>
<p>Bootstrap 的第四号版本三年磨一剑，从 15 年开始 Bootstrap4 的第一个 alpha 到现在，说起来那会我还没入行呢，前端技术圈已经发生了翻天覆地的变化。 想起自己当年也是从 Bootstrap 开始撸起页面的，如今由于更新迭代缓慢，同质化和紧耦合，缺少语义而被人诟病，曾经的王者陨落，时代的眼泪啊。</p>
</blockquote>
</li>
</ul>
<h2 id="工程实践"><a href="#工程实践" class="headerlink" title="工程实践"></a>工程实践</h2><ul>
<li><p><a href="https://github.com/pablohpsilva/vuejs-component-style-guide/blob/master/README-CN.md">Vue 开发规范</a></p>
<blockquote>
<p>本周开始新的项目后团队需要制定一个开发规范，这对于临时组件的团队来说也是一个适应的过程，大家一起讨论新项目前端的开发方式，组件的封装和状态如何管理，根据业务功能场景画路由图。这是一份非常好的 Vue 开发规范，涉及到用 Vue 开发过程中的方方面面，对于提高项目可维护性很有帮助，而且文档很清楚地告诉你为什么要有这样的规范。</p>
</blockquote>
</li>
<li><p><a href="#工程实践">本周开发手记</a></p>
<blockquote>
<p> 大公司的技术产品，尤其是内部应用产品往往采用非常陈旧的技术栈实现， 稳定可靠但是同时积累着一大堆技术债务，可维护性和代码结构越来越差，同时各个模块使用不同的前端技术，难以复用各种业务功能组件。 考虑到不同的前端 MVVM 框架有自己的一套组件系统，如何才能建立一个统一的通用的组件库，其他存量的系统可以  直接引用呢？比如我们统一建立一个 Vue 的组件库， 封装了一些 Vue 的业务功能组件， 那么其他的产品如果使用的是 react 或者 angular 要如何接入？ 一种方案是参考业界的将 Vue 组件库重构一个 react 版本和 angular 版本， 但是由于需要采用这种策略需要重构的工作量和人力完全无法匹配，我们目前暂时采用了第二种，就是直接引入 vue 组件依赖的包括 vue.js 在内的所有  文件， 好在 vue 所有的依赖加起来也就 100K， 这毫无疑问会影响原先页面的性能，所以我们也在积极地推部门使用同一的前端技术栈，这样就可以无缝使用组件库的组件了。除了性能问题，兼容性问题也是需要考虑的点，虽然现在通过在 index.html 绑定不同的 dom 可以实现各自框架的逻辑没有问题，但多个框架总是让我觉得不太放心。</p>
</blockquote>
</li>
</ul>
<h2 id="良心推荐"><a href="#良心推荐" class="headerlink" title="良心推荐"></a>良心推荐</h2><ul>
<li><p><a href="https://segmentfault.com/a/1190000004646121">KeystoneJS</a></p>
<blockquote>
<p>上周推荐了小程序的后端服务接口商城，除了小程序后端，我们经常在开发完页面之后需要做一个管理后台来可视化地操作我们的持久化数据，同时后端需要配置路由和数据库，所有的这一切 Keystone 都能帮助前端工程师解决，它基于 express，让前端又一次“全栈”。</p>
</blockquote>
</li>
<li><p><a href="https://item.jd.com/12176536.html">Vue2 实战教程</a></p>
<blockquote>
<p>来自梁睿坤大佬的实战经验书籍，Vue2 实战教程可以说是干货满满，通过实际项目讲解 Vue 开发一个项目需要注意的方法面面， 有很多概念解析很有想法，踩过的一些坑也是无私分享，本周看了三分之二，就忍不住强力推荐啦。</p>
</blockquote>
</li>
</ul>
<h2 id="效率工具"><a href="#效率工具" class="headerlink" title="效率工具"></a>效率工具</h2><ul>
<li><a href="http://cssreference.io/">CSS 用法快速搜索</a><blockquote>
<p>在知乎上看到的，可以快速搜索 CSS 的一些属性， 一般我通过模糊搜索找到自己有点忘了怎么用的一些属性，点进去后，神清气爽，所有的 demo 和注意事项都给你列出来了， 瞬间就加深了对属性的了解，而且界面非常好看。</p>
</blockquote>
</li>
</ul>
<h2 id="总结-amp-吐槽"><a href="#总结-amp-吐槽" class="headerlink" title="总结&amp;吐槽"></a>总结&amp;吐槽</h2><p>本周虽然每晚都是十点后回家，8106，好像是来部门后过得最忙的一周了吧， 但是感觉也是最充实的一周， 技术上做了很多技术方面的预研，学习了一些项目启动，工程化的方法论，通过试验写 demo 实践了许多存有疑惑的知识点。下周又有新的任务，要适应多核工作的局面，另外个位数的温度重回广东，还得适应下寒冷。下周想把我的大 F 带到公司去。</p>
<p>说起来好像接下来每周都要上 6 天班，知道年后回来的第二个星期，看来周末又出不了坂田这块地了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这周朋友圈刷起了下雪的照片和视频，想起在成都四年还是没能一睹雪花纷飞的场景，很是遗憾啊。还以为广东会保持 18 度的秋天风格到过年，下午就收到了明天骤降 10 度的寒潮预警，怕冷的人瑟瑟发抖！&lt;/p&gt;
&lt;h2 id=&quot;前端基础&quot;&gt;&lt;a href=&quot;#前端基础&quot; class=
    
    </summary>
    
      <category term="总结" scheme="http://shudery.cn/categories/%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="技术周报" scheme="http://shudery.cn/tags/%E6%8A%80%E6%9C%AF%E5%91%A8%E6%8A%A5/"/>
    
  </entry>
  
  <entry>
    <title>Daguo的每周清单：第一期</title>
    <link href="http://shudery.cn/2018/01/17/%E6%80%BB%E7%BB%93/Daguo%E7%9A%84%E6%AF%8F%E5%91%A8%E6%B8%85%E5%8D%951/"/>
    <id>http://shudery.cn/2018/01/17/总结/Daguo的每周清单1/</id>
    <published>2018-01-17T15:32:17.000Z</published>
    <updated>2019-02-12T03:07:54.231Z</updated>
    
    <content type="html"><![CDATA[<p>新年新气象，还没来得及总结 17 年，我决定先给 18 年立个 flag：每周输出一份技术学习清单。</p>
<h1 id="每周梳理清单的原因？"><a href="#每周梳理清单的原因？" class="headerlink" title="每周梳理清单的原因？"></a>每周梳理清单的原因？</h1><p>其实从 2 年前自学编程开始，我每周基本都会读到许多技术文章和文档，也看过很多的书籍以及视频教程（确实很低效，但不得不说帮我熬过了一段枯燥的时间），然而很多知识一旦没有实践很容易学过就忘了，对于工作量饱和的我来说，似乎又很难有时间去实践每个技术点。</p>
<p>为了能在项目和工作中，遇到技术难题，快速和过往的知识建立起联系，提高解决难题的思维和能力。我决定记录下学过的一些内容，通过回顾，总结学到的知识，以加深对技术的理解。沉淀一些东西，同时推荐一些我个人觉得比较好的技术文章和工具。<br>还有一个原因就是，想写点东西。有人说写作，英语和编程（可视化的，AI 发展起来之后）可能会是以后人类最需要掌握的能力，我很认同，所以也算练习一下吧，突然想起来我好像好久没学过英语了。</p>
<h1 id="和其他技术期刊的区别？"><a href="#和其他技术期刊的区别？" class="headerlink" title="和其他技术期刊的区别？"></a>和其他技术期刊的区别？</h1><p>近年来国内前端技术领域生态十分繁荣，有很多高质量的期刊，像前端之巅，码农周刊，前端早读课我都一直有关注和阅读，我每周的总结推荐里，很多文章可能都是源于这些期刊。区别于其他技术期刊，这个每周清单纯粹是我自己学习过程的一个记录和总结，我会回顾每周我学习的技术内容，做一些梳理和推荐。因为工作任务过于饱和，来不及验证和校对，可能有片面的描述或不严谨的内容，欢迎随时指出。</p>
<h1 id="会整理哪些技术内容？"><a href="#会整理哪些技术内容？" class="headerlink" title="会整理哪些技术内容？"></a>会整理哪些技术内容？</h1><ul>
<li>前端基础：夯实基础知识</li>
<li>JavaScript 生态：不夸张地说，JS 可能要一统天下了</li>
<li>技术视野：开阔眼界，才能和大佬谈笑风生</li>
<li>流行风口：想发技术财就紧跟风口走</li>
<li>工程实践：指尖跃动着茶轴，实践出真知</li>
<li>良心推荐：努力没有用，那一定是效率问题</li>
<li>心得&amp;吐槽 ：思考总结，负能量垃圾桶？</li>
</ul>
<p>另外还有不定期栏目：服务架构（流量大了怎么玩），编程思想（写健壮漂亮的代码），奇技淫巧（原来还有这种操作），书评推荐（也可能有非技术类的书或者电影），效率工具（提高生产力）内容比较少的话也可能直接就放在推荐里面了。然后根据每周的实际情况也会有对应的技术整理，比如我有几周突然就被分配去研究 Iot 物联网应用了，那么可能会出现很多 Iot 的文章推荐。</p>
<h1 id="Daguo-的每周清单"><a href="#Daguo-的每周清单" class="headerlink" title="Daguo 的每周清单"></a>Daguo 的每周清单</h1><hr>
<p>这是首期试验版，外部链接有些可能需要科学上网才能访问。</p>
<h2 id="前端基础"><a href="#前端基础" class="headerlink" title="前端基础"></a>前端基础</h2><ul>
<li><p><a href="https://qianduan.group/posts/5a58d2050cf6b624d2239c44">Lodash 源码中的那些迷人的细节</a></p>
<blockquote>
<p>lodash 是 underscore 的一个超集，两者作为 npm 下载量最大的两个包，其提供的工具函数极大地提高了前端开发人员的开发效率。即使如今 ES6 已经相当普及，用原生 JS 已经可以完成一些 lodash，API 的工作，不过毫无疑问 Lodash 的实现更加可靠高效，不过我还是习惯于直接用原生的接口写代码，虽然它们都只是语法糖而已。Lodash 源码要比很多框架的好解读一些，其中蕴含了许多有趣的 JS 编程技巧。</p>
</blockquote>
</li>
<li><p><a href="https://zhuanlan.zhihu.com/p/29879682">全新 Chrome Devtool Performance 使用指南</a></p>
<blockquote>
<p>在实际开发过程中，我们在做性能优化的时候，常常无从下手，或者说直接应用业界通用的一些优化手段，但是并不知道实际的效果到底如何，这个时候就是我们又一次感叹 Chrome 自带的开发者工具的强大的时候。</p>
</blockquote>
</li>
</ul>
<h2 id="JavaScript-生态"><a href="#JavaScript-生态" class="headerlink" title="JavaScript 生态"></a>JavaScript 生态</h2><ul>
<li><a href="http://bitcoin-on-nodejs.ebookchain.org/2-Node.js%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/1-Nodejs%E5%8E%9F%E6%9D%A5%E5%9C%A8%E5%B8%81%E5%9C%88%E5%A6%82%E6%AD%A4%E6%B5%81%E8%A1%8C%EF%BC%9F.html">Nodejs 区块链技术</a><blockquote>
<p>用 Nodejs 开发加密货币，而且目前 github 上主流的区块链项目大部分就是用 nodejs 写的，不得不说现在 Javascript 真的是啥都能写，让我不禁想起那句，能用 JavaScript 实现的，最终都会用 JavaScript 实现。对于最近的技术风口，区块链以及 Nodejs 有兴趣的话，那这本电子书真是太适合了，我还没读完，决定要好好研读一番。</p>
</blockquote>
</li>
</ul>
<h2 id="技术视野"><a href="#技术视野" class="headerlink" title="技术视野"></a>技术视野</h2><ul>
<li><p><a href="https://micro-frontends.org/">微前端概念解析</a></p>
<blockquote>
<p>我一直以来认为微服务只是后端的概念，知道读了这篇文章，作者提出微服务架构思想同样可以应用于前端，可以将一个应用拆分为多个端到端团队，每个团队都有自己对应的前后端服务，前端也可以运用不同的框架，构建工具。</p>
</blockquote>
</li>
<li><p><a href="https://juejin.im/post/59b631d0f265da0649241368">微信小程序官方开发框架 WePY</a></p>
<blockquote>
<p>我们了解到小程序的开发过程其实有自己的一套服务接口，这给其他平台的迁移造成了一定的难度，虽然它设计的接口都很简单，但是依然有成本。在自己的生态里造出一套开发接口玩，大概也就微信和苹果 ios 这些大佬敢玩吧，当然 ios 似乎过分多了。可能是鉴于小程序开发存在的移植性问题，在小程序正式发布近半年后，微信团队开发并开源了小程序开发框架 WePY，让开发者只需要开发一套代码，通过框架可以自动适配到多个环境，包括小程序，H5 还有 Native 端，同时还能使用像组件化，状态管理等 web 端常用能力，这就是 WePY 的作用。另外基于 vue 编码风格，也是非常容易上手。</p>
</blockquote>
</li>
<li><p><a href="https://www.zhihu.com/collection/96112282">用深度学习自动生成 HTML 代码</a></p>
<blockquote>
<p>陈独秀先生，请收下我的膝盖，这 paper 也太秀了。之前就想过，不说交互效果和 JS 实现，将设计图的切图转成 HTML 和 CSS 应该是可以实现的，就像爬虫爬文章标题，爬日期，都是有规律可询的，只是往往我们要将这些规律做一个梳理，再把这些转换规则写到代码里头，其实跟很多自动化的工具思路是一样的，将所有的情况实现考虑，后面就是自动完成的事情了。现在有了深度学习，只要提供足够的丰富样本，就可以自动的整理出这些规则，将设计图转换为实际代码了，相比人为识别，可以总结出更多的场景，提高转换工具的适用性和可靠性。</p>
</blockquote>
</li>
</ul>
<h2 id="流行风口"><a href="#流行风口" class="headerlink" title="流行风口"></a>流行风口</h2><ul>
<li><p><a href="https://mp.weixin.qq.com/debug/wxagame/dev/index.html?t=2018115">微信推出小游戏，跳一跳开启第一波微信小游戏红利？</a></p>
<blockquote>
<p>小游戏的运行环境是小程序环境的扩展，基本思路也是封装必要的 WEB 接口提供给用户，尽可能追求和 WEB 同样的开发体验。小游戏在小程序环境的基础上提供了 WebGL 接口的封装，使得渲染能力和性能有了大幅度提升。不过由于这些接口都是微信团队通过自研的原生实现封装的，所以并不可以等同为浏览器环境。目前，流行的 HTML5 游戏引擎 Cocos、Egret、Laya 已经完成了自身引擎及其工具对小游戏的适配和支持，对应的官方文档已经对接入小游戏开发做了介绍。</p>
</blockquote>
</li>
<li><p><a href="https://zhuanlan.zhihu.com/p/27658237">Node-RED 构建你的第一条 IOT 应用流</a></p>
<blockquote>
<p>起初是因为需要为产品数字化转型做技术储备，所以需要了解一些业界的 IOT 技术，然后发现了 Node-RED 这个框架，基于可视化模块流编程的物联网应用开发工具，又 IBM 开发维护。结合 NPM 可以下载扩展包，快速地开发一个 IOT 应用 demo，我用它的 HTTP 服务快速地搭建了一个红外感应监控的 IOT 应用，当然了，由于是 Nodejs 平台框架，所以用到的模组需要支持跑 Node 服务才行，我简单粗暴地用树莓派来作实验，很快就能构建好一个应用。依托 IBM 物联网平台还可以做很多商业化地开发扩展。</p>
</blockquote>
</li>
</ul>
<h2 id="工程实践"><a href="#工程实践" class="headerlink" title="工程实践"></a>工程实践</h2><ul>
<li><a href="https://github.com/EastWorld/wechat-app-mall">微信小程序商城 demo</a><blockquote>
<p>小程序商城的通用化 demo，已经实现了基本的商品管理，购物城管理，优惠券管理，地址管理等等 page，同时配合 api 工厂可以快速开发出一个商城应用，花了两天时间以这个 demo 为基础，熟悉了小程序的开发模式和语法，虽然说小程序不支持组件化，但是以 page 为单位的页面，其实已经可以解决复用性的问题，而微信提供的界面 UI 也非常简单，查阅文档，运用好 API 就行了，也不做其他的封装，因为小程序本身的大小有限制，本来就不太可能做业务复杂度太高的应用，所以很多在 Web 端流行的功能并没有在小程序端实现，WePY 只是一个可选项，并不必要。</p>
</blockquote>
</li>
</ul>
<h2 id="良心推荐"><a href="#良心推荐" class="headerlink" title="良心推荐"></a>良心推荐</h2><ul>
<li><a href="https://www.it120.cc/">小程序 API 工厂</a><blockquote>
<p>对于前端来说开发完成小程序后，往往还需要有对应的接口才能顺利交付，这个 Paas 平台支持订阅各种 API，围绕小程序商城实现了很多接口，提供了配置管理页面，还很贴心的支持域名跳转（也就是说你可以把一个域名跳转到这个 Paas 服务平台的管理页面上，这个功能大概是让开发者可以忽悠一下需求方这是个自己实现的后台？），同时平台也在不断丰富 API 类型，除了小程序后台，也可以拿这些 api 开发其他 web 应用，非常好用，重点是它是完全开源免费的，简直是周末做个小项目赚外快的利器啊。</p>
</blockquote>
</li>
</ul>
<h2 id="心得-amp-吐槽"><a href="#心得-amp-吐槽" class="headerlink" title="心得&amp;吐槽"></a>心得&amp;吐槽</h2><p>最近心情总是很忐忑，觉得自己这段时间成长太慢了，也许是对于刚毕业的黄金时间期望太高了。新的一年里要重拾心情，虚心学习，少说多学。成就感要在自我实现里找，不要浪费太多时间在外部环境。下周开始进新的项目组开发，主要会用到 Vue 的技术栈，接下来要好好研究下 Vue 了，由于有一些重构 React 代码的工作量，所以应该还要好好看看 React。这也是个好的契机，安心学技术的同时，看看大项目是怎么运作的。</p>
<p>前几天一个内部 IT 产品生产环境出了问题，附件上传保存失败，无提示，用户反映后 2 天才修复，印证了比利老哥那句嘲讽：边缘产品你想造个二级事件都难，哈哈。</p>
<p>说几个最近改变我认知的情况，其中缘由就不说破了：1、以前完全不关心保健品，上次去香港买了几瓶。2、由于信仰高效学习的信条，让我处理事情变得圆润起来。3、屏蔽广告商广告后，广告商赚了，广告投放的平台亏了。4、在互联网上你看到什么，很大程度上取决于你想看什么。5、戴上 MDR-1000X，原来世界如此安静。</p>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>还有不到一个月就春节了，最后再简单说去年下半年来的生活吧。基本就是一个毕业生刚工作时最普遍的状态吧，学着融入工作，社会，观察着周围新的人和事，加着班，吐着槽。熟悉了业务和工作方式后，慢慢适应，然后劳累地结束周复一周的工作。</p>
<p>工作内容虽然有很多重复，但是对于技术新人和职场菜鸟来说还是有很多可以挖掘学习的地方，把自己原先空白的认知慢慢地填补上去，这算是工作里最大的乐趣吧。学习方式还是按着自己的节奏来，新技术基本上看官方文档配合一个简单项目的 demo 就可以入门，后端学习过程中有一些阻力，因为入门的资料会少一些不过也问题不大，另外英文学习要加强。日常工作的备忘，问题，工作量都记在 keynote 上面，对效率提升和总结很有帮助。为了整理思路输出，房间墙上整了一块大白板，可以粗略地做一些梳理。开始接触听音这类学习方式，所谓文科生听为你读诗，理科生听知识内参，内参的知识点都比较精辟而且是最新的，每天上班路上会听大概十分钟把握下行业动态和发展趋势。</p>
<p>工作以外，所剩不多的业余时间还是过得比较单调随意，因为还是要为工作状态休养准备。根据豆瓣的记录，看的电影和书籍比上半年在学校要明显减少。再看了下 rescueTime 的记录，大部分娱乐时间还是花在看综艺，直播，刷知乎和即刻上面，综艺主韩综，直播只看浪师傅，木鱼水心和敖厂长的 up 基本都看了。以前玩游戏觉得是很好的放松方式，现在觉得那都太吸神了，所以也把 switch 从上半年的想买清单去掉了。新番基本都不看剧情类了，偏治愈和搞笑的，比如某国漫南国篇。入冬以来好久没打球了，不过偶尔看到集锦依然热血沸腾。健身同样入冬以来有所减少，不过倒还是一直坚持。其他像理财知识，房价，汽车，社保等内容都抽空去了解了一些，觉得这些都是早晚需要知道的内容。其中对于理财比较有感，学习过程中多次感受到资本力量的可怕，另外由于买房不实际，为了给攒钱找个理由，还定了个买某 200 型号车的目标。</p>
<p>深圳生活。坂田的生活其实还是挺不错的，虽然我经常自嘲郊区，但是郊区物价是真的实惠，已经去过很多家好吃又便宜的餐馆了，周边基本的设施，商城，电影院，羽毛球馆，篮球场都齐全。周末和朋友去市内虽然得转乘才能到地铁站，但是已经比在成都科大上学的时候要入市方便多了。住在佳兆业虽然没有小区篮球场，一开始还挺无法接受的，后来在这里度过了许多个静谧的周末下午，竟然也觉得很喜欢了。</p>
<p>第一期废话比较多，以后每周清单就只有技术总结和推荐，希望能坚持~</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;新年新气象，还没来得及总结 17 年，我决定先给 18 年立个 flag：每周输出一份技术学习清单。&lt;/p&gt;
&lt;h1 id=&quot;每周梳理清单的原因？&quot;&gt;&lt;a href=&quot;#每周梳理清单的原因？&quot; class=&quot;headerlink&quot; title=&quot;每周梳理清单的原因？&quot;&gt;&lt;/
    
    </summary>
    
      <category term="总结" scheme="http://shudery.cn/categories/%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="技术周报" scheme="http://shudery.cn/tags/%E6%8A%80%E6%9C%AF%E5%91%A8%E6%8A%A5/"/>
    
  </entry>
  
  <entry>
    <title>物联网的敲门砖：实现一个简单的IoT应用</title>
    <link href="http://shudery.cn/2017/10/08/%E7%AC%94%E8%AE%B0/%E7%89%A9%E8%81%94%E7%BD%91%E7%9A%84%E6%95%B2%E9%97%A8%E7%A0%96%EF%BC%9A%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84IoT%E5%BA%94%E7%94%A8/"/>
    <id>http://shudery.cn/2017/10/08/笔记/物联网的敲门砖：实现一个简单的IoT应用/</id>
    <published>2017-10-08T15:32:17.000Z</published>
    <updated>2019-02-12T02:52:12.937Z</updated>
    
    <content type="html"><![CDATA[<p>物联网概念的提出已久，业界早就有相应的实践和应用，受限于网络带宽和传感器技术，尚未普及，此外这种偏智能化的场景，注定需要一定的时间才能走进大众家庭。在物联网中，技术应用架构是怎样的，与传统互联网有何区别？为了弄清其中的关系和技术栈，我通过查阅资料，实现了一个典型的物联网智能场景，在这个过程随手整理了一些资料以及技术实现过程中踩的一些坑。</p>
<p>物联网和传统互联网的 CS 架构其实是相似的，都是前后端的交互通信，区别在于物联网往往有一个局域网链接客户端，局网中的设备 通过一些轻量的通讯协议交互，比如流行的 MQTT，也有直接使用蓝牙或者 WLAN 的，还有一台网关/路由作为中台，收集来自区域设备的数据，最终传递给云端服务器。如果硬要说还有什么区别，那就是在服务器端，往往还涉及到分布式，数据分析这些架构模块。以此来支持处理和分析来自设备的大量上传数据。</p>
<p>物联网的三个过程是：收集数据，传递数据和分析数据。对于收集数据而言，主要依赖传感器和相关的硬件模组，这也是软件工程师接触物联网比较感兴趣和有挑战的地方，因为涉及到一些硬件的技术内容；另外传递数据方面虽然依然采用 IP/TCP 的协议，但是相比传统的互联网，在应用层通讯协议方面已经不局限于采用 HTTP/HTTPS 了，在局域网中，依赖轻量级，低功耗的传输协议可以更大的发挥物联网设备的特点；至于数据分析层面则是现在飞速发展的互联网技术分支，也是目前物联网中相对成熟的模块，通过大数据实现数字世界和现实世界的 Digital Twin，通过数字世界的操控影响现实设备的表现。未来可以支持接入海量设备信息的大数据处理平台必定极具竞争力。在数据处理这一块由于我实现的只是一个简单的活动告警器，只是做一些简单的活动频率统计，所以不会实际都分布式和数据分析的内容。</p>
<p>上班的时候经常有这样一种场景，主管常常不在位置上，有时有事情想找主管，但又不是那种需要打电话直接找过去的事情，所以会特别希望主管一回到位置就能收到一个通知。刚好最近在看物联网的一些资料，这就衍生了我做一个监控告警的 IoT 应用的想法（没错，监视主管。目前暂时只实现了单设备，后续考虑接入多个监控设备，这样常年外出公干的大佬们一回来，我就能先过去挑几份好的礼物了。</p>
<p>说一下实现的思路，开始也说了，物联网关键的地方还是传感器和控制芯片这一块，其他实现方法用老的互联网那一套即可。由于之前接触过一些单片机和树莓派，对这些集成度高的板子还是比较放心的，考虑到社区生态和功能全面，所以就先用一台 Rspaberry 3B 来做实验（投入实用可以用一些更小的模组，比如 omega)，然后在某宝买了一套适配树莓派的传感器和杜邦线。其实一开始是打算用移动公司的 IoT 开发平台的，它提供了自带感应器的芯片模组，但是申请的开发板一直迟迟不给我发货，而且平台的 SDK 包是用 C 的，想写脚本的我不犹豫的跑路了。</p>
<p>由于是单设备的接入，而且树莓派本身就是一台功能强大的 Linux 服务器，所以直接拿来做中台，收集的数据发到搭架在我电脑上的服务器，服务器处理，分析，存储数据，同时提供操控物联网设备的服务以及推送 App 监控器报警的功能。App 采用 apache 给阿里孵化的全端开发框架 weex 写，这样可以一口气搞定 web，android，ios 三个平台的应用。app 可以控制活动监控器的告警灯以及是否开启监控。</p>
<p>先从设备客户端开始搞起，用 python 或者 js 都有相应支持树莓派 GPIO 接口的包文件，由于最近在看 Node-RED 这个基于 Nodejs 的可视化物联网编程框架，所以我就直接用 Nodejs 和 rpio 包写了。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//监听传感器输出引脚</span></div><div class="line">rpio.open(LISTENT_PIN, rpio.INPUT, rpio.PULL_DOWN);</div><div class="line">rpio.poll(LISTENT_PIN, pin =&gt; &#123;</div><div class="line">    <span class="comment">// log(':the state of pin ' + pin + ' is '+ rpio.read(pin))</span></div><div class="line">    <span class="comment">//将监听信息推送到app</span></div><div class="line">    log(<span class="string">'[rpio-&gt;app-hock]request '</span> + WEB_HOCK);</div><div class="line">    <span class="keyword">var</span> time = <span class="keyword">new</span> <span class="built_in">Date</span>().toString().split(<span class="string">' '</span>).splice(<span class="number">1</span>,<span class="number">4</span>).join(<span class="string">'-'</span>);</div><div class="line">    <span class="keyword">var</span> cmdStr = <span class="string">`curl '<span class="subst">$&#123;WEB_HOCK&#125;</span>' \</div><div class="line">      -H 'Content-Type: application/json' \</div><div class="line">      -d '</div><div class="line">    &#123;</div><div class="line">      "text": "[<span class="subst">$&#123;time&#125;</span>]检测范围有人活动..",</div><div class="line">    &#125;'`</span>;</div><div class="line">    exec(cmdStr, <span class="function"><span class="keyword">function</span>(<span class="params">err,stdout,stderr</span>)</span>&#123;</div><div class="line">            err &amp;&amp; log(err);</div><div class="line">            <span class="comment">// console.log(stdout);</span></div><div class="line">    &#125;);</div><div class="line">    <span class="comment">//将监听信息发送至控制平台</span></div><div class="line">    log(<span class="string">'[rpio-&gt;server]request '</span> + CONSOLE_URL + <span class="string">'/warnSignal'</span>);</div><div class="line">    CONSOLE_URL &amp;&amp; http.get(CONSOLE_URL+<span class="string">'/warnSignal'</span>,(res)=&gt;&#123;</div><div class="line">        log(<span class="string">'[server-&gt;rpio] '</span>,res);</div><div class="line">    &#125;).on(<span class="string">'error'</span>,e=&gt;&#123;</div><div class="line">        log(<span class="string">'connect console server '</span>+CONSOLE_URL+<span class="string">' failed.'</span>);</div><div class="line">    &#125;)</div><div class="line">    <span class="comment">//只有在告警功能打开时才会闪烁</span></div><div class="line">    isWarnLEDFuncOn &amp;&amp; twinkLED(WARNLED_PIN, <span class="number">0.5</span>, <span class="number">2</span>);</div></pre></td></tr></table></figure>
<p>硬件方面比较简单，买了集成度高的活动传感器，支持 3-10 米的检测范围，0.5s-300s 的报警延时功能，参照树莓派的 GPIO 引脚功能表连接设备和 LED 灯，LED 灯接 3.3V 的引脚就够了，最好还要加个电阻，不加也没啥事。监听对应的引脚的跳高电压，当监听到活动时会给树莓派发送一个波峰电压。接到报警之后将信息传给后端服务器，点亮并闪烁报警的 LED 灯，此外由于告警数据不需要服务器进行处理，所以我直接发给了可以推送信息给 app 的 webHock 地址。这个服务很多类 slack 的协作工具都有提供，我这里用的是 bearychat 的 incoming 机器人。</p>
<p>然后就是写设备提供的接口，服务器通过这些接口可以控制设备的一些功能，比如 LED 灯的开关，告警功能的开关。还有要实现的就是 LED 灯的开关和闪烁函数，这个结合 rpio 的 API 文档，可以快速实现。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//提供服务</span></div><div class="line">server(&#123; port: SERVER_PORT &#125;, [</div><div class="line">  <span class="comment">//告警灯状态可控</span></div><div class="line">  get(<span class="string">'/offWarnLED'</span>, ctx =&gt; &#123;</div><div class="line">    log(<span class="string">' offWarnLED request is coming..'</span>);</div><div class="line">    offLED(WARNLED_PIN);</div><div class="line">  &#125;),</div><div class="line">  get(<span class="string">'/onWarnLED'</span>, ctx =&gt; &#123;</div><div class="line">    log(<span class="string">' onWarnLED request is coming..'</span>);</div><div class="line">    onLED(WARNLED_PIN);</div><div class="line">  &#125;),</div><div class="line">  get(<span class="string">'/twinkWarnLED'</span>, ctx =&gt; &#123;</div><div class="line">    log(<span class="string">' twinkWarnLED request is coming..'</span>);</div><div class="line">    twinkLED(WARNLED_PIN, <span class="number">1</span>);</div><div class="line">  &#125;),</div><div class="line">  get(<span class="string">'/changeWarnLED'</span>, ctx =&gt; &#123;</div><div class="line">    log(<span class="string">' changeWarnLED request is coming..'</span>);</div><div class="line">    changeLED(WARNLED_PIN);</div><div class="line">  &#125;),</div><div class="line">  <span class="comment">//是否开启告警灯功能</span></div><div class="line">  get(<span class="string">'/onWarnFunc'</span>, ctx =&gt; &#123;</div><div class="line">    isWarnLEDFuncOn = <span class="literal">true</span>;</div><div class="line">    log(<span class="string">' Warn Functoin is open now..'</span>);</div><div class="line">  &#125;),</div><div class="line">  get(<span class="string">'/offWarnFunc'</span>, ctx =&gt; &#123;</div><div class="line">    isWarnLEDFuncOn = <span class="literal">false</span>;</div><div class="line">    log(<span class="string">' Warn Functoin is close now....'</span>);</div><div class="line">  &#125;),</div><div class="line">  get(<span class="string">'/changeWarnFunc'</span>, ctx =&gt; &#123;</div><div class="line">    isWarnLEDFuncOn = isWarnLEDFuncOn ? <span class="literal">false</span> : <span class="literal">true</span>;</div><div class="line">    log(<span class="string">' Warn Functoin is'</span> + isWarnLEDFuncOn + <span class="string">'now....'</span>);</div><div class="line">  &#125;)</div><div class="line">]);</div></pre></td></tr></table></figure>
<p>服务端方面本来是打算通过 webSocket 来和应用端实时通信，展示告警的状态，但是踩了 weex 的一个坑，没有搞出来，weex 的 android 中没有原生的 webSocket 实现，导致我在 web 调通的功能安装到 android 模拟器里后就不行了，后来实在找不齐 webSocket 实现所需要的库文件，而且考虑到场景不是很需要实时交互，所以就没有用这个方案了，后来想想其实用 ajax 长轮询做应该就没问题了。其他的功能就是接受设备的数据并储存，提供接口转发 app 端的控制请求给设备端，以及处理请求存储的告警信息内容。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//转发改变LED状态的请求</span></div><div class="line">app.get(<span class="string">'/changeWarnLED'</span>, (req, res) =&gt; &#123;</div><div class="line">  log(<span class="string">'[app-&gt;server]changeWarnLED'</span>);</div><div class="line">  http</div><div class="line">    .get(iotRouterUrl + <span class="string">'/changeWarnLED'</span>, resp =&gt; &#123;</div><div class="line">      res.send(<span class="string">'[server-&gt;app]ok!'</span>);</div><div class="line">    &#125;)</div><div class="line">    .on(<span class="string">'error'</span>, e =&gt; &#123;</div><div class="line">      log(e);</div><div class="line">    &#125;);</div><div class="line">&#125;);</div><div class="line"><span class="comment">//接收，存储设备的告警信息</span></div><div class="line">app.get(<span class="string">'/warnSignal'</span>, (req, res) =&gt; &#123;</div><div class="line">  log(<span class="string">'[rpio-&gt;server]somebody have a action now.'</span>);</div><div class="line">  res.send(<span class="string">'[server-&gt;rpio]The warn msg send success.'</span>);</div><div class="line">  <span class="comment">//存储信息</span></div><div class="line">  <span class="keyword">var</span> dateInfo = <span class="keyword">new</span> <span class="built_in">Date</span>()</div><div class="line">    .toString()</div><div class="line">    .split(<span class="string">' '</span>)</div><div class="line">    .splice(<span class="number">1</span>, <span class="number">3</span>)</div><div class="line">    .join(<span class="string">'-'</span>);</div><div class="line">  <span class="keyword">var</span> timeInfo = <span class="keyword">new</span> <span class="built_in">Date</span>()</div><div class="line">    .toString()</div><div class="line">    .split(<span class="string">' '</span>)</div><div class="line">    .splice(<span class="number">4</span>, <span class="number">1</span>)</div><div class="line">    .join(<span class="string">'-'</span>);</div><div class="line">  <span class="keyword">var</span> store = &#123;</div><div class="line">    timeLabel: <span class="built_in">Date</span>.now(),</div><div class="line">    dateInfo,</div><div class="line">    timeInfo,</div><div class="line">    msgType: <span class="string">'warnSignal'</span></div><div class="line">  &#125;;</div><div class="line">  <span class="comment">//存储报警信息</span></div><div class="line">  fs.readFile(<span class="string">'store.json'</span>, <span class="string">'utf-8'</span>, (e, data) =&gt; &#123;</div><div class="line">    e &amp;&amp; <span class="built_in">console</span>.log(e);</div><div class="line">    <span class="keyword">var</span> data = <span class="built_in">JSON</span>.parse(data);</div><div class="line">    data.data.push(store);</div><div class="line">    fs.writeFile(<span class="string">'./store.json'</span>, <span class="built_in">JSON</span>.stringify(data), e =&gt; &#123;</div><div class="line">      e &amp;&amp; <span class="built_in">console</span>.log(e);</div><div class="line">    &#125;);</div><div class="line">  &#125;);</div><div class="line">&#125;);</div><div class="line"><span class="comment">//返回报警数据</span></div><div class="line">app.get(<span class="string">'/data'</span>, (req, res) =&gt; &#123;</div><div class="line">  log(<span class="string">'[app-&gt;server]getData'</span>);</div><div class="line">  fs.readFile(<span class="string">'./store.json'</span>, <span class="string">'utf-8'</span>, (e, data) =&gt; &#123;</div><div class="line">    e &amp;&amp; <span class="built_in">console</span>.log(e);</div><div class="line">    log(<span class="string">'data number:'</span> + <span class="built_in">JSON</span>.parse(data).data.length);</div><div class="line">    res.send(data);</div><div class="line">  &#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>应用端采用 weex/vue 的 js 全端开发框架，简单的写几个按钮，添加请求相应的接口地址，就能达到控制设备的作用。通过 weex-toolkit 可以在 web 端调试，打包，注意这个过程要有相应的 android 和 ios 开发环境，也就是说 jdk，android-sdk，安卓模拟器，xCode 都是需要的，这方面可以看看 weex 的 helloWorld 教程搭下环境。</p>
<p>在树莓派中跑起代码</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">pi@raspberrypi:~<span class="regexp">/iot/</span>demo $ node rpio</div><div class="line">[Oct<span class="number">-22</span><span class="number">-2017</span><span class="number">-15</span>:<span class="number">01</span>:<span class="number">42</span>]server starts on <span class="number">8080</span> port</div><div class="line">[Oct<span class="number">-22</span><span class="number">-2017</span><span class="number">-15</span>:<span class="number">02</span>:<span class="number">11</span>][rpio-&gt;app-hock]request https:<span class="comment">//hook.bearychat.com/=bwBAI/incoming/55725fec1b3e3b629c8929ba0d41fefe</span></div><div class="line">[Oct<span class="number">-22</span><span class="number">-2017</span><span class="number">-15</span>:<span class="number">02</span>:<span class="number">11</span>][rpio-&gt;server]request http:<span class="comment">//192.168.31.170:8066/warnSignal</span></div><div class="line">[Oct<span class="number">-22</span><span class="number">-2017</span><span class="number">-15</span>:<span class="number">02</span>:<span class="number">12</span>][server-&gt;rpio]</div></pre></td></tr></table></figure>
<p>在服务端后台跑起 server</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">@Daguo:) ~<span class="regexp">/code/i</span>ot/demo <span class="number">13</span>:<span class="number">38</span>:<span class="number">57</span> &gt;&gt;&gt;master!</div><div class="line">$ node <span class="built_in">console</span>.js</div><div class="line">[Oct<span class="number">-22</span><span class="number">-2017</span><span class="number">-13</span>:<span class="number">38</span>:<span class="number">58</span>]start server at <span class="number">8066.</span></div><div class="line">[Oct<span class="number">-22</span><span class="number">-2017</span><span class="number">-13</span>:<span class="number">39</span>:<span class="number">54</span>][rpio-&gt;server]somebody have a action now.</div><div class="line">[Oct<span class="number">-22</span><span class="number">-2017</span><span class="number">-14</span>:<span class="number">09</span>:<span class="number">44</span>][rpio-&gt;server]somebody have a action now.</div><div class="line">[Oct<span class="number">-22</span><span class="number">-2017</span><span class="number">-15</span>:<span class="number">02</span>:<span class="number">12</span>][rpio-&gt;server]somebody have a action now.</div><div class="line">[Oct<span class="number">-22</span><span class="number">-2017</span><span class="number">-15</span>:<span class="number">08</span>:<span class="number">54</span>][app-&gt;server]changeWarnLED</div><div class="line">[Oct<span class="number">-22</span><span class="number">-2017</span><span class="number">-15</span>:<span class="number">08</span>:<span class="number">55</span>][app-&gt;server]changeWarnLED</div></pre></td></tr></table></figure>
<p>当监控到环境中有物体活动后，bearyChat 应用会收到弹出消息，通过 app 也可以控制设备 LED 灯，至此完成了物联网应用的基础功能，更加详细的代码放在我的<a href="https://github.com/shudery/iot">github</a>上。后续还需要改进的地方包括接入多设备的支持，同时要采用新的轻量级协议连接局域网设备，路由对多设备数据的收集和发送，服务端的数据分析和计算，应用端的可视化数据界面展示。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;物联网概念的提出已久，业界早就有相应的实践和应用，受限于网络带宽和传感器技术，尚未普及，此外这种偏智能化的场景，注定需要一定的时间才能走进大众家庭。在物联网中，技术应用架构是怎样的，与传统互联网有何区别？为了弄清其中的关系和技术栈，我通过查阅资料，实现了一个典型的物联网智能
    
    </summary>
    
      <category term="笔记" scheme="http://shudery.cn/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="技术研究" scheme="http://shudery.cn/tags/%E6%8A%80%E6%9C%AF%E7%A0%94%E7%A9%B6/"/>
    
  </entry>
  
  <entry>
    <title>服务架构基础概念</title>
    <link href="http://shudery.cn/2017/09/08/%E7%AC%94%E8%AE%B0/%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/"/>
    <id>http://shudery.cn/2017/09/08/笔记/服务架构基础概念/</id>
    <published>2017-09-07T16:00:00.000Z</published>
    <updated>2019-02-12T02:51:42.693Z</updated>
    
    <content type="html"><![CDATA[<p>最近和友人聊天的时候，说到现在在做的一些业务项目，在跟上级做汇报的时候，不管怎么说最后一定要在技术架构方面扯上云化，服务化，数字化之类的名词（摊手，往高端点说是必须要匹配公司的总体战略目标。也不管你的项目是否适合这些模式的架构方案，都要在胶片上放上这几个 High-Level 的词汇，不然这就是一份不能让领导满意的汇报材料，要打回去重写（滑稽。</p>
<p>言归正传，那么当前的企业架构大趋势下，上云，服务化是啥，还有其他的平台化，容器化，虚拟化，微服务，SOA 架构都是些什么鬼？它们和大数据，云计算，分布式之间又有何关联，为什么会成为新的架构事实标准呢？汇报的时候万一领导随便丢几个问题，你能够理清它们之间的关系吗？作为刚刚接触架构的新人，为了更好的向领导说(hu)明(you)，我决定好好学习一番，最后整理了一下，感觉已经可以开始我的表演了。下面我会从分布式计算说起，理清这些词汇及它们间的关系。</p>
<p>很长一段时间我们都是在本地计算机上跑程序代码的，但是当服务达到一定的计算规模之后，计算机的本地资源已经不能满足我们对性能的要求了。后来我们发现可以利用互联网上的其他计算机闲置的资源来分担本地服务的压力，这就是 <strong>分布式计算</strong>。</p>
<p>这些闲置的计算机资源怎么来的呢？如果直接购买，那么当企业不需要进行大规模计算的时候，就会造成资源的浪费。因此就出现了一些大公司购置了大量的计算机，形成一个计算资源池。它即可以供自家公司业务繁忙时期使用，也可以在不需要用的时候出租给其他公司或者个人，这种资源池有个好听的名字叫云，用它来减轻业务压力，提高性能的过程就是 <strong>云化或上云</strong>。云提供的计算能力就是 <strong>云计算</strong>，可以说云计算是一种开放的、商业化的分布式计算。简单来说，如果你有一些闲置的计算资源，简单的树莓机也可以，就可以做为一个小小的集群发布到网络，然后你就可以收点小费，提供服务端口给其他人使用，这时你就拥有了一朵小小的云，一个可以进行云计算或者分布式计算的基础设施。</p>
<p>通俗来说，通过云资源提供的服务就是 <strong>云服务</strong>，云服务有多种模式，拥有大量云资源的公司往往不止提供云计算的服务，还会提供存储空间，也就是 <strong>云存储</strong>，类似有道云笔记的功能。也可以直接将计算机设施提供给客户后就不管不问了，客户相当于包了台计算机，这种模式就是基础设施服务（IAAS）。目前最流行的是在原先的设施基础层上，拥有云资源的公司会将底层的计算机集群统一分配调度，封装成运营的平台界面和可供开发的 SDK，做成了一套平台服务（PAAS），也就是 <strong>云平台</strong>。</p>
<p>云平台给客户提供运营的功能，按需计费，租户可以随时扩容和缩减资源，同时大公司还会帮你升级，维护服务器，客户只需要专心运营，可以大大节约成本。大公司为了构建云平台，需要规划底层基础设施，开发抽象出方便用户使用功能，在平台化的过程中，大公司把一些底层的脏活累活都给做了，小公司直接利用平台的提供的服务就可以方便的体验到底层设施带来的好处。这就是现在在大公司大行其道的商业模式 <strong>服务化</strong>。业界关于服务化的实践非常多，最厉害的 Amazon Web Services（AWS）已经无需多言，除此之外像 Heroku，Google App Engine（GAE）也具有非常好的口碑，国内以 BATH 为主也都各有实践。</p>
<p>服务化的厉害在于用户根本不需要关注底层框架，不用具备相应的专业知识，但是又不至于像具体的软件服务（SAAS)那样缺少可以自由定制化的功能，无法平衡业务需求和企业利益。而对于个人而言也是好处多多，以前你想做一个网站站长，需要自己买服务器，安装服务器软件，编写网站程序，写监控模块，写日志系统和数据库。现在有了服务化平台，你只需要写你的网站程序，其他的可能就是根据你的心情，随意地在管理桌面添加或删除你想要的功能模块了。</p>
<p>提供服务化功能的云平台，就是 <strong>云服务平台</strong>，简单区分一下，AWS 就是提供了服务化功能的云平台，但是像搜狐快站这种提供自定义网站建设功能服务的平台，就只是普通的服务化平台（PAAS）</p>
<p>随着互联网时代技术的高速发展，大公司开心地利用着自己闲置的计算机资源和思维超前的平台化模式赚着小钱的同时，也在思考着怎么赚大钱。资本的力量让小公司瑟瑟发抖。</p>
<p>第一个方式就是先想办法节约自身成本，买那么多台计算机太浪费钱了，如何才能更加合理的使用资源，提高利用率呢。企业通过将基础设施的 <strong>虚拟化</strong>，在云平台的资源池中，基础设施不一定是真正的物理资源（计算机），往往是抽象后的虚拟资源，让一台计算机变成几十台甚至上百台相互隔离的。虚拟化的好处非常多：可以节省空间，降低能耗，提高计算资源的利用率，稳定性更好，灵活迁移等等。</p>
<p>后来 <strong>容器化</strong> 继承了虚拟化的诸多特点，也是一种可选的方案，不过容器化的隔离效果没有虚拟化好，容器的优点是更加轻量，部署更快，符合 DevOps 的理念，Docker 技术也已经非常成熟。配合虚拟机和容器可以有多种虚拟资源的方案。写到这里我突然想起，十年前有一家国产云提供商，那时候云服务还未普及，基础设施服务才刚刚兴起，可以说供应商这时已经有云的意识是非常超前的了。但是随后这家提供商大力的建设虚拟化云机以节约成本，扩大云资源池，而在服务化的道路上停滞不前，之后这家供应商的云平台一直没有很好的发展起来。十年后看无疑服务化才是王道之路，供应商已然醒悟，立志做五年后的五大云之一。这个走了弯路的供应商一直是做管道（通讯设施）的，最近几年终端（手机）也发展得不错，未来能实现”云管端”的战略布局吗？</p>
<p>另外，还要思考自身的平台技术架构的优化问题，传统的企业应用往往采用面向 <strong>服务架构设计（SOA）和企业服务总线（ESB）</strong>的模式，这是一种单一的应用架构，是一种处理小规模应用程序的有效架构设计。但是随着服务平台提供越来越多的功能，程序需要调用越来越多的服务接口，各个服务紧耦合成一团，十分不利于应用的维护，部署。每次修改应用的一个小模块就需要重新部署整个应用，除此之外整个应用使用相同的技术框架，限制了应用的迭代更新和活力。</p>
<p><strong>微服务（Microservices）</strong>应运而生，微服务的设计架构强调模块化和服务化，原有的单一应用按一定的粒度大小拆分成多个服务模块，实现各模块之间的解耦，各模块可以各自用不同的技术设计，开发，调试，部署，不会互相影响，服务之间通过轻量级的通信方式联系（通常是用基于 HTTP 的 RESTful API）。微服务摈弃了传统 SOA 架构中的繁重的 ESB，可以说是新时期的 SOA 继承思想。相比较传统的单一应用架构，除了在小型应用中可以简化开发过程，我想你不到任何你不运用微服务理念的原因。如果你想知道更多微服务的优势，可以看看<a href="https://mp.weixin.qq.com/s?__biz=MjM5MDE0Mjc4MA==&amp;mid=2650997457&amp;idx=1&amp;sn=c9024d2b47d88f15266d6d15544653ac&amp;chksm=bdbefa828ac973940ecaef2b74efed5f645b6e023756741b4a45f718b3373d565daef1b4d492&amp;scene=21#wechat_redirect">这边文章</a>。</p>
<p>最后要想赚大钱，还需要想办法挖掘服务化更大的潜力。在移动互联网时代，流量为王，用户和流量的重要性已经无需赘言。这些流量除了给各个公司带来广告收益外，流量也将用户海量的数据带到了云端，数据对于一家小公司而言可能就是做做自家产品的用户画像，找到切合用户的需求或者适合的合作方。但是这些数据都汇集到云端就不一样了，那可能就是整个行业的财富，庞大的数据流量就是服务化可挖掘的金矿。依托着自身的平台运算资源来分析处理 <strong>大数据</strong>，可以给企业带来巨大的利益。悔创阿里的杰克马说过：<strong>大数据将变成人类未来的巨大能源，做好大数据和云计算可以预测未来。</strong></p>
<p>大数据的重要性不言而喻，而且大数据往往需要依托大量的基础设施，简直就是给云服务提供商的巨大商机，其他人想玩都不一定玩得动。顺带一提，机器学习和人工智能在训练时，除了需要设计模型算法，关键是还需要大量的训练素材，大数据就能够为其提供巨大量级的素材。看来大数据不只能预测未来，统治未来也是可以的，毕竟人工智能统治未来没毛病（逃。</p>
<p>种种迹象都表明服务化，微服务是企业架构中要考虑的核心内容，要依托产品和业务的需求特性，用长远的眼光看待产品和架构设计。也确实是企业产品需要考虑的一个重要方面。所以开头的那个笑话也许是严肃的，你真的该好好考虑云化，服务化了。</p>
<p>其实企业架构设计非常有意思，它往往就是世界上最伟大的几个公司的架构提炼出来的产物，而这个产物又是那些公司上百上千工程师设计和实践的结晶。现今服务化的理念已深入人心，互联网的浪潮经久不退，新一轮的物联网浪潮和数字化世界还未来到，以后的企业技术架构会如何发展，以配合时代的潮流，还需持续学习和观察。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近和友人聊天的时候，说到现在在做的一些业务项目，在跟上级做汇报的时候，不管怎么说最后一定要在技术架构方面扯上云化，服务化，数字化之类的名词（摊手，往高端点说是必须要匹配公司的总体战略目标。也不管你的项目是否适合这些模式的架构方案，都要在胶片上放上这几个 High-Leve
    
    </summary>
    
      <category term="笔记" scheme="http://shudery.cn/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="技术研究" scheme="http://shudery.cn/tags/%E6%8A%80%E6%9C%AF%E7%A0%94%E7%A9%B6/"/>
    
  </entry>
  
  <entry>
    <title>MacOS使用半年感受(码农向</title>
    <link href="http://shudery.cn/2017/04/04/%E9%9A%8F%E5%86%99/MacOS%E4%BD%BF%E7%94%A8%E5%8D%8A%E5%B9%B4%E6%84%9F%E5%8F%97(%E7%A0%81%E5%86%9C%E5%90%91)/"/>
    <id>http://shudery.cn/2017/04/04/随写/MacOS使用半年感受(码农向)/</id>
    <published>2017-04-04T09:53:38.000Z</published>
    <updated>2019-02-12T01:27:25.297Z</updated>
    
    <content type="html"><![CDATA[<p>2016年8月底的时候入手了macbook pro2015版，其实早在3月入阿里实习的时候就被安利了mac于办公和编码的各种优势，正好当时被老旧的ThinkPad卡得生活不能自理，不过由于可以使用公司配的电脑以及想等2016新版的pro，所以一直忍住没买，直到8月我要回校时，新版一直拖延发布，而且听说用了蝶式键盘，我用过macbook12寸的蝶式键盘，简直忍不了，所以就直接买了，到现在使用了大概快半年了，每天都是重度使用，觉得可以写点感受和安利一些好用的软件。</p>
<p>总体来说OSX系统上手并不难，难点主要是我们很多人都已经习惯了windows系统的操作方式了，所以使用一个新系统需要一定的时间适应，而且需要建立一个操作映射，原先在windows可以实现的功能在mac上要如何实现？比如说windows的ctrl键的很多使用场景在mac下都是用command代替。</p>
<p>安利一波mac的优秀软件，可以提升mac的使用体验和工作效率。</p>
<h4 id="oh-my-zsh"><a href="#oh-my-zsh" class="headerlink" title="oh-my-zsh"></a>oh-my-zsh</h4><p>mac系统超级好用的命令行工具，相比windows的命令行是一个极大的优势，各种快捷操作，配置自己喜欢的主题，配色，结合自带的插件就可以实现很多功能。</p>
<h4 id="Moom"><a href="#Moom" class="headerlink" title="Moom"></a>Moom</h4><p>窗口尺寸调整工具，可以配置好快捷点对应的尺寸及窗口显示位置，一键改变窗口的位置和大小，最近在写论文需要多个窗口的时候使用起来那叫一个爽。</p>
<h4 id="Dash"><a href="#Dash" class="headerlink" title="Dash"></a>Dash</h4><p>文档查询工具，离线下载文档，支持github和stack overflow搜索，遇到API问题可以直接查找，不用再在网上查了。</p>
<h4 id="Reeder"><a href="#Reeder" class="headerlink" title="Reeder"></a>Reeder</h4><p>mac优秀的RSS阅读器，界面简洁优雅，使用触摸板体验更好。</p>
<h4 id="Spark"><a href="#Spark" class="headerlink" title="Spark"></a>Spark</h4><p>mac的邮箱管理工具，颜值非常高。</p>
<h4 id="Paste"><a href="#Paste" class="headerlink" title="Paste"></a>Paste</h4><p>复制剪切板保存工具，可以无上限保存复制历史，用了它后在很多场景可以不用来回复制粘贴，可以一口气先复制多次，同样界面颜值非常高，操作方便。</p>
<h4 id="Timing-gt-Rescue-Time"><a href="#Timing-gt-Rescue-Time" class="headerlink" title="Timing =&gt; Rescue Time"></a>Timing =&gt; Rescue Time</h4><p>记录mac软件的使用时间，打开后不管它，一周后它会有本周使用报告，可以看看自己这一周都干了什么。<br>后来我发现了一款更加专业的时间记录工具，可以生成各种数据图，管理分类。</p>
<h4 id="SmoothScroll"><a href="#SmoothScroll" class="headerlink" title="SmoothScroll"></a>SmoothScroll</h4><p>mac的触摸板操作非常流畅，然而大部分鼠标操作十分蛋疼，这是一款鼠标操作的改善软件，有很多的功能，但是仅解决mac下鼠标慢启动的这点就让我非常喜欢，开了这个就和windows下用鼠标没有区别了。</p>
<h4 id="MplayerX"><a href="#MplayerX" class="headerlink" title="MplayerX"></a>MplayerX</h4><p>mac下很好的视频播放器，相比原生自带的多了很多细节的优点，比方快捷键控制播速，暂停不会重置播速，快进快捷键等。</p>
<p>使用mac时间长了之后，也渐渐可以感受到它不够完美的地方（虽然我早就知道，不过由于mac带给我的体验的提升，我一直选择忽视它们</p>
<ul>
<li>软件兼容性问题， 比方说链接安卓手机传输多张图片时，试过很多软件方法都很容易就卡死。</li>
<li>电脑发热问题，基本开着chrome，多开几个Tag，视频播放，就开始发热，玩大游戏更别想了。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      MacOS使用半年感受(码农向
    
    </summary>
    
      <category term="随写" scheme="http://shudery.cn/categories/%E9%9A%8F%E5%86%99/"/>
    
    
      <category term="随写" scheme="http://shudery.cn/tags/%E9%9A%8F%E5%86%99/"/>
    
  </entry>
  
  <entry>
    <title>豆瓣电影到对应资源的传送门插件</title>
    <link href="http://shudery.cn/2017/02/22/%E7%AC%94%E8%AE%B0/%E8%B1%86%E7%93%A3%E7%94%B5%E5%BD%B1%E5%88%B0%E5%AF%B9%E5%BA%94%E8%B5%84%E6%BA%90%E7%9A%84%E4%BC%A0%E9%80%81%E9%97%A8%E6%8F%92%E4%BB%B6/"/>
    <id>http://shudery.cn/2017/02/22/笔记/豆瓣电影到对应资源的传送门插件/</id>
    <published>2017-02-21T16:00:00.000Z</published>
    <updated>2019-02-12T02:52:18.903Z</updated>
    
    <content type="html"><![CDATA[<p>这是一个运行在 chrome 浏览器上的插件。前几天看了<a href="http://zhangwenli.com/blog/2014/09/01/readfree-chrome-extension/">@羡澈</a>大神写的豆瓣读书跳转到 Readme 上下载电子书的地址，所以闲着没事就写了一个电影的跳转。</p>
<h3 id="项目地址"><a href="#项目地址" class="headerlink" title="项目地址"></a>项目地址</h3><p><a href="https://github.com/shudery/douban-movies-plugin/">https://github.com/shudery/douban-movies-plugin/</a></p>
<h3 id="实现功能"><a href="#实现功能" class="headerlink" title="实现功能"></a>实现功能</h3><p>在豆瓣电影介绍页面自动添加一个下载按钮，点击可以直接传送到该电影的可下载资源的地址，当然了，前提是要找得到资源才行。我写了一个爬虫事先爬取了电影下载网站中的现有资源，离线为一个哈希表供插件搜索。</p>
<p><img src="/pic/douban.jpeg" alt=""></p>
<h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><ul>
<li>能够科学上网的同学到 chrome 应用商店下载即可：<a href="https://chrome.google.com/webstore/detail/douban-movies-plugin/ecgaddjpeacadegjcopipeoncpaphnpl?hl=zh-CN">douban-movies-plugin</a></li>
<li>不能的直接本地下载 Chrome 插件的 cxr 文件：<a href="https://github.com/shudery/douban-movies-plugin/raw/master/plugin.crx">plugin.cxr</a></li>
<li>然后打开 Chrome 浏览器，点击菜单-&gt;工具-&gt;扩展程序</li>
<li>将已下载的 crx 文件拖入 Chrome 窗口</li>
<li>打开一个豆瓣电影页面（如：<a href="https://movie.douban.com/subject/25934014/">https://movie.douban.com/subject/25934014/</a>），如果电影标题右侧没有出现下载按钮，则表示该资源暂时没找到。</li>
</ul>
<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><ul>
<li>使用这个插件目前只支持 chrome 浏览器。</li>
<li>目前只有豆瓣电影的详情页有添加按钮。</li>
<li>暂时只爬取了 80s 电影网的所有视频资源，也就是说如果 80s 上没有资源，那么按钮就不会出现了，不过这个网站已经相当给力，基本想看啥有啥，新上映的电影一般一个月内会补上。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是一个运行在 chrome 浏览器上的插件。前几天看了&lt;a href=&quot;http://zhangwenli.com/blog/2014/09/01/readfree-chrome-extension/&quot;&gt;@羡澈&lt;/a&gt;大神写的豆瓣读书跳转到 Readme 上下载电子书的地
    
    </summary>
    
      <category term="笔记" scheme="http://shudery.cn/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="工具" scheme="http://shudery.cn/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>成为程序员的这一年</title>
    <link href="http://shudery.cn/2016/12/06/%E9%9A%8F%E5%86%99/%E6%88%90%E4%B8%BA%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%BF%99%E4%B8%80%E5%B9%B4/"/>
    <id>http://shudery.cn/2016/12/06/随写/成为程序员的这一年/</id>
    <published>2016-12-05T16:00:00.000Z</published>
    <updated>2019-02-12T01:27:25.337Z</updated>
    
    <content type="html"><![CDATA[<p>决定去华为工作之后，一直有朋友建议我写一篇文章分享一下我的自学和跨界历程。因为我大学是电子工程专业，而我现在做的，之前的实习职位以及现在的offer都是web开发，它们几乎没有任何关联。另外我开始自学web的时间也比较晚，从决定试一试到现在大概过去一年的时间，一年时间以来在自学编程的路上确实摔了不少坑，也有一些感悟。之前我也想写点东西，但是懒癌犯作迟迟没有动笔，想想都快年末了，还是整理一下，当作是一篇年末总结也好，纯粹是记录一下这段经历和感悟，如果言辞有不当之处请联系我修改。</p>
<p><strong>事先预警：</strong>由于本人理工男平时疏于写作，同时语文水平有限，很可能导致本文变成一篇非刻意性软文，其中夹杂着一些鸡汤，也许有毒，不能保证适合所有人。此外这篇总结也许会写着写着烂尾，请上车的朋友随时做好跳车的准备。</p>
<p><strong>正文的分割线，本文未经允许不得转载</strong></p>
<hr>
<p>我在今年三月底的时候做了一个决定，翘掉学校四门必修课，离开成都去阿里移动事业群工作。过去半年多了，回想当初做着个决定还挺不容易，这个我在大学里做的最离经叛道的一个决定，现在看来，应该也是最正确的。</p>
<h2 id="自学之路"><a href="#自学之路" class="headerlink" title="自学之路"></a>自学之路</h2><p>先说说我是怎么走上程序员这条路的。我是在去年年底的时候才开始认真思考未来职业这个问题的，当时我大三上学期就快要结束了。我们学校是在大三才开始学习专业必修课程，真正地接触了电子专业课程后，我花了好几个月的时间认清了我不能真正的喜欢上这些东西。我是一个一直都偏向于找工作，不想读研的人，这让我非常急躁，因为我清楚这样下去以我的本科能力根本就没法找到一份能令我和家人满意的工作。这也迫使我好好认真地审视了一下自己，最后我的决定是投身互联网，做一名程序员极客。</p>
<p>我在高考选专业的时候就已经在电子工程和计算机软件专业之间抉择过一次了，后来由于电子科学是我们学校的王牌专业，而且其实那会我对电子信息和软件这些学科都没有什么深刻的理解，觉得自己都算是有些兴趣，并且这两个专业据说也还蛮火的。<strong>所以说其实我在去年年底重新选择了软件是挺危险的，因为就像我在几年前高考选错了路一样，我现在只是又回到了原点，再做一次选择，谁也不知道过了多久，我是不是又会回到这里，选择别的什么路。</strong></p>
<p>但是无论如何，不能否认的是当年如果其他条件都相同，我是一定会在电子科学和计算机软件中选择后者的。我是个各方面条件平凡的人，没有什么特别的才能，喜欢的爱好通常也坚持不了多久。后来还摊上了一个非常耗费时间的爱好，就是玩游戏，然后浑浑噩噩，一直在划水混日子，转眼到了大三。期间要说有什么一直能燃起我内心兴趣的就是互联网和软件，这可能也和我玩过很多电脑游戏有关。记得高一的时候，我还和画画特别好的同桌说以后我要是去做游戏软件，就请他来给我做游戏人物的形象设计。我觉得我本来内心就是想做软件的，但是种种原因，一直以来没能听见自己内心的声音，后来经历了的很多事情都让我更坚定这个选择。</p>
<p>决定了互联网软件的大方向之后，还有很多细分的领域要作选择。<strong>其实当时我内心的想法就是我得快点把职业方向这个事给规划好定下来，然后就去往那方面走了，因为我觉得我真的起步太晚了，而且我是一个不对口的野生专业。</strong></p>
<p><img src="/pic/xuanzei.jpeg" alt="xuanzei"></p>
<p>这是我当时写在纸上的未来职业方向，可以看到我当时还没破釜沉舟，给自己留着退路，第一二个写的都还是和原本专业相关的职位，我做过一些硬件编程，所以觉得FPGA可能是一个方向，或者技术不行的话，运用一些本科学到的专业皮毛做个电子销售员之类的，当然这些是最坏的就业打算的。</p>
<p>我当时画了两个圈圈表示重点考虑，一个是做Java，我大一的时候就对Java很感兴趣，因为高中的时候安卓手机游戏特别火，而这些游戏基本都是Java做的，但是那会我菜到Java的开发环境都配不好，我觉得这里面有Windows系统配置繁琐的锅（逃。当时连一个HelloWorld程序都跑不出来，这给年轻的我深深的打击，果断就放弃了，那会我还庆幸自己还好没选计算机。但是越恨越爱，我还是把它作为一个主要的就业方向。</p>
<p>另一个方向正是web开发方面的，这是一个我非常感兴趣的方向，经过一番了解之后，我发现它比Java要好入门的多，行业前景在近几年非常好，应该还挺好赚钱的，出于这样单纯而现实的想法，我的就业方向就这样确定了，直到许久以后我才真正领略到这个行业的魅力。</p>
<p>方向定了之后，我渐渐舍弃了许多其他爱好，抽出时间，开始了勤奋地自学。有意思的是，被我逐渐舍弃的爱好包括吉他摄影之类的，而依然坚持的爱好则有诸如健身篮球，那是我下意识里的选择，果然我还是个理工男，文艺只是一个梦啊（捂脸。</p>
<p><strong>由于经常带着大学前两年浪费太多时间了的愧疚感，所以我的学习主动性在这个时间段非常高。而且庆幸的是web相对于其他软件，网上的学习资源太多了，代码很多都是开源的，我发现这是一个非常适合野生专业转行和自学的方向。</strong>还一度觉得计算机软件专业中的web开发者相对于那些自学的同学是没有多大优势的（逃。直到后来秋招找工作的时候，这个后面再说。那段时间基本都泡在图书馆看入门的经典书或者在寝室写demo，逐一地去搞懂每一个技术点，把慕课网和极客学院的课程基本都看完了，国外也有很多更优质的资源网站，但是对于初学者区别不大。这个时间我积累了很多优质的学习资源和技术博文，有刚入门前端的朋友如果需要可以联系我。</p>
<p><strong>那段时间每天晚上睡觉的时候都觉得今天又学到了有用的知识，这跟我在学电子专业的理论知识的那种体验是完全不一样的，软件学科的知识转化为实际的互联网产品和服务要比硬件快的多，它是自顶向下的，不需要你从最底层的枯燥的理论学起，这真的很适合我这种成就感驱动学习的人。</strong>在学了许多技术点之后，我开始给自己的知识体系做一些梳理，尝试写一些笔记总结，以此让自己的知识变得更系统。随后我加入了一些学校的IT组织，但是很快我发现这些学习型社团的效率太慢了，作为大三老人有点耗不起。然后又在网上参加一些前端和JS编程比赛，开始自己写一些网站，做一些实践项目，至今还清楚记得当我把第一个做好的网页给朋友看，那时激动的心情和满满的成就感（捂脸。</p>
<p><strong>前端领域有三板斧，HTML，CSS，JavaScript。而我的自学之路也是三板斧：兴趣，愧疚感，成就感。</strong></p>
<h2 id="开始找实习"><a href="#开始找实习" class="headerlink" title="开始找实习"></a>开始找实习</h2><hr>
<p>自学大概4个多月的时间，期间有一个月我参加了学校一个去新加坡创业交流的项目，还有回家过年休息了一段时间。放假完重新回到学校后，在学校BBS上面得知马上就要开始实习生内部推荐了，学习了一段时间也很想检验一下自己的技术和知识面，我觉得让大佬们面试就是很好的检验方法，就找了学校的学长开始投BAT的内推，推的岗位都是前端工程师。</p>
<p>反馈快得惊人，快到我对面试还毫无准备，没投几天，在3月中旬的时候我就收到了腾讯的面试电话，刚午睡醒的我接到电话真的是一脸懵逼，面试结果自然是呵呵了。<strong>除了应试技巧不熟悉，紧张过度之外，问我的很简单的技术问题我也没有答上来。这次面试狠狠地敲醒了我，我知道我一定得增加学习的强度了，同时也要好好准备一下应试技巧。</strong></p>
<p>十几天后我接到了另外一个来自BAT的面试电话，印象很深刻的是阿里的面试官都没让我自我介绍，上来直接问了大概20多个技术问题。由于这次有过充足的准备，而且问的问题对初学者比较友好，问了很多基础的知识点，没有太深入，大部分我都回答出来了，而且很幸运的是当时阿里广州正在急招一些Nodejs方面的实习生，我Node虽然是初学，但也正因如此知识点算都记得清楚。</p>
<p>我几个月的努力没有被辜负，后来我顺利地通过了面试，HR希望我尽快能过去，我本意是继续像上一个学期那样子这学期先自学，把那厌恶的专业课学分先拿了，然后找一份的暑假的实习，接着再去工作的。后来我觉得要是能够尽快去大厂里一边实践一边学习，同时认识许多志同道合的牛人，一定能更快地成长。做这个决定有很心酸的历程和压力，包括但不限于：当时我有四门必修专业课，一门过不了都不要想毕业，选修的学分也还没够，而我那会还没屌到觉得自己可以不要毕业证了，即使这份不对口专业的毕业证确实只是名面上的东西；还有辅导员老师极力劝阻，要知道的每一个电子科大的辅导员都有坚持劝你读研的属性（摊手。另外要离开校园去另一座城市工作，对陌生的环境我显然还没有准备好，内心很不安。。</p>
<p>在得到朋友的支持以及我一夜的纠结和思考之后，订了隔天前往广州贵得要死的飞机票。<strong>我离开学校当时内心只有一个想法，就是我还很菜很菜，现在有一个很好的机会我一定要去好好成长一番。</strong>后来经过努力和一番波折，那几门必修课我在补考和重修后也勉强拿到学分，老师也对我改变了看法，而当初的不安则变成了对一座城市和一个职业真正由心的热爱。</p>
<h2 id="实习，不断成长"><a href="#实习，不断成长" class="headerlink" title="实习，不断成长"></a>实习，不断成长</h2><hr>
<p>在阿里实习的这段时间，颠覆了我对行业，对程序员的理解，让我打心底坚定了以后的职业发展方向。</p>
<p>对于我这样的初学者来说，去公司实习是一次赌博，赌的是你的时间，考验着你的学习和承受能力。我在阿里的第一个月经历了人生中从未有过的恐慌和压力。我所在部门做的业务刚刚起步，非常繁忙，这个过程有非常多的坑，没有工作经验和项目经历，这些坑你多半是逃不掉的，只能一个一个去踩，不断遇到困难，不断去解决。这段时间我的TodoLists都是满的，我可以感受到别人和我实力的差距，很多东西我必须比别人花更多的时间才能搞明白。</p>
<p>记得我工作的第一天，主管跟我和另一个一同入职的中大研究生讲我们整个业务流程，一通讲下来，我根本就听不懂，太多的名词我都是第一次听说，以至于最后主管问我有没有什么问题要问，我都是一脸懵逼。这种内心到处都是问题但是问不出来问题的心情真是无奈得很。而那个研究生和我根本不是一个级别的，最骚的是主管讲什么技术点他都要来几句很牛逼的看法，让当时很沉默的我好尴尬，深受刺激，压力山大。后来这个实习第一天就和主管谈笑风生的大神成了我的好朋友，帮助我成长了不少，我就不黑他了（逃。</p>
<p>实习一开始的时候确实非常苦逼，每天都在给公司写bug（可怕，现在想想还是会心疼自己几秒。后来熟悉业务和环境，技术成长了之后，才渐渐能和大佬们一样，到公司后先端杯coffee or tea再说（逃。实习还发生了许多有意思的事情，也认识了很多有实力有想法的人，这些和工作细节我在自己的实习周记里写了很多，这里就不展开了，写一点感悟吧。</p>
<p>实际工作跟之前自学是完全不一样的，太多的突发事项会打断你原有的计划，要调整自己不断地去适应，还有一点巨大的变化就是对效率的要求。<strong>工作环境给你的压力会迫使你不断提升自己效率，不论是出于早点下班，腾出时间去从事业余的爱好，还是想成为马太效应中的马太，效率非常重要。</strong></p>
<p>实习的时候我见识了许多同事为了提高效率而使用的技巧或者软件了，小的方面比如操作技巧方面的放弃鼠标，熟用快捷键，用Vim，建TodoLists等等，大的方面如用工程化的思想组织代码，运用设计模式，做脚手架，工作流，构建代码库等等，还有一些好用的工具软件，阅读器，高效的学习周刊等等，这些是实际工作中的提高效率的方法。</p>
<p><strong>至于提高学习效率的方法，是去不断完善你学习东西的方法论，渐渐地这套学习体系在你的不断训练下会变得成熟而高效，所有遇到的难题都是可以抽象出相似点的，只要模型足够强大，就可以迅速匹配到解决方案，从而提升效率。工具终究是工具，而方法论才是支配工具的效率银弹。</strong>有点像机器深度学习模仿人脑神经元的算法，人工智能如果有一天可以接管人类，我想那就是因为AI有快速建模匹配的方法论，以及超高的学习效率吧。</p>
<p>我之所以对效率这么敏感不是没有原因的，首先我自己开始自学的时间比较迟，我本来就没有过多的时间，所以我只能通过提高效率来加快学习进度，而我本身是一个有挺多爱好，爱玩的同时还有间断性懒癌的人，因此总幻想通过有效率地工作来给自己的其他爱好腾出时间。然而后来我发现一个残酷的事实，大多数时候，高效率地学习之后会越着迷地接着学习，并不能腾出时间，即所谓沉迷学习不能自拔（可怕。就像以前玩炉石的时候的场景：这回用快攻流的牌，赶紧打完去打球喽，然后事实总是欢声笑语中再来一盘。</p>
<p>实习的好处都不用多说了，可以从我上面的描述体会到一些，我觉得最最主要的有三点：<strong>实用型技术知识的迅速增长，熟悉行业及业务流程，团队合作和自身价值体现的愉悦。</strong>除此之外还有可能收获，思维能力的提升，视野的开阔，一群志同道合的朋友或者几位爱聚餐爱争着请客的主管（逃。</p>
<p>还有钱方面的收获我也不怕落俗地说一说，毕竟钱也是我们大部分人学得勤的一个重要动力，我去实习的时间比较早，工资加上期间做了一些外包项目，离开学校这半年时间我大概净赚了2万块钱，在我买了一台Macbook pro，一部ipad mini4，还有把大学最后一年的学费交了之后，还剩两千块。</p>
<p>其实即使不是去阿里，许多公司的业务强度和收获的成长不见得比阿里低，不管去哪里实习，<strong>我觉得对于大部分搞技术学生来说都是一件非常值得的事情，你不用跟我一样冒着毕不了业的风险，只是把暑假寒假的时间拿出来，有时间尽早去工作，做你钟意的事情，一定可以让你有新的体会。</strong></p>
<h2 id="秋招找工作"><a href="#秋招找工作" class="headerlink" title="秋招找工作"></a>秋招找工作</h2><hr>
<p>秋招找工作的准备的过程十分艰苦，从七月中旬开始内部推荐到九月，这期间晚上我都是接近3点才睡觉，刷各种面试题，还要做项目，这里我做了一件很可怕，也很愚蠢的事情。我抖了个机灵，把很多之前做的项目还未实现的功能都写到简历上面了，因为我准备得太迟了，而且看到其他实习生简历的时候真的觉得自己的简历太不够看了。</p>
<p><strong>恰巧我当时对项目还有许多的改进想法，我就把还没有实现的功能也写到简历上面了，因为我知道我现在投的简历面试官基本都还不会去验证，我只要在真正面试之前把功能做出来就行了。然后自己制定了一个时间表，开始照着自己写的简历给自己的项目打补丁做功能，这就是菜鸟给简历补坑的历程啊（捂脸。</strong></p>
<p>而我平时早上7点多还要去上班，时间根本不够我整，所以我只能熬夜来完成这些东西，虽然也有不小的收获，但是这种折寿的做法就像阿凯的八门遁甲一样只能情急的时候搞一搞，况且阿凯完事了还有鸣人用六道之力给他续命。</p>
<p>后来种种原因，我没有继续留在阿里，其实我之前开始准备简历的时候就已经做好准备了，其中缘由比较复杂，有个人原因，也有团队因素，这里就不展开了。有趣的是我刚离开没多久，阿里就出了抢月饼事件，在程序员圈内引起了不小的争议，作为一个很喜欢捣鼓JavaScript的程序员，我对阿里HR所谓的企业价值观表示不解（摊手。</p>
<p>总之我辞去了工作之后就开始专心准备秋招的事情了，这个准备阶段让我自身差缺补漏了非常多之前学习前端过程中遗漏的知识点，重新看那些经典的书籍也带给了我很多不同的收获，着重安利《JavaScript高级程序设计》这本书，俗称红宝石，虽然名字叫高级，但其实是一本值得啃很多遍的基础书，应试的思维我推荐hax老师前端面试的知乎live，这个live是前不久才出的，虽然有点贵，但还是值得的。由于不用工作，这段时间的学习要比工作的时候系统得多，也快乐得多。因为得回学校补考，我在八月底回到了阔别已久的成都，然后选择了直接参加成都这边学校的校招，后来腾讯正式校招取消成都前端工程师的面试的时候我有后悔过这个决定，因为我其实可以直接在广州参加同学学校的校园招聘的，应该会有一个比较好的秋招应聘体验，当然这是后话了。</p>
<p>后来我陆续投了一些公司，以互联网公司为主，也有一些硬件公司巨头，基本都是广深的，主要还是比较想回大广东工作。包括内推的前后参加了大概有20次面试，收获了几份offer，这期间也碰了好几次壁，腾讯内推我就被刷了好几次，主要问题就是算法和基础的计算机软件知识不够硬，算法能力几乎可以忽略，这也暴露了我这个野专业的一些缺陷，前面虽然说web好入门，但它毕竟是软件的一个分支，别人考你比较底层的东西也无可厚非。所以秋招结束过后到最近这一段时间，我都一直在补计算机专业的基础知识，去一些OJ，比如leetcode上面练习算法。</p>
<p>面试就是一次学习和完善自身的过程，面试之前不断准备，面经要适当刷一点，了解一些面试的套路可以让自己的回答更加游刃有余，面试过后我会记录总结，把可以改进的点列举出来，每一次面试都要争取最好的表现。就像medium上的<a href="https://medium.freecodecamp.com/5-key-learnings-from-the-post-bootcamp-job-search-9a07468d2331">这篇面经</a>说的：<strong>You have to perform well, even when you’re not fully prepared. In order to succeed, you have to be your own advocate. —— 不管你有没有准备好，你都必须表现得很好。为了取胜，你必须展现出你最好的一面。</strong></p>
<p>找工作是个漫长的过程，整个秋招下来收获良多，有些是技术层面的，有些是应试技巧方面的，甚至和一些面试官成了朋友。我把找工作期间遇到的一些面试问题和总结的一些方法整理好，放在了gitbook上面：<a href="https://shudery.gitbooks.io/front-end-offer/content/">前端面试知识点整理</a>，此外我之前已经把秋招找工作以及遇到的趣事记录在另一篇文章，所以这里就不展开说了，如果还有其他的问题想和我交流都可以私信我。    </p>
<p><strong>最后选择去华为没有别的原因，就是厂比较大，给的钱也还可以，觉得华为可以在毕业的前几年给我提供一个比较好的环境来成长。</strong>当然后来了解一下，也渐渐知道华为确实是一家很有抱负很有实力的公司。话说我菊厂明年30周年要不要学一下某厂，每人发5万+红包呢（期待。不过网上黑华为的也是挺多的，好在现在BAT里的BA也时不时会加入了被黑的行列（逃，感觉华为在被黑的路上也不孤单了。</p>
<h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><hr>
<p>我当初决定放弃本专业，选择软件，自学编程的理由其实很简单，就是想找份自己可以接受的工作，同时必须得是自己的兴趣所在，我希望以后能活跃在一个喜欢的领域里，一辈子都受益于此。也许我做决定的时间比较晚，但我没有因为相对的起步晚而不去迈出第一步，所以才有了后面不断的成长和收获，如果不知道自己想成为怎样的人，那和西部世界的机器人有什么区别（逃。我还有很多不足，也知道这是个需要一直不断学习的职业，但是一想到编程可以做好多有意思的事情，就会一直努力的。</p>
<p>谢谢一直支持我，给我帮助的朋友，我会永远记得。<br>这就是我过去一年成为程序员的经历和感悟，没写过这么长的，感谢看完。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;决定去华为工作之后，一直有朋友建议我写一篇文章分享一下我的自学和跨界历程。因为我大学是电子工程专业，而我现在做的，之前的实习职位以及现在的offer都是web开发，它们几乎没有任何关联。另外我开始自学web的时间也比较晚，从决定试一试到现在大概过去一年的时间，一年时间以来在
    
    </summary>
    
      <category term="随写" scheme="http://shudery.cn/categories/%E9%9A%8F%E5%86%99/"/>
    
    
      <category term="随写" scheme="http://shudery.cn/tags/%E9%9A%8F%E5%86%99/"/>
    
  </entry>
  
  <entry>
    <title>实现通用的网站服务构建系统</title>
    <link href="http://shudery.cn/2016/11/23/%E7%AC%94%E8%AE%B0/%E5%AE%9E%E7%8E%B0%E9%80%9A%E7%94%A8%E7%9A%84%E7%BD%91%E7%AB%99%E6%9C%8D%E5%8A%A1%E6%9E%84%E5%BB%BA%E7%B3%BB%E7%BB%9F/"/>
    <id>http://shudery.cn/2016/11/23/笔记/实现通用的网站服务构建系统/</id>
    <published>2016-11-22T16:00:00.000Z</published>
    <updated>2019-02-12T02:51:26.070Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文章主要记录如何快速创建一个简洁，健壮的 web server，目标是实现网站服务的常用模块，尝试全栈思维开发，提供一套快速构建网站服务的全能脚手架，力求突破快速，低廉，优质只能兼得其二的工程瓶颈。<br>运用的技术栈：node + express + handlebars + mongDB + mocha</p>
<h3 id="创建服务和基础路由"><a href="#创建服务和基础路由" class="headerlink" title="创建服务和基础路由"></a>创建服务和基础路由</h3><p>如同客户端的事件响应，当客户端输入一个 url 之后，server 要如何响应这个事件，在 express 中可以通过中间件搭建各种路由，在客户端请求地址触发相应路由，返回对应的文件，入口文件 app.js 如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">const app = require(&apos;express&apos;)();</div><div class="line">const port = process.env.port || 3000;</div><div class="line">app.listen(port, (err) =&gt; &#123;</div><div class="line">    err &amp;&amp; log(&apos;error form app.listen()&apos;)</div><div class="line">    log(`application start listen at $&#123;port&#125;`)</div><div class="line">&#125;);</div><div class="line">app.get(&apos;/&apos;, (req, res) =&gt; &#123;</div><div class="line">    res.type(&apos;text/plain&apos;)</div><div class="line">    res.send(&apos;welcome home!&apos;);</div><div class="line">&#125;);</div><div class="line">&lt;!-- //404路由 --&gt;</div><div class="line">app.use((req, res) =&gt; &#123;</div><div class="line">    res.status(404);</div><div class="line">    res.send(&apos;404 not found&apos;);</div><div class="line">&#125;);</div><div class="line">&lt;!-- //500路由,根据传入参数来区分404路由 --&gt;</div><div class="line">app.use((err, req, res, next) =&gt; &#123;</div><div class="line">    res.status(500);</div><div class="line">    res.send(&apos;500 server error&apos;);</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>最基本的三个路由对应了三种网页请求状态，’/‘匹配响应了主页的正常请求。</p>
<h3 id="配置模板引擎"><a href="#配置模板引擎" class="headerlink" title="配置模板引擎"></a>配置模板引擎</h3><p>创建默认模板目录 views，再创建布局模板目录 layouts，都是默认参数，目录名照用就行。<br>添加 main.hbs 到 <code>/views/layouts</code>中，hbs 是 handlebars 的简写，记得给你使用的文本编辑器下载相应模板的插件，不然没有语法提示和补全很难过的，我用的 sublime text，直接下载 handlebars 这个插件即可。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&lt;!DOCTYPE html&gt;</div><div class="line">&lt;html lang=&quot;en&quot;&gt;</div><div class="line">&lt;head&gt;</div><div class="line">	&lt;meta charset=&quot;UTF-8&quot;&gt;</div><div class="line">	&lt;title&gt;home&lt;/title&gt;</div><div class="line">	&lt;script src=&apos;/js/test.js&apos;&gt;&lt;/script&gt;</div><div class="line">&lt;/head&gt;</div><div class="line">&lt;body&gt;</div><div class="line">	&#123;&#123;&#123;body&#125;&#125;&#125;</div><div class="line">&lt;/body&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure>
<p>其中 body 会结合路由配置自动读取 views 下的相应模板来代替这一块内容。<br>在 views 下添加主页模板<code>home.hbs</code>，404 页面模板<code>404.hbs</code>，服务器错误页面<code>500.hbs</code>，结合<code>main.hbs</code>形成一个对应页面的 html 文件。</p>
<p>在 app.js 中添加</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">const handlebars = require(&apos;express-handlebars&apos;);</div><div class="line">app.engine(&apos;.hbs&apos;, handlebars(&#123; defaultLayout: &apos;main.hbs&apos;,extname: &apos;.bhs&apos; &#125;));</div><div class="line">app.set(&apos;view engine&apos;, &apos;.hbs&apos;);</div></pre></td></tr></table></figure>
<p>其中 defaultLayout 设置了模板的进入地址，默认为 main，即上面创建的 main.hbs，然后设置文件扩展名缩写为.hbs，然后就可以结合模板来为路由配置返回的文件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">app.get(&apos;/&apos;, (req, res) =&gt; &#123;</div><div class="line">    res.render(&apos;home&apos;, &#123; nowTime: new Date() &#125;);</div><div class="line">&#125;)</div><div class="line">app.use((req, res) =&gt; &#123;</div><div class="line">    res.status(404);</div><div class="line">    res.render(&apos;404&apos;);</div><div class="line">&#125;);</div><div class="line">app.use((err, req, res, next) =&gt; &#123;</div><div class="line">    res.status(500);</div><div class="line">    res.render(&apos;500&apos;);</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>使用了 render 方法来调用模板，传入第一个参数即对应创建的模板文件名，第二个参数为传递对模板的配置对象，模板中通过可以获取到这个变量，视图引擎默认返回的文件就是<code>text/plain</code>，不用 res.type 设置，除了 200 状态码之外，其他状态码依然需要设置。</p>
<h3 id="设置静态文件路径"><a href="#设置静态文件路径" class="headerlink" title="设置静态文件路径"></a>设置静态文件路径</h3><p>项目目录下创建一个文件夹存放静态文件，这里用 public，添加如下代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">app.use(express.static(__dirname + &apos;/public&apos;));</div></pre></td></tr></table></figure>
<p>添加这段代码之后，在模板中引用的静态文件就是以/public 为根目录了，比如<code>&lt;img src=&quot;/img/icon.jpg&quot;&gt;</code>对应查找的路径就是<code>/public/img/icon.jpg</code></p>
<h3 id="添加测试框架"><a href="#添加测试框架" class="headerlink" title="添加测试框架"></a>添加测试框架</h3><p>测试系统对于一个健壮的 web 项目的支撑作用十分重要，提前写好测试可以大幅降低后期维护的成本。本项目使用 Mocha 框架和 chai 断言库进行测试，将这两个文件统一放到<code>public/vendor</code>中，将测试用例统一放在<code>public/test</code>目录下，在 test 目录中添加一个全部页面都运行的测试 global.js</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">suite(&apos;Global Tests&apos;,()=&gt;&#123;</div><div class="line">    test(&apos;page have a valid title:&apos;+document.title,()=&gt;&#123;</div><div class="line">        assert(document.title &amp;&amp; document.title.toUpperCase() !== &apos;TODO&apos;)</div><div class="line">    &#125;)</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>添加一个 about 页面单独运行的测试 about.js</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">suite(&apos;About Page Test&apos;,()=&gt;&#123;</div><div class="line">    test(&apos;contain a tag&apos;,()=&gt;&#123;</div><div class="line">        assert(document.getElementsByTagName(&apos;a&apos;).length)</div><div class="line">    &#125;)</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>在 app.js 文件中添加开启测试的方式，这里用查询参数<code>?test=1</code>来开启</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">app.use((req,res,next)=&gt;&#123;</div><div class="line">    &lt;!-- //res.locals可以传递给视图模板 --&gt;</div><div class="line">    res.locals.startTests = (app.get(&apos;env&apos;)!== &apos;production&apos; &amp;&amp; req.query.test === 1);</div><div class="line">    next();</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>将主要逻辑放在公用模板 main.hbs 中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">&lt;link rel=&apos;stylesheet&apos; href=&apos;/vendor/mocha.css&apos;&gt;</div><div class="line">&lt;script src=&apos;/vendor/mocha.js&apos;&gt;&lt;/script&gt;</div><div class="line">&lt;script src=&apos;/vendor/chai.js&apos;&gt;&lt;/script&gt;</div><div class="line">&#123;&#123;#if startTests&#125;&#125;</div><div class="line">    &lt;div id=&quot;mocha&quot;&gt;&lt;/div&gt;</div><div class="line">    &lt;script&gt;</div><div class="line">    console.log(&apos;startTests&apos;)</div><div class="line">    mocha.ui(&apos;tdd&apos;);</div><div class="line">    var assert = chai.assert;</div><div class="line">    &lt;/script&gt;</div><div class="line">    &lt;script src=&apos;/test/global.js&apos;&gt;&lt;/script&gt;</div><div class="line">    &#123;&#123;#if pageTestPath&#125;&#125;</div><div class="line">        &lt;script src=&apos;&#123;&#123;pageTestPath&#125;&#125;&apos;&gt;&lt;/script&gt;</div><div class="line">    &#123;&#123;/if&#125;&#125;</div><div class="line">    &lt;script&gt;mocha.run()&lt;/script&gt;</div><div class="line">&#123;&#123;/if&#125;&#125;</div></pre></td></tr></table></figure>
<p>启动服务，访问<code>localhost:3000/about?test=1</code>，查看测试结果<br><img src="/pic/3.jpg" alt=""></p>
<p>在 test 目录下继续添加逻辑功能的单元测试 unit.js，区别于页面测试，逻辑测试使用 describe/it/expect 来描述，结构如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var mocha = require(&apos;mocha&apos;)</div><div class="line">var expect = require(&apos;chai&apos;).expect</div><div class="line">var log = require(&apos;../lib/daguo&apos;).log</div><div class="line">describe(&apos;Unit Tests&apos;,()=&gt;&#123;</div><div class="line">    it(&apos;log modules&apos;,()=&gt;&#123;</div><div class="line">        expect(typeof log(&apos;test&apos;) === &apos;string&apos;)</div><div class="line">    &#125;)</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p><strong>TIPS:</strong></p>
<ul>
<li>使用 nodemon 自动重启 server 服务，结合 webpack，gulp 等构建工具可以热加载刷新浏览器页面，进一步实现自动化</li>
<li>一些需要浏览器操作的测试可以通过 zombie，phantomJS 等框架来实现</li>
<li>在<a href="https://travis-ci.org">https://travis-ci.org</a>给项目添加自动集成测试，每一次提交代码会自动运行测试代码</li>
<li>express-handlebars 这个模板在 partials 路径这里有问题，一直提示找不到对应部分的模板，换成 express-hbs 可解决，并且不用再配置 hbs 的简写后缀了</li>
</ul>
<h3 id="添加-cookie"><a href="#添加-cookie" class="headerlink" title="添加 cookie"></a>添加 cookie</h3><p>网站门户少不了需要添加用户配置，可以针对性地提供一些服务，而 cookie 是用户身份的凭证，为使用无状态 HTTP 协议的浏览器提供了识别用户的能力，接下来给网站添加登录模块的功能。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">//set cookie-parser</div><div class="line">app.use(require(&apos;cookie-parser&apos;)(credentials.cookieSecret));</div><div class="line">//postbody-parser</div><div class="line">app.use(require(&apos;body-parser&apos;).urlencoded(&#123; extended: false &#125;));</div><div class="line">app.get(&apos;/login&apos;, (req, res) =&gt; &#123;</div><div class="line">    if (req.cookies.daguoCookie === &apos;string123&apos;) &#123;</div><div class="line">        // res.render(&apos;user&apos;, &#123; cookie: req.cookies.daguoCookie &#125;)</div><div class="line">        res.redirect(303, &apos;/user&apos;)</div><div class="line">    &#125; else &#123;</div><div class="line">        res.render(&apos;login&apos;)</div><div class="line">    &#125;</div><div class="line">&#125;)</div><div class="line">app.post(&apos;/process&apos;, (req, res) =&gt; &#123;</div><div class="line">    if (req.xhr || req.accepts(&apos;json,html&apos;) === &apos;json&apos;) &#123;</div><div class="line">        log(req.xhr)</div><div class="line">        res.send(&apos;process receive a xhr or json accepts&apos;)</div><div class="line">    &#125;</div><div class="line">    if (req.body.user === &apos;user&apos; &amp;&amp; req.body.password === &apos;123&apos;) &#123;</div><div class="line">        res.cookie(&apos;daguoCookie&apos;, &apos;string123&apos;)</div><div class="line">        res.redirect(303, &apos;/user&apos;)</div><div class="line">            // res.render(&apos;user&apos;, &#123; user: req.body.user, password: req.body.password &#125;)</div><div class="line">    &#125; else &#123;</div><div class="line">        res.render(&apos;error&apos;, &#123; message: &apos;user name or password is error&apos; &#125;)</div><div class="line">    &#125;</div><div class="line">&#125;)</div><div class="line">app.get(&apos;/user&apos;, (req, res) =&gt; &#123;</div><div class="line">    res.render(&apos;user&apos;)</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>添加 credentials.js 存储证书文件<br>需要添加两个功能中间件，<code>body-parser</code>和<code>cookie-parser</code>，分别用来解析 request 请求中的表单 body 和之前服务器返回的 cookie，第一次登录输入硬编码的用户名和密码，下一次再登录 login 界面将直接跳转到 user 路由，渲染 user 页面。<br>login 页面主要是一个登录表单:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;form action=&quot;/process?from=login&quot; method=&quot;POST&quot;&gt;</div><div class="line">    &lt;label for=&quot;user&quot;&gt;user: &lt;input type=&quot;text&quot; name=&quot;user&quot;&gt;&lt;/label&gt;</div><div class="line">    &lt;label for=&quot;password&quot;&gt;password: &lt;input type=&quot;password&quot; name=&quot;password&quot;&gt;&lt;/label&gt;</div><div class="line">    &lt;input type=&quot;submit&quot; value=&quot;submit&quot;&gt;</div><div class="line">&lt;/form&gt;</div></pre></td></tr></table></figure>
<p>反复调试可以通过设置 cookie 的 maxAge 为一个较短的时间，或者用 chrome 工具删除 cookie，也可以直接通过 JS 将 document.cookie 设置为<code>&#39;{cookiename}=0&#39;</code>的形式来清除 cookie</p>
<h3 id="开发前端界面"><a href="#开发前端界面" class="headerlink" title="开发前端界面"></a>开发前端界面</h3><p>完成了一些后台逻辑之后我们需要对网站的展示部分进行设计和开发，可以结合网上流行的各种前端展示框架，比如 Bootstrap，semanticUI，material-UI，等等进行开发，这些框架给我们提供了网页常用的各种组件，包括导航条，图标，按钮，表单的样式都已经有一套统一的设计，如果希望网站的展示效果区别于普通的网站，那就避免用 Boostrap，因为它实在是太流行了，github 上 10W+的 star 是其他前端框架的好几倍，不是它不好，只是用久了难免有一些审美疲劳。</p>
<p>我在这套网站构建系统中使用的是 semanticUI，它同样提供了丰富的前端组件，其次它的设计风格似乎要更有美感一些，但是它整包的体积太大了，从开发到生产要自行 Build 出相关样式的文件才划算。此外 semanticUI 的 API 风格是短类型名+多类型的组合，粒度更小，自由度比较高，举个栗子就是将 btn-info-right 的展示效果分割成三个类 btn，info 和 right，这样可能会导致一些命名冲突的问题，但在小型项目中就不予考虑了。</p>
<p>由于页面设计能力有限，所以暂时先临摹一下 medium 网站的展示效果:<br><img src="/pic/1.jpg" alt=""><br>模仿效果，具体可以看 github 的代码:<br><img src="/pic/2.jpg" alt=""></p>
<h3 id="邮件系统"><a href="#邮件系统" class="headerlink" title="邮件系统"></a>邮件系统</h3><p>使用 nodemailer 模块构建 web 应用的邮件 server 非常方便，在 lib 下新建 mailer.js</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">const nodemailer = require(&apos;nodemailer&apos;);</div><div class="line">module.exports = function(credentials) &#123;</div><div class="line">    let mailTransport = nodemailer.createTransport(&apos;smtps://&apos; + credentials.gmail.user + &apos;%40gmail.com:&apos; + credentials.gmail.password + &apos;@smtp.gmail.com&apos;);</div><div class="line">    let from = &apos;node-web-server-mailer&lt;shudery@gamil.com&gt;&apos;;</div><div class="line">    let masterEmail = &apos;125153450@qq.com&apos;</div><div class="line">    return &#123;</div><div class="line">        send(subject, html, to) &#123;</div><div class="line">            mailTransport.sendMail(&#123;</div><div class="line">                to: to ? to : masterEmail,</div><div class="line">                from,</div><div class="line">                subject,</div><div class="line">                html,</div><div class="line">            &#125;, (err, info) =&gt; &#123;</div><div class="line">                if (err) &#123;</div><div class="line">                    return console.log(&apos;send email error:&apos; + err);</div><div class="line">                &#125;;</div><div class="line">                console.log(&apos;send email info:&apos; + info.response);</div><div class="line">            &#125;);</div><div class="line">        &#125;,</div><div class="line">        errorSend(message, filename, exception) &#123;</div><div class="line">            let html = `&lt;h1&gt;site error:&lt;/h1&gt;message:$&#123;message&#125;&lt;br&gt;`;</div><div class="line">            if (filename) &#123;</div><div class="line">                html += `filename:$&#123;filename&#125;&lt;br&gt;`;</div><div class="line">            &#125;</div><div class="line">            if (exception) &#123;</div><div class="line">                html += `exception;$&#123;exception&#125;`;</div><div class="line">            &#125;</div><div class="line">            mailTransport.sendMail(&#123;</div><div class="line">                from,</div><div class="line">                to: masterEmail,</div><div class="line">                subject: &apos;site error&apos;,</div><div class="line">                html,</div><div class="line">            &#125;)</div><div class="line">        &#125;,</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="未完待续……"><a href="#未完待续……" class="headerlink" title="未完待续……"></a>未完待续……</h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇文章主要记录如何快速创建一个简洁，健壮的 web server，目标是实现网站服务的常用模块，尝试全栈思维开发，提供一套快速构建网站服务的全能脚手架，力求突破快速，低廉，优质只能兼得其二的工程瓶颈。&lt;br&gt;运用的技术栈：node + express + handleba
    
    </summary>
    
      <category term="笔记" scheme="http://shudery.cn/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Node.js" scheme="http://shudery.cn/tags/Node-js/"/>
    
  </entry>
  
  <entry>
    <title>简易的RSS格式输出工具</title>
    <link href="http://shudery.cn/2016/11/20/%E7%AC%94%E8%AE%B0/%E7%AE%80%E6%98%93%E7%9A%84RSS%E6%A0%BC%E5%BC%8F%E8%BE%93%E5%87%BA%E5%B7%A5%E5%85%B7/"/>
    <id>http://shudery.cn/2016/11/20/笔记/简易的RSS格式输出工具/</id>
    <published>2016-11-19T16:00:00.000Z</published>
    <updated>2019-02-12T01:39:07.541Z</updated>
    
    <content type="html"><![CDATA[<p>RSS 即简易信息聚合，当一个网站发布一个 RSS 文件后，这个 RSS-Feed 中包含的信息就能直接被其他站点调用，而且由于这些数据都是标准的 XML 格式，所以也能在其他的终端和服务中使用，是一种描述和同步网站内容的格式。</p>
<p>由于我习惯用 mac 触摸手势的操作，以及不喜欢在浏览器里点击位于不同收藏夹里的标签，用 RSS 阅读器这种内容聚合方式，极大提升了我阅读文章，获取资源的效率，但是现在许多我喜欢的站点不开放 RSS 格式的输出源，或者已经停止维护老旧的 RSS 地址了，因此我将这些站点先进行爬取，提取相应内容，然后结合标准的 RSSXML 模板将其输出，使其能够被 RSS 阅读器正常的订阅。</p>
<p>下面我就介绍一下这个工具：<a href="https://github.com/shudery/RSS-feed-spider">github 地址</a></p>
<h2 id="RSS-feed-spider"><a href="#RSS-feed-spider" class="headerlink" title="RSS-feed-spider"></a>RSS-feed-spider</h2><h4 id="功能介绍"><a href="#功能介绍" class="headerlink" title="功能介绍"></a>功能介绍</h4><p>可以自己制作各大网站，内容频道的文章 RSS 格式输出源，通过爬虫工具抓取内容，输出 RSS 阅读器能够识别的 XML 格式，部署在 PASS 平台可以供阅读器订阅。目前由于很多站点二次爬取模板还没开发，故详情内容要跳转到原站，这对手势操作以及原本就想看原站的人没有大多影响，当然了，这意味着没法离线阅读内容，或者说事先缓存文章（只有标题）</p>
<h4 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h4><p>利用 site 目录下存好的各站点基本信息，根据页面结构修改选择器，利用爬虫爬取页面，抓取相关信息填入 RSS-XML 模板中，将结果的 XML 文件返回到客户端，服务端使用 Node.js 和 web 应用快速搭建框架 express，爬虫用 superagent，pass 平台使用 heroku(国外不太稳定)</p>
<h4 id="查询参数"><a href="#查询参数" class="headerlink" title="查询参数"></a>查询参数</h4><p>每个 RSS 订阅源的格式为：<a href="https://daguo-rss.herokuapp.com/?site={}">https://daguo-rss.herokuapp.com/?site={}</a><br>可以在订阅 url 后面添加查询参数，如?site=jianshu&amp;num=20&amp;desc=true</p>
<ul>
<li>site：站点名字</li>
<li>num：抓取文章数量，默认 10，没有翻页逻辑，最多主页全部文章</li>
<li>desc：是否抓取描述，需要二次爬取，不稳定，默认不开</li>
</ul>
<h4 id="扩展方法"><a href="#扩展方法" class="headerlink" title="扩展方法"></a>扩展方法</h4><p>直接在项目 site 目录下生成相应的站点爬取脚本，脚本名字即对应的查询参数里 site={}需要填写的字符串。单次爬取的模板都一样，只需要配置相应的 RSS 基本信息，修改 getItems 函数中相应字段的选择器，这里用 cheerio 获取 DOM 节点。</p>
<h4 id="完成站点"><a href="#完成站点" class="headerlink" title="完成站点"></a>完成站点</h4><ul>
<li><a href="https://daguo-rss.herokuapp.com/?site=jianshu">简书热门频道</a></li>
<li><a href="https://daguo-rss.herokuapp.com/?site=guoke">果壳</a></li>
<li><a href="https://daguo-rss.herokuapp.com/?site=juejin">掘金前端</a></li>
<li><a href="https://daguo-rss.herokuapp.com/?site=ted">TED</a></li>
<li><a href="https://daguo-rss.herokuapp.com/?site=zaoduke">前端早读课</a></li>
<li><a href="https://daguo-rss.herokuapp.com/?site=hacker">Hacker News</a></li>
<li><del>电子科技大学 UESTC 新闻</del></li>
<li><del>下厨房流行菜谱</del></li>
<li><del>卢松松好文分享</del></li>
<li><del>微信自媒体</del></li>
<li><del>开发者头条</del></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;RSS 即简易信息聚合，当一个网站发布一个 RSS 文件后，这个 RSS-Feed 中包含的信息就能直接被其他站点调用，而且由于这些数据都是标准的 XML 格式，所以也能在其他的终端和服务中使用，是一种描述和同步网站内容的格式。&lt;/p&gt;
&lt;p&gt;由于我习惯用 mac 触摸手势
    
    </summary>
    
      <category term="笔记" scheme="http://shudery.cn/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="工具" scheme="http://shudery.cn/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="Node.js" scheme="http://shudery.cn/tags/Node-js/"/>
    
  </entry>
  
  <entry>
    <title>基于openCV的计算机视觉研究</title>
    <link href="http://shudery.cn/2016/11/08/%E7%AC%94%E8%AE%B0/%E5%9F%BA%E4%BA%8EopenCV%E7%9A%84%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E7%A0%94%E7%A9%B6/"/>
    <id>http://shudery.cn/2016/11/08/笔记/基于openCV的计算机视觉研究/</id>
    <published>2016-11-07T16:00:00.000Z</published>
    <updated>2019-02-12T01:31:11.226Z</updated>
    
    <content type="html"><![CDATA[<p>计算机视觉随着 AR，VR，自动驾驶，人工智能等技术的崛起，已经成为一个迅速发展并且富有前景的领域。openCV，计算机视觉开源库，与前端工程师经常打交道的 openGL 算是兄弟函数库。</p>
<p>openGL 作为专业的图形编程接口，为程序员提供了功能强大，调用方便的底层图形库。openCV 则致力于提供实现图像处理和计算机视觉的通用算法，降低了学习计算机设觉领域的门槛，让开发者可以更快的收获机器视觉带来的乐趣。</p>
<p>说了这么多然而我是一个前端工程师啊，我更关心人类的视觉体验，无缘无故怎么会闲的蛋疼跑来弄计算机视觉呢；好吧这其实是我的毕业设计题目，之前没有事先找老师拿题目，在选择毕业设计的那个早晨，我睡过了。。许多我擅长的软件题目都被选了，所以我还感兴趣的就剩下了比较难啃的计算机视觉还有深度学习相关的课题，老师说如果我下学期要去实习，推荐我选相对简单的计算机视觉。选好题目和实验室学长打过招呼拿了一些学习资料后，由于各种事情搁置了一段时间，最近闲起来，决定开始学习这个火热的领域。</p>
<p>回到正题，openCV 是用 C++编写的，但是依然有大量的 C 语言接口。该库也有大量的 Python,Java,MATLAB 的接口，由于我最近刚好在复习 C 语言，平时写算法如果不能用 ES6 也都是用 C，所以我觉得用 C 语言来完成后续的编程工作。</p>
<p>学习过程中，感受到了很多资料的缺失和落后，国外要好一点，而且社区也远远没有前端技术社区的氛围，有一些小坑解决起来还挺浪费时间的，今天我已经把 openCV 在 macOS 的开发环境，包括 xCode 的一些设置，作为前端 ST 信仰粉，一直秉持不到万不得已不用 IDE 的态度，然而这次为了调试还是用 xCode 吧，基于 sublime text 的 latex 论文书写环境也配置好了，接下来就是一边理论学习，一边实践操作的过程了，希望年前能有一个比较好的完成度，同时对这个领域能有一些比较深入的见解。</p>
<hr>
<p>下面记录一下搭建环境的过程，后续会继续记录基于 openCV 的计算机视觉的研究成果~</p>
<h3 id="macOS-搭建基于-Xcode-的-openCV-开发环境"><a href="#macOS-搭建基于-Xcode-的-openCV-开发环境" class="headerlink" title="macOS 搭建基于 Xcode 的 openCV 开发环境"></a>macOS 搭建基于 Xcode 的 openCV 开发环境</h3><h4 id="下载源码："><a href="#下载源码：" class="headerlink" title="下载源码："></a>下载源码：</h4><p>mac 下运用 openCV 的函数需要自行编译源代码，官方的解释是由于包括 linux 和 macOS 的各类 Unix 系统各自带的编译器不同，所以需要多几个步骤，可以从官网上选择相应版本的 zip 下载。openCV 是使用非常宽松的 BSD 协议的开源项目，BSD 比起 MIT 而言在修改代码，重新封装之后不要求一定要公开源码，现在计算机视觉开发尚未普及，这么做也是保护使用 openCV 公司的商业机密，让开发者可以毫无顾虑的使用 openCV 这个视觉库，所以也可以直接从 github 上下载 openCV，</p>
<h4 id="编译源码："><a href="#编译源码：" class="headerlink" title="编译源码："></a>编译源码：</h4><p>下载 mac 编译源码的工具 cmake，直接一行 homebrew 代码搞定：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">brew install cmake</div></pre></td></tr></table></figure>
<p>然后解压下载的 zip 源代码，进入解压后的文件目录，创建一个存放 openCV 函数的目录 release，在该目录下执行命令开始编译。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">mkdir release</div><div class="line">cd release</div><div class="line">cmake -G &quot;Unix Makefiles&quot;</div><div class="line">make</div><div class="line">make install</div></pre></td></tr></table></figure>
<p>部分命令可能需要 sudo 权限。</p>
<h4 id="Xcode-开发环境："><a href="#Xcode-开发环境：" class="headerlink" title="Xcode 开发环境："></a>Xcode 开发环境：</h4><p>新建命令行 command line tool 工程，选择 C 或者 C++语言，<br>可以复制下面这段<code>hello world</code>式的开始程序来调试，用通常的打印信息的函数可以检验大多数编程环境，但是由于这里涉及到代码库是否成功引入等问题，所以运用一些 openCV 的通用函数来看能否成功运行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">#include &lt;highgui.h&gt;</div><div class="line">int main(int argc, char **argv)</div><div class="line">&#123;</div><div class="line">    IplImage *img = cvLoadImage( argv[1],-1);</div><div class="line">    cvNamedWindow( &quot;Example1&quot;, CV_WINDOW_AUTOSIZE);</div><div class="line">    cvShowImage( &quot;Example1&quot;, img);</div><div class="line">    cvWaitKey(0);</div><div class="line">    cvReleaseImage( &amp;img);</div><div class="line">    cvDestroyWindow( &quot;Example1&quot;);</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这段代码功能很简单，可以读取本地的一张图片并展示出来，这里参数 argv[1]需要替换为要显展示图片的地址，第二个参数有三个取值：-1 为默认读取图像的原通道数；0 为强制转化读取图像为灰度图；1 为读取彩色图，每个函数的用途非常简单好用：<code>IplImage</code> 是一个存储图片的结构体，<code>cvLoadImage</code> 为存储图片的方式，<code>cvNamedWindow</code> 创建一个名字为<code>Example1</code>的窗口，第二个参数<code>CV_WINDOW_AUTOSIZE</code>表示窗口大小根据加载的图片自动变化，<code>cvWaitKey(0)</code>含义是读取到键盘操作继续进行程序，<code>cvReleaseImage</code>和<code>cvDestroyWindow</code>是释放结构体和窗口的空间，可以省略，加上更严谨。</p>
<p>然后开始运行左上角的三角按钮，或者 cmd+B 构建，会提示找不到 highgui.h 的文件，所以我们还需要给这个项目配置头文件路径。</p>
<h4 id="配置头文件路径："><a href="#配置头文件路径：" class="headerlink" title="配置头文件路径："></a>配置头文件路径：</h4><p>点一下左侧文件的项目根，中间代码区域找到 Bulid Setting，在搜索栏中输入 search<br>找到 Header search Paths 这一项添加 openCV 三个默认的编译存储地址：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">/usr/local/include</div><div class="line">/usr/local/include/opencv</div><div class="line">/usr/local/include/opencv2</div></pre></td></tr></table></figure>
<p>Library search Paths 这一项添加</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/usr/local/lib</div></pre></td></tr></table></figure>
<p><img src="/pic/1-2.png" alt=""></p>
<p>完成之后编译运行程序，正常来说，应该还有报错和 40 多个 warning 警告，警告大部分是未使用的函数报警，这个无关紧要，分析错误查了一波资料哦后发现还缺少在项目中引入一些 openCV 的<code>.dylib</code>文件。</p>
<h4 id="引入-dylib-文件："><a href="#引入-dylib-文件：" class="headerlink" title="引入.dylib 文件："></a>引入.dylib 文件：</h4><p><code>.dylib</code>位于编译目录 release 的 lib 目录中，在项目根右击创建一个新组 lib，添加所有的<code>.dylib</code>文件进去即可成功实现第一个<code>helloworld</code>程序。<br><img src="/pic/1-1.png" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;计算机视觉随着 AR，VR，自动驾驶，人工智能等技术的崛起，已经成为一个迅速发展并且富有前景的领域。openCV，计算机视觉开源库，与前端工程师经常打交道的 openGL 算是兄弟函数库。&lt;/p&gt;
&lt;p&gt;openGL 作为专业的图形编程接口，为程序员提供了功能强大，调用方便
    
    </summary>
    
      <category term="笔记" scheme="http://shudery.cn/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="技术研究" scheme="http://shudery.cn/tags/%E6%8A%80%E6%9C%AF%E7%A0%94%E7%A9%B6/"/>
    
  </entry>
  
  <entry>
    <title>运用钩子：监听npm仓库和包更新</title>
    <link href="http://shudery.cn/2016/11/07/%E7%BF%BB%E8%AF%91/%E8%BF%90%E7%94%A8%E9%92%A9%E5%AD%90%EF%BC%9A%E7%9B%91%E5%90%ACnpm%E4%BB%93%E5%BA%93%E5%92%8C%E5%8C%85%E6%9B%B4%E6%96%B0/"/>
    <id>http://shudery.cn/2016/11/07/翻译/运用钩子：监听npm仓库和包更新/</id>
    <published>2016-11-06T16:00:00.000Z</published>
    <updated>2019-02-12T01:40:30.250Z</updated>
    
    <content type="html"><![CDATA[<p><strong>本文由我翻译在<a href="http://www.zcfy.cc/claim">众成</a>翻译平台，<a href="http://www.zcfy.cc/article/introducing-hooks-get-notifications-of-npm-registry-and-package-changes-as-they-happen-1610.html">文章地址</a></strong></p>
<p>今天我很高兴地给大家介绍一种简单强大的方法，可以用于追踪 npm 仓库变更，构建自己的开发环境的工具：钩子。</p>
<h2 id="What"><a href="#What" class="headerlink" title="What?"></a>What?</h2><p>钩子是你订阅的 npm 仓库事件的通知者，运用钩子，你能构建可以响应 npm 仓库中软件包更改的处理各种任务的集成环境。</p>
<p>每一次软件包变化，钩子会发送一个 HTTP 的 POST 请求给一个你在钩子中配置的 URI 地址，你可以添加钩子来监听特别的软件包，监听包发布者的动态，或者监听一个组织里的所有软件包和用户。</p>
<p>举个栗子，你可以通过给<strong>@npm</strong>设置一个钩子，监视 npm 所有上传的软件包，如果你只想监视 lodash 这个包，同样可以给<strong>@lodash</strong>设置钩子。</p>
<h2 id="When"><a href="#When" class="headerlink" title="When?"></a>When?</h2><p>如果你有一个 paid，<a href="http://t.umblr.com/redirect?z=https%3A%2F%2Fwww.npmjs.com%2Fnpm%2Fprivate-packages&amp;t=MGY4N2Q4OWRmYTljZDg2YzViMzQzZGY5YmE4ZWJiOGI3MDg2M2QwOSxycTRWMHI1eA%3D%3D">个人或者组织的 npm 账号</a>，那么你可以马上运用钩子。</p>
<p>每一个用户可以配置总共 100 个钩子，至于要如何使用它们，这就取决你了：你可以将它们都用于监听同一个软件包，或者监听 100 个不同的包。如果你用一个钩子监听某一个范围，那么算作一个单一的钩子，不论这个范围内有多少个软件包。你可以监视 npm 代码库中任何开源的软件包，以及任何你可以控制的私人包，你只能收到有权限访问的软件包的钩子通知。</p>
<h2 id="How"><a href="#How" class="headerlink" title="How?"></a>How?</h2><p><img src="http://p0.qhimg.com/t01252b2385f2f7beb8.png" alt="!full Slack integration"></p>
<p>现在用<a href="http://t.umblr.com/redirect?z=https%3A%2F%2Fwww.npmjs.com%2Fpackages%2Fwombat&amp;t=Y2JjNDUwNzc2ZWZiY2Q3NDMxZjVhM2ZmZTM2NGE3ZTU0Njc0MmEyMSxycTRWMHI1eA%3D%3D">wombat</a>命令行工具创建你的第一个钩子。</p>
<p>首先，用通用的方法下载 wombat</p>
<p><code>npm install -g wombat</code></p>
<p>然后开始设置一些钩子。</p>
<p><strong>1. 监听 npm 的软件包：</strong></p>
<p><code>wombat hook add npm</code></p>
<p><a href="http://t.umblr.com/redirect?z=https%3A%2F%2Fexample.com%2Fwebhooks&amp;t=ZDA5NzVhODQ0MjQ0ZmI2MzhmOGMzZjYwZTljZGEzYTBkMjIwZmU3YSxycTRWMHI1eA%3D%3D">https://example.com/webhooks</a> shared-secret-text</p>
<p><strong>2. 监听@slack 组织客户 API 的更新：</strong></p>
<p><code>wombat hook add @slack</code></p>
<p><a href="http://t.umblr.com/redirect?z=https%3A%2F%2Fexample.com%2Fwebhooks&amp;t=ZDA5NzVhODQ0MjQ0ZmI2MzhmOGMzZjYwZTljZGEzYTBkMjIwZmU3YSxycTRWMHI1eA%3D%3D">https://example.com/webhooks</a> but-sadly-not-very-secret</p>
<p><strong>3. 监听 ever-prolific substack:</strong></p>
<p><code>wombat hook add --type=owner substack</code></p>
<p><a href="http://t.umblr.com/redirect?z=https%3A%2F%2Fexample.com%2Fwebhooks&amp;t=ZDA5NzVhODQ0MjQ0ZmI2MzhmOGMzZjYwZTljZGEzYTBkMjIwZmU3YSxycTRWMHI1eA%3D%3D">https://example.com/webhooks</a> this-secret-is-very-shared</p>
<p><strong>4. 查看你的所有钩子以及它们上一次触发的时间:</strong></p>
<p><code>wombat hook ls</code></p>
<p>提示：Wombat 还有几个有趣的用法。<code>wombat --help</code>会告诉你还有哪些用法。</p>
<p>我们也提供了公共的 API 来运行钩子，更多的细节以及如何运用 API 而不用 wombat 来管理你的钩子可以参考<a href="http://t.umblr.com/redirect?z=https%3A%2F%2Fgithub.com%2Fnpm%2Fregistry%2Ftree%2Fmaster%2Fdocs%2Fhooks&amp;t=MDE2Y2IzMjJjMGVlOGVkMGY0ZDAwZDhhMzhjMTVmNjJjZGNiOWI4MCxycTRWMHI1eA%3D%3D">文档</a>.</p>
<h2 id="Why"><a href="#Why" class="headerlink" title="Why?"></a>Why?</h2><p>你能运用钩子来触发集成测试，触发代码部署，在聊天频道发布通知或者触发你自己软件包的更新</p>
<p>为了帮助你更好地上手，提供给你一些我们在开发钩子的时候整理的资料。</p>
<ul>
<li><p><a href="http://t.umblr.com/redirect?z=https%3A%2F%2Fwww.npmjs.com%2Fpackage%2Fnpm-hook-receiver&amp;t=OGRjZGI4YmEyYzQ0NDY0YzZjOTdiMzEzOGY5ZTE2MzM2ODViZThkOSxycTRWMHI1eA%3D%3D">npm-hook-receiver</a>: 一个用钩子监听 HTTP 的 post 请求的<a href="http://t.umblr.com/redirect?z=https%3A%2F%2Fwww.npmjs.com%2Fpackage%2Frestify&amp;t=OTI5YzEwOGFhNGE2NjhkYzg0ZWNjMzY5OTI5N2Y3YjM0YmNiZjc2YSxycTRWMHI1eA%3D%3D">例子</a>，<a href="http://t.umblr.com/redirect?z=https%3A%2F%2Fgithub.com%2Fnpm%2Fnpm-hook-receiver&amp;t=Yjk3ZWI1OWE5YTg5ZmQ2NWM4Yzk4N2YwOGYwYjVlYTM1ZWE0NjZiNCxycTRWMHI1eA%3D%3D">源码点这里</a>.</p>
</li>
<li><p><a href="http://t.umblr.com/redirect?z=https%3A%2F%2Fgithub.com%2Fnpm%2Fnpm-hook-slack&amp;t=MGY1NTdjMjUwZjZkODJlZGI1YTFiNDJhNWI5YzNkZDcyOTc5NWI5YSxycTRWMHI1eA%3D%3D">npm-hook-slack</a>: 世界上最简单的播报 Slack 包事件的 Slackbot，用 npm-hook-receiver 构建.</p>
</li>
<li><p><a href="http://t.umblr.com/redirect?z=https%3A%2F%2Fgithub.com%2Fnpm%2Fcaptain-hook&amp;t=ZDc3ZDU2MDZjMjRlNjRkMGIyYmMyZDA2OTFkNjA3NGFhY2JmMmRiOSxycTRWMHI1eA%3D%3D">captain-hook</a>: 一个有趣的工具帮你管理你的 web 钩子以及接收 posts.</p>
</li>
<li><p><a href="http://t.umblr.com/redirect?z=https%3A%2F%2Fwww.npmjs.com%2Fpackage%2Fwombat&amp;t=NDBiZDBlZDM0OGY0OGYwOGFlNGU5YzdjYWJkNTUxNzgzMWZiOTU1OSxycTRWMHI1eA%3D%3D">wombat</a>: 一个 CLI 命令行工具，用于检查和编辑你的钩子，这个客户端运用所有的钩子 API，<a href="http://t.umblr.com/redirect?z=https%3A%2F%2Fgithub.com%2Fnpm%2Fwombat-cli&amp;t=YzQxZTJiYWVkYTBhYmIyYmQzMTc4M2Y2ZTVmMjc3ZGMxOWRiNDY5MyxycTRWMHI1eA%3D%3D">源码点这里</a>.</p>
</li>
<li><p><a href="http://t.umblr.com/redirect?z=https%3A%2F%2Fgithub.com%2Fnpm%2Fifttt-hook-translator&amp;t=NjliNTU2YjkyZDVkNDEyOWMwZGFkODMxNGE5MzU5OWMzODVjMGQ4NSxycTRWMHI1eA%3D%3D">ifttt-hook-translator</a>: 一个可以接收 web 钩子已经将其转化为<a href="http://t.umblr.com/redirect?z=https%3A%2F%2Fifttt.com%2F&amp;t=ZWI1MzhmMzYxOGVlNTExNjYwYWY1ZWNlMWNhZDdiOTQ5ZmU5ZjBlMixycTRWMHI1eA%3D%3D">IFTTT</a>事件的工具, 可以用它触发任何你能在 IFTTT 做的事情</p>
</li>
<li><p><a href="http://t.umblr.com/redirect?z=https%3A%2F%2Fgithub.com%2Fbcoe%2Fcitgm-harness%2Fpulls&amp;t=Mzk1MDA1MDUxNGE3NDAyMTljNzYxYTgyMDkxNWQ0Y2RhZTA4YmZhZixycTRWMHI1eA%3D%3D">citgm-harness</a>: <a href="http://t.umblr.com/redirect?z=https%3A%2F%2Fgithub.com%2Fnodejs%2Fcitgm&amp;t=ZTJkM2YzMzZmYzk5MWI3N2YyZTA0ZDRmZGE2N2ZmY2QyYmViMjJkMixycTRWMHI1eA%3D%3D">Canary in the Gold Mine suite</a> 一个 Nodejs 运用钩子来驱动包测试的工具，详细的包信息触发不同项目持续的集成测试，是一个测试是否破坏由顶自下依赖条件的方法</p>
</li>
</ul>
<h2 id="What-do-you-think"><a href="#What-do-you-think" class="headerlink" title="What do you think?"></a>What do you think?</h2><p>我们公布的是钩子的 Beta 版本，从哪里获得它就行。我们如何看待它？你们还有其他想要的监听的事件？100 个钩子的提供太多还是太少？</p>
<p>我们对你的看法真的非常感兴趣，如果你构建了一些有用的或者用处不大的钩子工具，不要害羞与我们<a href="http://t.umblr.com/redirect?z=http%3A%2F%2Finfo%40npmjs.com&amp;t=MGIzMWQ2MGMxZGVhODlkYTFkYmExNGFmZmYyNDQzNTBjZjg3YzQzZSxycTRWMHI1eA%3D%3D">交流</a>或者在<a href="https://twitter.com/npmjs">推特</a>上面@我们。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;本文由我翻译在&lt;a href=&quot;http://www.zcfy.cc/claim&quot;&gt;众成&lt;/a&gt;翻译平台，&lt;a href=&quot;http://www.zcfy.cc/article/introducing-hooks-get-notifications-of-n
    
    </summary>
    
      <category term="翻译" scheme="http://shudery.cn/categories/%E7%BF%BB%E8%AF%91/"/>
    
    
      <category term="Node.js" scheme="http://shudery.cn/tags/Node-js/"/>
    
  </entry>
  
  <entry>
    <title>程序员的苦与乐</title>
    <link href="http://shudery.cn/2016/10/19/%E9%9A%8F%E5%86%99/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%8B%A6%E4%B8%8E%E4%B9%90/"/>
    <id>http://shudery.cn/2016/10/19/随写/程序员的苦与乐/</id>
    <published>2016-10-18T16:00:00.000Z</published>
    <updated>2019-02-12T02:50:41.519Z</updated>
    
    <content type="html"><![CDATA[<p>前段时间准备秋招，思考着如何回答一些主观题，比如为什么做前端，平时如何持续学习，未来职业的规划等。<br>要不是为了准备面试，平时根本没有好好想过这些问题，找工作面试这一过程还真是蛮锻炼人的。<br>最近刚好读了软件著作《人月神话》，深受鼓舞，尝试着结合里面关于程序员职业的思考和自己学习编程的经历，去回答类似为什么当一个程序员这样的问题。<br>下文是我摘录自 Dr.Brooks 著名的软件管理书籍《人月神话》中的文章以及自己的一些想法。</p>
<hr>
<h3 id="职业的乐趣"><a href="#职业的乐趣" class="headerlink" title="职业的乐趣"></a>职业的乐趣</h3><p>编程为什么有趣，作为回报，它的从业者期望得到什么样的快乐？</p>
<p>首先，这种快乐是一种创建实物的纯粹快乐。如同小孩在玩泥巴时感到快乐一样，成年人喜欢创建事物，特别是自己进行设计，我想这种快乐是上帝创建世界的折射，一种呈现在每片独特的，崭新的树叶和雪花上的喜悦。</p>
<p>其次，这种快乐来自于开发对他人有用的东西。内心深处，我们期望我们的劳动成果能够被他人使用，并能对他们有所帮助。从这一角度而言，这同小孩用黏土为爸爸的办公室捏制铅笔盒没有任何本质的区别。</p>
<p>第三，快乐来自于整个过程体现出的一种强大的魅力，将互相齿合的零部件组装在一起，看到它们以精妙的方式运行着，并收到了预期到效果。比起弹球游戏机或自动点唱机所具有的迷人魅力，程序化计算机毫不逊色。</p>
<p>第四，这种快乐是持续学习的快乐，它来自于这项工作的非重复特性。人们所面临的问题总有这样那样的不同，因而解决问题的人可以从中学习新的事物，有时是实践上的，有时是理论上的，或者兼而有之。</p>
<p>最后，这种快乐还来自于在基于驾驭的介质上工作。程序员，就像诗人一样，几乎仅仅在单纯的思考中工作。程序员凭空地运用自己的想象，来建造自己的城堡。很少有创造介质如此灵活，如此易于精练和重建，如此容易实现概念上的设想，不过我们也将看到，容易驾驭的特性也有它自己的问题。</p>
<p>然而程序毕竟和诗歌不同，它是实实在在的东西：它可以移动和运行，能独立产生可见的输出，它能打印结果，绘制图形，发出声音，移动支架。神话和传说中的魔术在我们的时代已经变成了现实。在键盘上输入正确的咒语，屏幕会互动，变幻，显示出前所未有的也不可能存在的事物。</p>
<p>编程的快乐在于它不仅满足了我们内心深处进行创造的渴望，而且还唤醒了每个人内心的情感。</p>
<hr>
<h3 id="职业的苦恼"><a href="#职业的苦恼" class="headerlink" title="职业的苦恼"></a>职业的苦恼</h3><p>然而这个过程并不全是快乐的。我们只有事先了解一些编程固有的苦恼，这样，当它们真的出现时，才能更加坦然地面对。</p>
<p>首先，苦恼来自追求完美。因为计算机是以这样的方式来变戏法的：如果咒语中的一个字符，一个停顿，没有与正确的形式完全一致，魔术就不会出现，现实中，很少有人类活动会要求如此完美，所以人类对它本来就是不习惯的，实际上，我认为，学习编程最困难的部分，是将做事的方式向追求完美的方向调整。</p>
<p>其次，苦恼来自由他人设定目标，供给资源和提供信息。编程人员很少能控制工作环境和工作目标，用管理的术语来说，个人权威和他所承担的责任是不匹配的，不过，似乎在所有的领域中，对要完成的工作，很少能提供与责任相一致的正式权威。而实际情况中，实际相对于形式的权威来自于每次任务的完成。</p>
<p>对系统编程人员而言，对其他人的依赖是一件非常痛苦的事情。依靠其他人的程序，而这些程序往往设计得并不合理，实现拙劣，发布不完整，没有源代码和测试用例，或者文档记录糟糕，所以系统编程人员不得不花费时间去研究和修改，而它们在理想情况下本应该可以是完整的，可靠的。</p>
<p>下一个苦恼，概念性设计是有趣的，但寻找琐碎的 Bug 却是一项重复性的活动。伴随着创造性活动的，往往是枯燥沉闷的时间和艰苦的劳动。程序编制工作也不例外。</p>
<p>另外，人们发现调试和差错往往是线性收敛的，或者更糟糕的是，具有二次方的复杂度。结果，测试一拖再拖，寻找最后一个错误比第一个错误将花费更多的时间。</p>
<p>最后一个苦恼，有时也是一种无奈，当投入了大量辛苦的劳动，产品在即将完成或者终于完成的时候，却已显得陈旧过时。可能是同事和竞争对手已在追逐新的，更好的构思，也许替代方案不仅仅是在构思，而且已经在安排了。</p>
<p>现实情况比上面说的通常好一点。当产品开发完成时，更优秀的新产品通常还不能投入使用，而仅仅是为大家所谈论而已，另外，它同样需要数月的开发时间。事实上，只有实际需要时，才会用到最新的设想，因为所实现的系统已经能满足要求，并体现了回报。</p>
<p>诚然，产品开发所基于的技术在不断的进步。一旦设计被冻结，在概念上就已经开始陈旧了。不过，实际产品需要一步一步按阶段实现。实现落后与否的判断应根据其他已有的系统，而不是未实现的概念，因此，我们所面临的挑战和任务是在实际的进度和有有效的资源范围内的，寻找解决实际问题的切实可行方案。</p>
<p>这就是编程，一个许多人痛苦挣扎的焦油坑以及一种乐趣和苦恼共存的创造性活动。对许多人比如我而言，其中的快乐远大苦恼。其实作者文中讲到的苦恼，大多我还没有实际遇到过，因为我还没有足够的经历涉及到大型的团队项目，而这些苦恼无一例外在团队和项目变得庞大的时候也将随之放大，值得一提的是，在作者写这本著作的几十年前，估计不知道当今互联网发展如此快速吧，不然我猜他一定会在职业的苦恼加上一条惨无人道的加班时间吧。</p>
<p>总结来说，于我而言，编程赋予我创造工具，提供服务的能力，给我体现自身价值和满足成就感的机会，现在它即将成为我立足社会，赚钱混饭的技能，就这三点已经可以充分支撑我在程序员这条道路不断前行了。至于文中说的持续学习的快乐，作为一个团队项目不可或缺的一个部件之类的，随着我持续专注的学习，我想以后我一定能更切实的体会到那种愉悦吧。至于加班的事情，作为一个华为战士，我就不说什么了，已经准备好了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前段时间准备秋招，思考着如何回答一些主观题，比如为什么做前端，平时如何持续学习，未来职业的规划等。&lt;br&gt;要不是为了准备面试，平时根本没有好好想过这些问题，找工作面试这一过程还真是蛮锻炼人的。&lt;br&gt;最近刚好读了软件著作《人月神话》，深受鼓舞，尝试着结合里面关于程序员职业的
    
    </summary>
    
      <category term="随写" scheme="http://shudery.cn/categories/%E9%9A%8F%E5%86%99/"/>
    
    
      <category term="编程" scheme="http://shudery.cn/tags/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
</feed>
