<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Daguo&#39;s blog</title>
  <subtitle>Hello guy, welcome!</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://shudery.cn/"/>
  <updated>2017-09-09T10:27:58.000Z</updated>
  <id>http://shudery.cn/</id>
  
  <author>
    <name>Daguo</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>服务架构的基础知识整理</title>
    <link href="http://shudery.cn/2017/09/08/%E5%AD%A6%E4%B9%A0%E6%84%9F%E6%82%9F/%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/"/>
    <id>http://shudery.cn/2017/09/08/学习感悟/服务架构的基础知识整理/</id>
    <published>2017-09-08T15:32:17.000Z</published>
    <updated>2017-09-09T10:27:58.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近和友人聊天的时候，说到现在在做的一些业务项目，在跟上级做汇报的时候，不管怎么说最后一定要在技术架构方面扯上云化，服务化，数字化之类的名词（摊手，往高端点说是必须要匹配公司的总体战略目标。也不管你的项目是否适合这些模式的架构方案，都要在胶片上放上这几个High-Level的词汇，不然这就是一份不能让领导满意的汇报材料，要打回去重写（滑稽。</p>
<p>言归正传，那么当前的企业架构大趋势下，云化，服务化是啥，还有其他的平台化，容器化，虚拟化，微服务，SOA架构都是些什么鬼？它们和大数据，云计算，分布式之间又有何关联，为什么会成为新的架构事实标准呢？汇报的时候万一领导随便丢几个问题，你能够理清它们之间的关系吗？作为刚刚接触架构的新人，为了更好的向领导说(hu)明(you)，我决定好好学习一番，最后整理了一下，感觉已经可以开始我的表演了。下面我会从分布式计算说起，理清这些词汇及它们间的关系。<br><a id="more"></a></p>
<p>很长一段时间我们都是在本地计算机上跑程序代码的，但是当服务达到一定的计算规模之后，计算机的本地资源已经不能满足我们对性能的要求了。后来我们发现可以利用互联网上的其他计算机闲置的资源来分担本地服务的压力，这就是 <strong>分布式计算</strong>。</p>
<p>这些闲置的计算机资源怎么来的呢？如果直接购买，那么当企业不需要进行大规模计算的时候，就会造成资源的浪费。因此就出现了一些大公司购置了大量的计算机，形成一个计算资源池。它即可以供自家公司业务繁忙时期使用，也可以在不需要用的时候出租给其他公司或者个人，这种资源池有个好听的名字叫云，云提供的计算能力就是 <strong>云计算</strong>，可以说云计算是一种商业化的分布式计算。简单来说，如果你有一些闲置的计算资源，简单的树莓机也可以，就可以做为一个小小的集群发布到网络，然后你就可以收点小费，提供服务端口给其他人使用，这时你就拥有了一朵小小的云，一个可以进行云计算或者分布式计算的基础设施。</p>
<p>通俗来说，通过云资源提供的服务就是 <strong>云服务</strong>，云服务有多种模式，拥有大量云资源的公司往往不止提供云计算的服务，还会提供存储空间，也就是 <strong>云存储</strong>，类似有道云笔记的功能。也可以直接将计算机设施提供给客户后就不管不问了，客户相当于包了台计算机，这种模式就是基础设施服务（IAAS）。目前最流行的是在原先的设施基础层上，拥有云资源的公司会将底层的计算机集群统一分配调度，封装成运营的平台界面和可供开发的SDK，做成了一套平台服务（PAAS），也就是 <strong>云平台</strong>。</p>
<p>云平台给客户提供运营的功能，按需计费，租户可以随时扩容和缩减资源，同时大公司还会帮你升级，维护服务器，客户只需要专心运营，可以大大节约成本。大公司为了构建云平台，需要规划底层基础设施，开发抽象出方便用户使用功能，在平台化的过程中，大公司把一些底层的脏活累活都给做了，小公司直接利用平台的提供的服务就可以方便的体验到底层设施带来的好处。这就是现在在大公司大行其道的商业模式 <strong>服务化</strong>。业界关于服务化的实践非常多，最厉害的Amazon Web Services（AWS）已经无需多言，除此之外像Heroku，Google App Engine（GAE）也具有非常好的口碑，国内以BATH为主也都各有实践。</p>
<p>服务化的厉害在于用户根本不需要关注底层框架，不用具备相应的专业知识，但是又不至于像具体的软件服务（SAAS)那样缺少可以自由定制化的功能，无法平衡业务需求和企业利益。而对于个人而言也是好处多多，以前你想做一个网站站长，需要自己买服务器，安装服务器软件，编写网站程序，写监控模块，写日志系统和数据库。现在有了服务化平台，你只需要写你的网站程序，其他的可能就是根据你的心情，随意地在管理桌面添加或删除你想要的功能模块了。</p>
<p>提供服务化功能的云平台，就是 <strong>云服务平台</strong>，简单区分一下，AWS就是提供了服务化功能的云平台，但是像搜狐快站这种提供自定义网站建设功能服务的平台，就只是普通的服务化平台（PAAS）</p>
<p>随着互联网时代技术的高速发展，大公司开心地利用着自己闲置的计算机资源和思维超前的平台化模式赚着小钱的同时，也在思考着怎么赚大钱。资本的力量让小公司瑟瑟发抖。</p>
<p>第一个方式就是先想办法节约自身成本，买那么多台计算机太浪费钱了，如何才能更加合理的使用资源，提高利用率呢。企业通过将基础设施的 <strong>虚拟化</strong>，在云平台的资源池中，基础设施不一定是真正的物理资源（计算机），往往是抽象后的虚拟资源，让一台计算机变成几十台甚至上百台相互隔离的。虚拟化的好处非常多：可以节省空间，降低能耗，提高计算资源的利用率，稳定性更好，灵活迁移等等。</p>
<p>后来 <strong>容器化</strong> 继承了虚拟化的诸多特点，也是一种可选的方案，不过容器化的隔离效果没有虚拟化好，容器的优点是更加轻量，部署更快，符合DevOps的理念，Docker技术也已经非常成熟。配合虚拟机和容器可以有多种虚拟资源的方案。写到这里我突然想起，十年前有一家国产云提供商，那时候云服务还未普及，基础设施服务才刚刚兴起，可以说供应商这时已经有云的意识是非常超前的了。但是随后这家提供商大力的建设虚拟化云机以节约成本，扩大云资源池，而在服务化的道路上停滞不前，之后这家供应商的云平台一直没有很好的发展起来。十年后看无疑服务化才是王道之路，供应商已然醒悟，立志做五年后的五大云之一。这个走了弯路的供应商一直是做管道（通讯设施）的，最近几年终端（手机）也发展得不错，未来能实现”云管端”的战略布局吗？</p>
<p>另外，还要思考自身的平台技术架构的优化问题，传统的企业应用往往采用面向 <strong>服务架构设计（SOA）和企业服务总线（ESB）</strong>的模式，这是一种单一的应用架构，是一种处理小规模应用程序的有效架构设计。但是随着服务平台提供越来越多的功能，程序需要调用越来越多的服务接口，各个服务紧耦合成一团，十分不利于应用的维护，部署。每次修改应用的一个小模块就需要重新部署整个应用，除此之外整个应用使用相同的技术框架，限制了应用的迭代更新和活力。</p>
<p><strong>微服务（Microservices）</strong>应运而生，微服务的设计架构强调模块化和服务化，原有的单一应用按一定的粒度大小拆分成多个服务模块，实现各模块之间的解耦，各模块可以各自用不同的技术设计，开发，调试，部署，不会互相影响，服务之间通过轻量级的通信方式联系（通常是用基于HTTP的RESTful API）。微服务摈弃了传统SOA架构中的繁重的ESB，可以说是新时期的SOA继承思想。相比较传统的单一应用架构，除了在小型应用中可以简化开发过程，我想你不到任何你不运用微服务理念的原因。如果你想知道更多微服务的优势，可以看看<a href="https://mp.weixin.qq.com/s?__biz=MjM5MDE0Mjc4MA==&amp;mid=2650997457&amp;idx=1&amp;sn=c9024d2b47d88f15266d6d15544653ac&amp;chksm=bdbefa828ac973940ecaef2b74efed5f645b6e023756741b4a45f718b3373d565daef1b4d492&amp;scene=21#wechat_redirect">这边文章</a>。</p>
<p>最后要想赚大钱，还需要想办法挖掘服务化更大的潜力。在移动互联网时代，流量为王，用户和流量的重要性已经无需赘言。这些流量除了给各个公司带来广告收益外，流量也将用户海量的数据带到了云端，数据对于一家小公司而言可能就是做做自家产品的用户画像，找到切合用户的需求或者适合的合作方。但是这些数据都汇集到云端就不一样了，那可能就是整个行业的财富，庞大的数据流量就是服务化可挖掘的金矿。依托着自身的平台运算资源来分析处理 <strong>大数据</strong>，可以给企业带来巨大的利益。悔创阿里的杰克马说过：<strong>大数据将变成人类未来的巨大能源，做好大数据和云计算可以预测未来。</strong> </p>
<p>大数据的重要性不言而喻，而且大数据往往需要依托大量的基础设施，简直就是给云服务提供商的巨大商机，其他人想玩都不一定玩得动。顺带一提，机器学习和人工智能在训练时，除了需要设计模型算法，关键是还需要大量的训练素材，大数据就能够为其提供巨大量级的素材。看来大数据不只能预测未来，统治未来也是可以的，毕竟人工智能统治未来没毛病（逃。</p>
<p>种种迹象都表明服务化，微服务是企业架构中要考虑的核心内容，要依托产品和业务的需求特性，用长远的眼光看待产品和架构设计。主管，我讲完了，您看我的这份皮皮涕还行吗。</p>
<p>其实企业架构设计非常有意思，它往往就是世界上最伟大的几个公司的架构提炼出来的产物，而这个产物又是那些公司上百上千工程师设计和实践的结晶。现今服务化的理念已深入人心，互联网的浪潮经久不退，新一轮的物联网浪潮和数字化世界还未来到，以后的企业技术架构会如何发展，以配合时代的潮流，还需持续学习和观察。</p>
]]></content>
    
    <summary type="html">
    
      cloud service
    
    </summary>
    
      <category term="学习感悟" scheme="http://shudery.cn/categories/%E5%AD%A6%E4%B9%A0%E6%84%9F%E6%82%9F/"/>
    
    
      <category term="记录" scheme="http://shudery.cn/tags/%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>MacOS使用半年感受(码农向</title>
    <link href="http://shudery.cn/2017/04/04/%E9%9A%8F%E7%AC%94/MacOS%E4%BD%BF%E7%94%A8%E5%8D%8A%E5%B9%B4%E6%84%9F%E5%8F%97(%E7%A0%81%E5%86%9C%E5%90%91/"/>
    <id>http://shudery.cn/2017/04/04/随笔/MacOS使用半年感受(码农向/</id>
    <published>2017-04-04T09:53:38.000Z</published>
    <updated>2017-04-17T00:42:20.000Z</updated>
    
    <content type="html"><![CDATA[<p>2016年8月底的时候入手了macbook pro2015版，其实早在3月入阿里实习的时候就被安利了mac于办公和编码的各种优势，正好当时被老旧的ThinkPad卡得生活不能自理，不过由于可以使用公司配的电脑以及想等2016新版的pro，所以一直忍住没买，直到8月我要回校时，新版一直拖延发布，而且听说用了蝶式键盘，我用过macbook12寸的蝶式键盘，简直忍不了，所以就直接买了，到现在使用了大概快半年了，每天都是重度使用，觉得可以写点感受和安利一些好用的软件。</p>
<a id="more"></a>
<p>总体来说OSX系统上手并不难，难点主要是我们很多人都已经习惯了windows系统的操作方式了，所以使用一个新系统需要一定的时间适应，而且需要建立一个操作映射，原先在windows可以实现的功能在mac上要如何实现？比如说windows的ctrl键的很多使用场景在mac下都是用command代替。</p>
<p>安利一波mac的优秀软件，可以提升mac的使用体验和工作效率。</p>
<h4 id="oh-my-zsh"><a href="#oh-my-zsh" class="headerlink" title="oh-my-zsh"></a>oh-my-zsh</h4><p>mac系统超级好用的命令行工具，相比windows的命令行是一个极大的优势，各种快捷操作，配置自己喜欢的主题，配色，结合自带的插件就可以实现很多功能。</p>
<h4 id="Moom"><a href="#Moom" class="headerlink" title="Moom"></a>Moom</h4><p>窗口尺寸调整工具，可以配置好快捷点对应的尺寸及窗口显示位置，一键改变窗口的位置和大小，最近在写论文需要多个窗口的时候使用起来那叫一个爽。</p>
<h4 id="Dash"><a href="#Dash" class="headerlink" title="Dash"></a>Dash</h4><p>文档查询工具，离线下载文档，支持github和stack overflow搜索，遇到API问题可以直接查找，不用再在网上查了。</p>
<h4 id="Reeder"><a href="#Reeder" class="headerlink" title="Reeder"></a>Reeder</h4><p>mac优秀的RSS阅读器，界面简洁优雅，使用触摸板体验更好。</p>
<h4 id="Spark"><a href="#Spark" class="headerlink" title="Spark"></a>Spark</h4><p>mac的邮箱管理工具，颜值非常高。</p>
<h4 id="Paste"><a href="#Paste" class="headerlink" title="Paste"></a>Paste</h4><p>复制剪切板保存工具，可以无上限保存复制历史，用了它后在很多场景可以不用来回复制粘贴，可以一口气先复制多次，同样界面颜值非常高，操作方便。</p>
<h4 id="Timing-gt-Rescue-Time"><a href="#Timing-gt-Rescue-Time" class="headerlink" title="Timing =&gt; Rescue Time"></a>Timing =&gt; Rescue Time</h4><p>记录mac软件的使用时间，打开后不管它，一周后它会有本周使用报告，可以看看自己这一周都干了什么。<br>后来我发现了一款更加专业的时间记录工具，可以生成各种数据图，管理分类。</p>
<h4 id="SmoothScroll"><a href="#SmoothScroll" class="headerlink" title="SmoothScroll"></a>SmoothScroll</h4><p>mac的触摸板操作非常流畅，然而大部分鼠标操作十分蛋疼，这是一款鼠标操作的改善软件，有很多的功能，但是仅解决mac下鼠标慢启动的这点就让我非常喜欢，开了这个就和windows下用鼠标没有区别了。</p>
<h4 id="MplayerX"><a href="#MplayerX" class="headerlink" title="MplayerX"></a>MplayerX</h4><p>mac下很好的视频播放器，相比原生自带的多了很多细节的优点，比方快捷键控制播速，暂停不会重置播速，快进快捷键等。</p>
<p>使用mac时间长了之后，也渐渐可以感受到它不够完美的地方（虽然我早就知道，不过由于mac带给我的体验的提升，我一直选择忽视它们</p>
<ul>
<li>软件兼容性问题， 比方说链接安卓手机传输多张图片时，试过很多软件方法都很容易就卡死。</li>
<li>电脑发热问题，基本开着chrome，多开几个Tag，视频播放，就开始发热，玩大游戏更别想了。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      MacOS使用半年感受(码农向
    
    </summary>
    
      <category term="随笔" scheme="http://shudery.cn/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="随笔" scheme="http://shudery.cn/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>豆瓣电影到对应资源的传送门插件</title>
    <link href="http://shudery.cn/2017/02/22/%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/%E8%B1%86%E7%93%A3%E7%94%B5%E5%BD%B1%E5%88%B0%E5%AF%B9%E5%BA%94%E8%B5%84%E6%BA%90%E7%9A%84%E4%BC%A0%E9%80%81%E9%97%A8%E6%8F%92%E4%BB%B6/"/>
    <id>http://shudery.cn/2017/02/22/方法总结/豆瓣电影到对应资源的传送门插件/</id>
    <published>2017-02-22T04:00:33.000Z</published>
    <updated>2017-02-27T03:35:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>这是一个运行在chrome浏览器上的插件。前几天看了<a href="http://zhangwenli.com/blog/2014/09/01/readfree-chrome-extension/">@羡澈</a>大神写的豆瓣读书跳转到Readme上下载电子书的地址，所以闲着没事就写了一个电影的跳转。</p>
<a id="more"></a>
<h3 id="项目地址"><a href="#项目地址" class="headerlink" title="项目地址"></a>项目地址</h3><p><a href="https://github.com/shudery/douban-movies-plugin/">https://github.com/shudery/douban-movies-plugin/</a></p>
<h3 id="实现功能"><a href="#实现功能" class="headerlink" title="实现功能"></a>实现功能</h3><p>在豆瓣电影介绍页面自动添加一个下载按钮，点击可以直接传送到该电影的可下载资源的地址，当然了，前提是要找得到资源才行。我写了一个爬虫事先爬取了电影下载网站中的现有资源，离线为一个哈希表供插件搜索。</p>
<p><img src="/pic/douban.jpeg" alt=""></p>
<h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><ul>
<li>能够科学上网的同学到chrome应用商店下载即可：<a href="https://chrome.google.com/webstore/detail/douban-movies-plugin/ecgaddjpeacadegjcopipeoncpaphnpl?hl=zh-CN">douban-movies-plugin</a></li>
<li>不能的直接本地下载Chrome插件的cxr文件：<a href="https://github.com/shudery/douban-movies-plugin/raw/master/plugin.crx">plugin.cxr</a></li>
<li>然后打开Chrome浏览器，点击菜单-&gt;工具-&gt;扩展程序</li>
<li>将已下载的crx文件拖入Chrome窗口</li>
<li>打开一个豆瓣电影页面（如：<a href="https://movie.douban.com/subject/25934014/">https://movie.douban.com/subject/25934014/</a>），如果电影标题右侧没有出现下载按钮，则表示该资源暂时没找到。</li>
</ul>
<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><ul>
<li>使用这个插件目前只支持chrome浏览器。</li>
<li>目前只有豆瓣电影的详情页有添加按钮。</li>
<li>暂时只爬取了80s电影网的所有视频资源，也就是说如果80s上没有资源，那么按钮就不会出现了，不过这个网站已经相当给力，基本想看啥有啥，新上映的电影一般一个月内会补上。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      一个豆瓣电影到对应资源的传送门插件
    
    </summary>
    
      <category term="方法总结" scheme="http://shudery.cn/categories/%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="记录" scheme="http://shudery.cn/tags/%E8%AE%B0%E5%BD%95/"/>
    
      <category term="工具" scheme="http://shudery.cn/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>成为程序员的这一年</title>
    <link href="http://shudery.cn/2016/12/06/%E9%9A%8F%E7%AC%94/%E6%88%90%E4%B8%BA%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%BF%99%E4%B8%80%E5%B9%B4/"/>
    <id>http://shudery.cn/2016/12/06/随笔/成为程序员的这一年/</id>
    <published>2016-12-05T16:00:00.000Z</published>
    <updated>2016-12-06T15:29:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>决定去华为工作之后，一直有朋友建议我写一篇文章分享一下我的自学和跨界历程。因为我大学是电子工程专业，而我现在做的，之前的实习职位以及现在的offer都是web开发，它们几乎没有任何关联。另外我开始自学web的时间也比较晚，从决定试一试到现在大概过去一年的时间，一年时间以来在自学编程的路上确实摔了不少坑，也有一些感悟。之前我也想写点东西，但是懒癌犯作迟迟没有动笔，想想都快年末了，还是整理一下，当作是一篇年末总结也好，纯粹是记录一下这段经历和感悟，如果言辞有不当之处请联系我修改。<br><a id="more"></a></p>
<p><strong>事先预警：</strong>由于本人理工男平时疏于写作，同时语文水平有限，很可能导致本文变成一篇非刻意性软文，其中夹杂着一些鸡汤，也许有毒，不能保证适合所有人。此外这篇总结也许会写着写着烂尾，请上车的朋友随时做好跳车的准备。</p>
<p><strong>正文的分割线，本文未经允许不得转载</strong></p>
<hr>
<p>我在今年三月底的时候做了一个决定，翘掉学校四门必修课，离开成都去阿里移动事业群工作。过去半年多了，回想当初做着个决定还挺不容易，这个我在大学里做的最离经叛道的一个决定，现在看来，应该也是最正确的。</p>
<h2 id="自学之路"><a href="#自学之路" class="headerlink" title="自学之路"></a>自学之路</h2><p>先说说我是怎么走上程序员这条路的。我是在去年年底的时候才开始认真思考未来职业这个问题的，当时我大三上学期就快要结束了。我们学校是在大三才开始学习专业必修课程，真正地接触了电子专业课程后，我花了好几个月的时间认清了我不能真正的喜欢上这些东西。我是一个一直都偏向于找工作，不想读研的人，这让我非常急躁，因为我清楚这样下去以我的本科能力根本就没法找到一份能令我和家人满意的工作。这也迫使我好好认真地审视了一下自己，最后我的决定是投身互联网，做一名程序员极客。</p>
<p>我在高考选专业的时候就已经在电子工程和计算机软件专业之间抉择过一次了，后来由于电子科学是我们学校的王牌专业，而且其实那会我对电子信息和软件这些学科都没有什么深刻的理解，觉得自己都算是有些兴趣，并且这两个专业据说也还蛮火的。<strong>所以说其实我在去年年底重新选择了软件是挺危险的，因为就像我在几年前高考选错了路一样，我现在只是又回到了原点，再做一次选择，谁也不知道过了多久，我是不是又会回到这里，选择别的什么路。</strong></p>
<p>但是无论如何，不能否认的是当年如果其他条件都相同，我是一定会在电子科学和计算机软件中选择后者的。我是个各方面条件平凡的人，没有什么特别的才能，喜欢的爱好通常也坚持不了多久。后来还摊上了一个非常耗费时间的爱好，就是玩游戏，然后浑浑噩噩，一直在划水混日子，转眼到了大三。期间要说有什么一直能燃起我内心兴趣的就是互联网和软件，这可能也和我玩过很多电脑游戏有关。记得高一的时候，我还和画画特别好的同桌说以后我要是去做游戏软件，就请他来给我做游戏人物的形象设计。我觉得我本来内心就是想做软件的，但是种种原因，一直以来没能听见自己内心的声音，后来经历了的很多事情都让我更坚定这个选择。</p>
<p>决定了互联网软件的大方向之后，还有很多细分的领域要作选择。<strong>其实当时我内心的想法就是我得快点把职业方向这个事给规划好定下来，然后就去往那方面走了，因为我觉得我真的起步太晚了，而且我是一个不对口的野生专业。</strong></p>
<p><img src="/pic/xuanzei.jpeg" alt="xuanzei"></p>
<p>这是我当时写在纸上的未来职业方向，可以看到我当时还没破釜沉舟，给自己留着退路，第一二个写的都还是和原本专业相关的职位，我做过一些硬件编程，所以觉得FPGA可能是一个方向，或者技术不行的话，运用一些本科学到的专业皮毛做个电子销售员之类的，当然这些是最坏的就业打算的。</p>
<p>我当时画了两个圈圈表示重点考虑，一个是做Java，我大一的时候就对Java很感兴趣，因为高中的时候安卓手机游戏特别火，而这些游戏基本都是Java做的，但是那会我菜到Java的开发环境都配不好，我觉得这里面有Windows系统配置繁琐的锅（逃。当时连一个HelloWorld程序都跑不出来，这给年轻的我深深的打击，果断就放弃了，那会我还庆幸自己还好没选计算机。但是越恨越爱，我还是把它作为一个主要的就业方向。</p>
<p>另一个方向正是web开发方面的，这是一个我非常感兴趣的方向，经过一番了解之后，我发现它比Java要好入门的多，行业前景在近几年非常好，应该还挺好赚钱的，出于这样单纯而现实的想法，我的就业方向就这样确定了，直到许久以后我才真正领略到这个行业的魅力。</p>
<p>方向定了之后，我渐渐舍弃了许多其他爱好，抽出时间，开始了勤奋地自学。有意思的是，被我逐渐舍弃的爱好包括吉他摄影之类的，而依然坚持的爱好则有诸如健身篮球，那是我下意识里的选择，果然我还是个理工男，文艺只是一个梦啊（捂脸。</p>
<p><strong>由于经常带着大学前两年浪费太多时间了的愧疚感，所以我的学习主动性在这个时间段非常高。而且庆幸的是web相对于其他软件，网上的学习资源太多了，代码很多都是开源的，我发现这是一个非常适合野生专业转行和自学的方向。</strong>还一度觉得计算机软件专业中的web开发者相对于那些自学的同学是没有多大优势的（逃。直到后来秋招找工作的时候，这个后面再说。那段时间基本都泡在图书馆看入门的经典书或者在寝室写demo，逐一地去搞懂每一个技术点，把慕课网和极客学院的课程基本都看完了，国外也有很多更优质的资源网站，但是对于初学者区别不大。这个时间我积累了很多优质的学习资源和技术博文，有刚入门前端的朋友如果需要可以联系我。</p>
<p><strong>那段时间每天晚上睡觉的时候都觉得今天又学到了有用的知识，这跟我在学电子专业的理论知识的那种体验是完全不一样的，软件学科的知识转化为实际的互联网产品和服务要比硬件快的多，它是自顶向下的，不需要你从最底层的枯燥的理论学起，这真的很适合我这种成就感驱动学习的人。</strong>在学了许多技术点之后，我开始给自己的知识体系做一些梳理，尝试写一些笔记总结，以此让自己的知识变得更系统。随后我加入了一些学校的IT组织，但是很快我发现这些学习型社团的效率太慢了，作为大三老人有点耗不起。然后又在网上参加一些前端和JS编程比赛，开始自己写一些网站，做一些实践项目，至今还清楚记得当我把第一个做好的网页给朋友看，那时激动的心情和满满的成就感（捂脸。</p>
<p><strong>前端领域有三板斧，HTML，CSS，JavaScript。而我的自学之路也是三板斧：兴趣，愧疚感，成就感。</strong></p>
<h2 id="开始找实习"><a href="#开始找实习" class="headerlink" title="开始找实习"></a>开始找实习</h2><hr>
<p>自学大概4个多月的时间，期间有一个月我参加了学校一个去新加坡创业交流的项目，还有回家过年休息了一段时间。放假完重新回到学校后，在学校BBS上面得知马上就要开始实习生内部推荐了，学习了一段时间也很想检验一下自己的技术和知识面，我觉得让大佬们面试就是很好的检验方法，就找了学校的学长开始投BAT的内推，推的岗位都是前端工程师。</p>
<p>反馈快得惊人，快到我对面试还毫无准备，没投几天，在3月中旬的时候我就收到了腾讯的面试电话，刚午睡醒的我接到电话真的是一脸懵逼，面试结果自然是呵呵了。<strong>除了应试技巧不熟悉，紧张过度之外，问我的很简单的技术问题我也没有答上来。这次面试狠狠地敲醒了我，我知道我一定得增加学习的强度了，同时也要好好准备一下应试技巧。</strong></p>
<p>十几天后我接到了另外一个来自BAT的面试电话，印象很深刻的是阿里的面试官都没让我自我介绍，上来直接问了大概20多个技术问题。由于这次有过充足的准备，而且问的问题对初学者比较友好，问了很多基础的知识点，没有太深入，大部分我都回答出来了，而且很幸运的是当时阿里广州正在急招一些Nodejs方面的实习生，我Node虽然是初学，但也正因如此知识点算都记得清楚。</p>
<p>我几个月的努力没有被辜负，后来我顺利地通过了面试，HR希望我尽快能过去，我本意是继续像上一个学期那样子这学期先自学，把那厌恶的专业课学分先拿了，然后找一份的暑假的实习，接着再去工作的。后来我觉得要是能够尽快去大厂里一边实践一边学习，同时认识许多志同道合的牛人，一定能更快地成长。做这个决定有很心酸的历程和压力，包括但不限于：当时我有四门必修专业课，一门过不了都不要想毕业，选修的学分也还没够，而我那会还没屌到觉得自己可以不要毕业证了，即使这份不对口专业的毕业证确实只是名面上的东西；还有辅导员老师极力劝阻，要知道的每一个电子科大的辅导员都有坚持劝你读研的属性（摊手。另外要离开校园去另一座城市工作，对陌生的环境我显然还没有准备好，内心很不安。。</p>
<p>在得到朋友的支持以及我一夜的纠结和思考之后，订了隔天前往广州贵得要死的飞机票。<strong>我离开学校当时内心只有一个想法，就是我还很菜很菜，现在有一个很好的机会我一定要去好好成长一番。</strong>后来经过努力和一番波折，那几门必修课我在补考和重修后也勉强拿到学分，老师也对我改变了看法，而当初的不安则变成了对一座城市和一个职业真正由心的热爱。</p>
<h2 id="实习，不断成长"><a href="#实习，不断成长" class="headerlink" title="实习，不断成长"></a>实习，不断成长</h2><hr>
<p>在阿里实习的这段时间，颠覆了我对行业，对程序员的理解，让我打心底坚定了以后的职业发展方向。</p>
<p>对于我这样的初学者来说，去公司实习是一次赌博，赌的是你的时间，考验着你的学习和承受能力。我在阿里的第一个月经历了人生中从未有过的恐慌和压力。我所在部门做的业务刚刚起步，非常繁忙，这个过程有非常多的坑，没有工作经验和项目经历，这些坑你多半是逃不掉的，只能一个一个去踩，不断遇到困难，不断去解决。这段时间我的TodoLists都是满的，我可以感受到别人和我实力的差距，很多东西我必须比别人花更多的时间才能搞明白。</p>
<p>记得我工作的第一天，主管跟我和另一个一同入职的中大研究生讲我们整个业务流程，一通讲下来，我根本就听不懂，太多的名词我都是第一次听说，以至于最后主管问我有没有什么问题要问，我都是一脸懵逼。这种内心到处都是问题但是问不出来问题的心情真是无奈得很。而那个研究生和我根本不是一个级别的，最骚的是主管讲什么技术点他都要来几句很牛逼的看法，让当时很沉默的我好尴尬，深受刺激，压力山大。后来这个实习第一天就和主管谈笑风生的大神成了我的好朋友，帮助我成长了不少，我就不黑他了（逃。</p>
<p>实习一开始的时候确实非常苦逼，每天都在给公司写bug（可怕，现在想想还是会心疼自己几秒。后来熟悉业务和环境，技术成长了之后，才渐渐能和大佬们一样，到公司后先端杯coffee or tea再说（逃。实习还发生了许多有意思的事情，也认识了很多有实力有想法的人，这些和工作细节我在自己的实习周记里写了很多，这里就不展开了，写一点感悟吧。</p>
<p>实际工作跟之前自学是完全不一样的，太多的突发事项会打断你原有的计划，要调整自己不断地去适应，还有一点巨大的变化就是对效率的要求。<strong>工作环境给你的压力会迫使你不断提升自己效率，不论是出于早点下班，腾出时间去从事业余的爱好，还是想成为马太效应中的马太，效率非常重要。</strong></p>
<p>实习的时候我见识了许多同事为了提高效率而使用的技巧或者软件了，小的方面比如操作技巧方面的放弃鼠标，熟用快捷键，用Vim，建TodoLists等等，大的方面如用工程化的思想组织代码，运用设计模式，做脚手架，工作流，构建代码库等等，还有一些好用的工具软件，阅读器，高效的学习周刊等等，这些是实际工作中的提高效率的方法。</p>
<p><strong>至于提高学习效率的方法，是去不断完善你学习东西的方法论，渐渐地这套学习体系在你的不断训练下会变得成熟而高效，所有遇到的难题都是可以抽象出相似点的，只要模型足够强大，就可以迅速匹配到解决方案，从而提升效率。工具终究是工具，而方法论才是支配工具的效率银弹。</strong>有点像机器深度学习模仿人脑神经元的算法，人工智能如果有一天可以接管人类，我想那就是因为AI有快速建模匹配的方法论，以及超高的学习效率吧。</p>
<p>我之所以对效率这么敏感不是没有原因的，首先我自己开始自学的时间比较迟，我本来就没有过多的时间，所以我只能通过提高效率来加快学习进度，而我本身是一个有挺多爱好，爱玩的同时还有间断性懒癌的人，因此总幻想通过有效率地工作来给自己的其他爱好腾出时间。然而后来我发现一个残酷的事实，大多数时候，高效率地学习之后会越着迷地接着学习，并不能腾出时间，即所谓沉迷学习不能自拔（可怕。就像以前玩炉石的时候的场景：这回用快攻流的牌，赶紧打完去打球喽，然后事实总是欢声笑语中再来一盘。</p>
<p>实习的好处都不用多说了，可以从我上面的描述体会到一些，我觉得最最主要的有三点：<strong>实用型技术知识的迅速增长，熟悉行业及业务流程，团队合作和自身价值体现的愉悦。</strong>除此之外还有可能收获，思维能力的提升，视野的开阔，一群志同道合的朋友或者几位爱聚餐爱争着请客的主管（逃。</p>
<p>还有钱方面的收获我也不怕落俗地说一说，毕竟钱也是我们大部分人学得勤的一个重要动力，我去实习的时间比较早，工资加上期间做了一些外包项目，离开学校这半年时间我大概净赚了2万块钱，在我买了一台Macbook pro，一部ipad mini4，还有把大学最后一年的学费交了之后，还剩两千块。</p>
<p>其实即使不是去阿里，许多公司的业务强度和收获的成长不见得比阿里低，不管去哪里实习，<strong>我觉得对于大部分搞技术学生来说都是一件非常值得的事情，你不用跟我一样冒着毕不了业的风险，只是把暑假寒假的时间拿出来，有时间尽早去工作，做你钟意的事情，一定可以让你有新的体会。</strong></p>
<h2 id="秋招找工作"><a href="#秋招找工作" class="headerlink" title="秋招找工作"></a>秋招找工作</h2><hr>
<p>秋招找工作的准备的过程十分艰苦，从七月中旬开始内部推荐到九月，这期间晚上我都是接近3点才睡觉，刷各种面试题，还要做项目，这里我做了一件很可怕，也很愚蠢的事情。我抖了个机灵，把很多之前做的项目还未实现的功能都写到简历上面了，因为我准备得太迟了，而且看到其他实习生简历的时候真的觉得自己的简历太不够看了。</p>
<p><strong>恰巧我当时对项目还有许多的改进想法，我就把还没有实现的功能也写到简历上面了，因为我知道我现在投的简历面试官基本都还不会去验证，我只要在真正面试之前把功能做出来就行了。然后自己制定了一个时间表，开始照着自己写的简历给自己的项目打补丁做功能，这就是菜鸟给简历补坑的历程啊（捂脸。</strong></p>
<p>而我平时早上7点多还要去上班，时间根本不够我整，所以我只能熬夜来完成这些东西，虽然也有不小的收获，但是这种折寿的做法就像阿凯的八门遁甲一样只能情急的时候搞一搞，况且阿凯完事了还有鸣人用六道之力给他续命。</p>
<p>后来种种原因，我没有继续留在阿里，其实我之前开始准备简历的时候就已经做好准备了，其中缘由比较复杂，有个人原因，也有团队因素，这里就不展开了。有趣的是我刚离开没多久，阿里就出了抢月饼事件，在程序员圈内引起了不小的争议，作为一个很喜欢捣鼓JavaScript的程序员，我对阿里HR所谓的企业价值观表示不解（摊手。</p>
<p>总之我辞去了工作之后就开始专心准备秋招的事情了，这个准备阶段让我自身差缺补漏了非常多之前学习前端过程中遗漏的知识点，重新看那些经典的书籍也带给了我很多不同的收获，着重安利《JavaScript高级程序设计》这本书，俗称红宝石，虽然名字叫高级，但其实是一本值得啃很多遍的基础书，应试的思维我推荐hax老师前端面试的知乎live，这个live是前不久才出的，虽然有点贵，但还是值得的。由于不用工作，这段时间的学习要比工作的时候系统得多，也快乐得多。因为得回学校补考，我在八月底回到了阔别已久的成都，然后选择了直接参加成都这边学校的校招，后来腾讯正式校招取消成都前端工程师的面试的时候我有后悔过这个决定，因为我其实可以直接在广州参加同学学校的校园招聘的，应该会有一个比较好的秋招应聘体验，当然这是后话了。</p>
<p>后来我陆续投了一些公司，以互联网公司为主，也有一些硬件公司巨头，基本都是广深的，主要还是比较想回大广东工作。包括内推的前后参加了大概有20次面试，收获了几份offer，这期间也碰了好几次壁，腾讯内推我就被刷了好几次，主要问题就是算法和基础的计算机软件知识不够硬，算法能力几乎可以忽略，这也暴露了我这个野专业的一些缺陷，前面虽然说web好入门，但它毕竟是软件的一个分支，别人考你比较底层的东西也无可厚非。所以秋招结束过后到最近这一段时间，我都一直在补计算机专业的基础知识，去一些OJ，比如leetcode上面练习算法。</p>
<p>面试就是一次学习和完善自身的过程，面试之前不断准备，面经要适当刷一点，了解一些面试的套路可以让自己的回答更加游刃有余，面试过后我会记录总结，把可以改进的点列举出来，每一次面试都要争取最好的表现。就像medium上的<a href="https://medium.freecodecamp.com/5-key-learnings-from-the-post-bootcamp-job-search-9a07468d2331">这篇面经</a>说的：<strong>You have to perform well, even when you’re not fully prepared. In order to succeed, you have to be your own advocate. —— 不管你有没有准备好，你都必须表现得很好。为了取胜，你必须展现出你最好的一面。</strong></p>
<p>找工作是个漫长的过程，整个秋招下来收获良多，有些是技术层面的，有些是应试技巧方面的，甚至和一些面试官成了朋友。我把找工作期间遇到的一些面试问题和总结的一些方法整理好，放在了gitbook上面：<a href="https://shudery.gitbooks.io/front-end-offer/content/">前端面试知识点整理</a>，此外我之前已经把秋招找工作以及遇到的趣事记录在另一篇文章，所以这里就不展开说了，如果还有其他的问题想和我交流都可以私信我。    </p>
<p><strong>最后选择去华为没有别的原因，就是厂比较大，给的钱也还可以，觉得华为可以在毕业的前几年给我提供一个比较好的环境来成长。</strong>当然后来了解一下，也渐渐知道华为确实是一家很有抱负很有实力的公司。话说我菊厂明年30周年要不要学一下某厂，每人发5万+红包呢（期待。不过网上黑华为的也是挺多的，好在现在BAT里的BA也时不时会加入了被黑的行列（逃，感觉华为在被黑的路上也不孤单了。</p>
<h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><hr>
<p>我当初决定放弃本专业，选择软件，自学编程的理由其实很简单，就是想找份自己可以接受的工作，同时必须得是自己的兴趣所在，我希望以后能活跃在一个喜欢的领域里，一辈子都受益于此。也许我做决定的时间比较晚，但我没有因为相对的起步晚而不去迈出第一步，所以才有了后面不断的成长和收获，如果不知道自己想成为怎样的人，那和西部世界的机器人有什么区别（逃。我还有很多不足，也知道这是个需要一直不断学习的职业，但是一想到编程可以做好多有意思的事情，就会一直努力的。</p>
<p>谢谢一直支持我，给我帮助的朋友，我会永远记得。<br>这就是我过去一年成为程序员的经历和感悟，没写过这么长的，感谢看完。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;决定去华为工作之后，一直有朋友建议我写一篇文章分享一下我的自学和跨界历程。因为我大学是电子工程专业，而我现在做的，之前的实习职位以及现在的offer都是web开发，它们几乎没有任何关联。另外我开始自学web的时间也比较晚，从决定试一试到现在大概过去一年的时间，一年时间以来在自学编程的路上确实摔了不少坑，也有一些感悟。之前我也想写点东西，但是懒癌犯作迟迟没有动笔，想想都快年末了，还是整理一下，当作是一篇年末总结也好，纯粹是记录一下这段经历和感悟，如果言辞有不当之处请联系我修改。&lt;br&gt;
    
    </summary>
    
      <category term="随笔" scheme="http://shudery.cn/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="随笔" scheme="http://shudery.cn/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>实现通用的网站服务构建系统</title>
    <link href="http://shudery.cn/2016/11/23/%E7%A8%8B%E5%BA%8F%E5%91%98/%E5%AE%9E%E7%8E%B0%E9%80%9A%E7%94%A8%E7%9A%84%E7%BD%91%E7%AB%99%E6%9C%8D%E5%8A%A1%E6%9E%84%E5%BB%BA%E7%B3%BB%E7%BB%9F/"/>
    <id>http://shudery.cn/2016/11/23/程序员/实现通用的网站服务构建系统/</id>
    <published>2016-11-23T13:59:48.000Z</published>
    <updated>2016-12-16T11:54:06.000Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文章主要记录如何快速创建一个简洁，健壮的web server，目标是实现网站服务的常用模块，尝试全栈思维开发，提供一套快速构建网站服务的全能脚手架，力求突破快速，低廉，优质只能兼得其二的工程瓶颈。<br>运用的技术栈：node + express + handlebars + mongDB + mocha<br><a id="more"></a></p>
<h3 id="创建服务和基础路由"><a href="#创建服务和基础路由" class="headerlink" title="创建服务和基础路由"></a>创建服务和基础路由</h3><p>如同客户端的事件响应，当客户端输入一个url之后，server要如何响应这个事件，在express中可以通过中间件搭建各种路由，在客户端请求地址触发相应路由，返回对应的文件，入口文件app.js如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">const app = require(&apos;express&apos;)();</div><div class="line">const port = process.env.port || 3000;</div><div class="line">app.listen(port, (err) =&gt; &#123;</div><div class="line">    err &amp;&amp; log(&apos;error form app.listen()&apos;)</div><div class="line">    log(`application start listen at $&#123;port&#125;`)</div><div class="line">&#125;);</div><div class="line">app.get(&apos;/&apos;, (req, res) =&gt; &#123;</div><div class="line">    res.type(&apos;text/plain&apos;)</div><div class="line">    res.send(&apos;welcome home!&apos;);</div><div class="line">&#125;);</div><div class="line">&lt;!-- //404路由 --&gt;</div><div class="line">app.use((req, res) =&gt; &#123;</div><div class="line">    res.status(404);</div><div class="line">    res.send(&apos;404 not found&apos;);</div><div class="line">&#125;);</div><div class="line">&lt;!-- //500路由,根据传入参数来区分404路由 --&gt;</div><div class="line">app.use((err, req, res, next) =&gt; &#123;</div><div class="line">    res.status(500);</div><div class="line">    res.send(&apos;500 server error&apos;);</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>最基本的三个路由对应了三种网页请求状态，’/‘匹配响应了主页的正常请求。</p>
<h3 id="配置模板引擎"><a href="#配置模板引擎" class="headerlink" title="配置模板引擎"></a>配置模板引擎</h3><p>创建默认模板目录views，再创建布局模板目录layouts，都是默认参数，目录名照用就行。<br>添加main.hbs到 <code>/views/layouts</code>中，hbs是handlebars的简写，记得给你使用的文本编辑器下载相应模板的插件，不然没有语法提示和补全很难过的，我用的sublime text，直接下载handlebars这个插件即可。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&lt;!DOCTYPE html&gt;</div><div class="line">&lt;html lang=&quot;en&quot;&gt;</div><div class="line">&lt;head&gt;</div><div class="line">	&lt;meta charset=&quot;UTF-8&quot;&gt;</div><div class="line">	&lt;title&gt;home&lt;/title&gt;</div><div class="line">	&lt;script src=&apos;/js/test.js&apos;&gt;&lt;/script&gt;</div><div class="line">&lt;/head&gt;</div><div class="line">&lt;body&gt;</div><div class="line">	&#123;&#123;&#123;body&#125;&#125;&#125;</div><div class="line">&lt;/body&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure>
<p>其中body会结合路由配置自动读取views下的相应模板来代替这一块内容。<br>在views下添加主页模板<code>home.hbs</code>，404页面模板<code>404.hbs</code>，服务器错误页面<code>500.hbs</code>，结合<code>main.hbs</code>形成一个对应页面的html文件。</p>
<p>在app.js中添加</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">const handlebars = require(&apos;express-handlebars&apos;);</div><div class="line">app.engine(&apos;.hbs&apos;, handlebars(&#123; defaultLayout: &apos;main.hbs&apos;,extname: &apos;.bhs&apos; &#125;));</div><div class="line">app.set(&apos;view engine&apos;, &apos;.hbs&apos;);</div></pre></td></tr></table></figure>
<p>其中defaultLayout设置了模板的进入地址，默认为main，即上面创建的main.hbs，然后设置文件扩展名缩写为.hbs，然后就可以结合模板来为路由配置返回的文件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">app.get(&apos;/&apos;, (req, res) =&gt; &#123;</div><div class="line">    res.render(&apos;home&apos;, &#123; nowTime: new Date() &#125;);</div><div class="line">&#125;)</div><div class="line">app.use((req, res) =&gt; &#123;</div><div class="line">    res.status(404);</div><div class="line">    res.render(&apos;404&apos;);</div><div class="line">&#125;);</div><div class="line">app.use((err, req, res, next) =&gt; &#123;</div><div class="line">    res.status(500);</div><div class="line">    res.render(&apos;500&apos;);</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>使用了render方法来调用模板，传入第一个参数即对应创建的模板文件名，第二个参数为传递对模板的配置对象，模板中通过可以获取到这个变量，视图引擎默认返回的文件就是<code>text/plain</code>，不用res.type设置，除了200状态码之外，其他状态码依然需要设置。</p>
<h3 id="设置静态文件路径"><a href="#设置静态文件路径" class="headerlink" title="设置静态文件路径"></a>设置静态文件路径</h3><p>项目目录下创建一个文件夹存放静态文件，这里用public，添加如下代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">app.use(express.static(__dirname + &apos;/public&apos;));</div></pre></td></tr></table></figure></p>
<p>添加这段代码之后，在模板中引用的静态文件就是以/public为根目录了，比如<code>&lt;img src=&quot;/img/icon.jpg&quot;&gt;</code>对应查找的路径就是<code>/public/img/icon.jpg</code></p>
<h3 id="添加测试框架"><a href="#添加测试框架" class="headerlink" title="添加测试框架"></a>添加测试框架</h3><p>测试系统对于一个健壮的web项目的支撑作用十分重要，提前写好测试可以大幅降低后期维护的成本。本项目使用Mocha框架和chai断言库进行测试，将这两个文件统一放到<code>public/vendor</code>中，将测试用例统一放在<code>public/test</code>目录下，在test目录中添加一个全部页面都运行的测试global.js<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">suite(&apos;Global Tests&apos;,()=&gt;&#123;</div><div class="line">    test(&apos;page have a valid title:&apos;+document.title,()=&gt;&#123;</div><div class="line">        assert(document.title &amp;&amp; document.title.toUpperCase() !== &apos;TODO&apos;)</div><div class="line">    &#125;)</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>添加一个about页面单独运行的测试about.js<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">suite(&apos;About Page Test&apos;,()=&gt;&#123;</div><div class="line">    test(&apos;contain a tag&apos;,()=&gt;&#123;</div><div class="line">        assert(document.getElementsByTagName(&apos;a&apos;).length)</div><div class="line">    &#125;)</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>在app.js文件中添加开启测试的方式，这里用查询参数<code>?test=1</code>来开启<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">app.use((req,res,next)=&gt;&#123;</div><div class="line">    &lt;!-- //res.locals可以传递给视图模板 --&gt;</div><div class="line">    res.locals.startTests = (app.get(&apos;env&apos;)!== &apos;production&apos; &amp;&amp; req.query.test === 1);</div><div class="line">    next();</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>将主要逻辑放在公用模板main.hbs中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">&lt;link rel=&apos;stylesheet&apos; href=&apos;/vendor/mocha.css&apos;&gt;</div><div class="line">&lt;script src=&apos;/vendor/mocha.js&apos;&gt;&lt;/script&gt;</div><div class="line">&lt;script src=&apos;/vendor/chai.js&apos;&gt;&lt;/script&gt;</div><div class="line">&#123;&#123;#if startTests&#125;&#125;</div><div class="line">    &lt;div id=&quot;mocha&quot;&gt;&lt;/div&gt;</div><div class="line">    &lt;script&gt;</div><div class="line">    console.log(&apos;startTests&apos;)</div><div class="line">    mocha.ui(&apos;tdd&apos;);</div><div class="line">    var assert = chai.assert;</div><div class="line">    &lt;/script&gt;</div><div class="line">    &lt;script src=&apos;/test/global.js&apos;&gt;&lt;/script&gt;</div><div class="line">    &#123;&#123;#if pageTestPath&#125;&#125;</div><div class="line">        &lt;script src=&apos;&#123;&#123;pageTestPath&#125;&#125;&apos;&gt;&lt;/script&gt;</div><div class="line">    &#123;&#123;/if&#125;&#125;</div><div class="line">    &lt;script&gt;mocha.run()&lt;/script&gt;</div><div class="line">&#123;&#123;/if&#125;&#125;</div></pre></td></tr></table></figure></p>
<p>启动服务，访问<code>localhost:3000/about?test=1</code>，查看测试结果<br><img src="/pic/3.jpg" alt=""></p>
<p>在test目录下继续添加逻辑功能的单元测试unit.js，区别于页面测试，逻辑测试使用describe/it/expect来描述，结构如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var mocha = require(&apos;mocha&apos;)</div><div class="line">var expect = require(&apos;chai&apos;).expect</div><div class="line">var log = require(&apos;../lib/daguo&apos;).log</div><div class="line">describe(&apos;Unit Tests&apos;,()=&gt;&#123;</div><div class="line">    it(&apos;log modules&apos;,()=&gt;&#123;</div><div class="line">        expect(typeof log(&apos;test&apos;) === &apos;string&apos;)</div><div class="line">    &#125;)</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p><strong>TIPS:</strong></p>
<ul>
<li>使用nodemon自动重启server服务，结合webpack，gulp等构建工具可以热加载刷新浏览器页面，进一步实现自动化</li>
<li>一些需要浏览器操作的测试可以通过zombie，phantomJS等框架来实现</li>
<li>在<a href="https://travis-ci.org">https://travis-ci.org</a>给项目添加自动集成测试，每一次提交代码会自动运行测试代码</li>
<li>express-handlebars这个模板在partials路径这里有问题，一直提示找不到对应部分的模板，换成express-hbs可解决，并且不用再配置hbs的简写后缀了</li>
</ul>
<h3 id="添加cookie"><a href="#添加cookie" class="headerlink" title="添加cookie"></a>添加cookie</h3><p>网站门户少不了需要添加用户配置，可以针对性地提供一些服务，而cookie是用户身份的凭证，为使用无状态HTTP协议的浏览器提供了识别用户的能力，接下来给网站添加登录模块的功能。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">//set cookie-parser</div><div class="line">app.use(require(&apos;cookie-parser&apos;)(credentials.cookieSecret));</div><div class="line">//postbody-parser</div><div class="line">app.use(require(&apos;body-parser&apos;).urlencoded(&#123; extended: false &#125;));</div><div class="line">app.get(&apos;/login&apos;, (req, res) =&gt; &#123;</div><div class="line">    if (req.cookies.daguoCookie === &apos;string123&apos;) &#123;</div><div class="line">        // res.render(&apos;user&apos;, &#123; cookie: req.cookies.daguoCookie &#125;)</div><div class="line">        res.redirect(303, &apos;/user&apos;)</div><div class="line">    &#125; else &#123;</div><div class="line">        res.render(&apos;login&apos;)</div><div class="line">    &#125;</div><div class="line">&#125;)</div><div class="line">app.post(&apos;/process&apos;, (req, res) =&gt; &#123;</div><div class="line">    if (req.xhr || req.accepts(&apos;json,html&apos;) === &apos;json&apos;) &#123;</div><div class="line">        log(req.xhr)</div><div class="line">        res.send(&apos;process receive a xhr or json accepts&apos;)</div><div class="line">    &#125;</div><div class="line">    if (req.body.user === &apos;user&apos; &amp;&amp; req.body.password === &apos;123&apos;) &#123;</div><div class="line">        res.cookie(&apos;daguoCookie&apos;, &apos;string123&apos;)</div><div class="line">        res.redirect(303, &apos;/user&apos;)</div><div class="line">            // res.render(&apos;user&apos;, &#123; user: req.body.user, password: req.body.password &#125;)</div><div class="line">    &#125; else &#123;</div><div class="line">        res.render(&apos;error&apos;, &#123; message: &apos;user name or password is error&apos; &#125;)</div><div class="line">    &#125;</div><div class="line">&#125;)</div><div class="line">app.get(&apos;/user&apos;, (req, res) =&gt; &#123;</div><div class="line">    res.render(&apos;user&apos;)</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>添加credentials.js存储证书文件<br>需要添加两个功能中间件，<code>body-parser</code>和<code>cookie-parser</code>，分别用来解析request请求中的表单body和之前服务器返回的cookie，第一次登录输入硬编码的用户名和密码，下一次再登录login界面将直接跳转到user路由，渲染user页面。<br>login页面主要是一个登录表单:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;form action=&quot;/process?from=login&quot; method=&quot;POST&quot;&gt;</div><div class="line">    &lt;label for=&quot;user&quot;&gt;user: &lt;input type=&quot;text&quot; name=&quot;user&quot;&gt;&lt;/label&gt;</div><div class="line">    &lt;label for=&quot;password&quot;&gt;password: &lt;input type=&quot;password&quot; name=&quot;password&quot;&gt;&lt;/label&gt;</div><div class="line">    &lt;input type=&quot;submit&quot; value=&quot;submit&quot;&gt;</div><div class="line">&lt;/form&gt;</div></pre></td></tr></table></figure></p>
<p>反复调试可以通过设置cookie的maxAge为一个较短的时间，或者用chrome工具删除cookie，也可以直接通过JS将document.cookie设置为<code>&#39;{cookiename}=0&#39;</code>的形式来清除cookie</p>
<h3 id="开发前端界面"><a href="#开发前端界面" class="headerlink" title="开发前端界面"></a>开发前端界面</h3><p>完成了一些后台逻辑之后我们需要对网站的展示部分进行设计和开发，可以结合网上流行的各种前端展示框架，比如Bootstrap，semanticUI，material-UI，等等进行开发，这些框架给我们提供了网页常用的各种组件，包括导航条，图标，按钮，表单的样式都已经有一套统一的设计，如果希望网站的展示效果区别于普通的网站，那就避免用Boostrap，因为它实在是太流行了，github上10W+的star是其他前端框架的好几倍，不是它不好，只是用久了难免有一些审美疲劳。</p>
<p>我在这套网站构建系统中使用的是semanticUI，它同样提供了丰富的前端组件，其次它的设计风格似乎要更有美感一些，但是它整包的体积太大了，从开发到生产要自行Build出相关样式的文件才划算。此外semanticUI的API风格是短类型名+多类型的组合，粒度更小，自由度比较高，举个栗子就是将btn-info-right的展示效果分割成三个类btn，info和right，这样可能会导致一些命名冲突的问题，但在小型项目中就不予考虑了。</p>
<p>由于页面设计能力有限，所以暂时先临摹一下medium网站的展示效果:<br><img src="/pic/1.jpg" alt=""><br>模仿效果，具体可以看github的代码:<br><img src="/pic/2.jpg" alt=""></p>
<h3 id="邮件系统"><a href="#邮件系统" class="headerlink" title="邮件系统"></a>邮件系统</h3><p>使用nodemailer模块构建web应用的邮件server非常方便，在lib下新建mailer.js<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">const nodemailer = require(&apos;nodemailer&apos;);</div><div class="line">module.exports = function(credentials) &#123;</div><div class="line">    let mailTransport = nodemailer.createTransport(&apos;smtps://&apos; + credentials.gmail.user + &apos;%40gmail.com:&apos; + credentials.gmail.password + &apos;@smtp.gmail.com&apos;);</div><div class="line">    let from = &apos;node-web-server-mailer&lt;shudery@gamil.com&gt;&apos;;</div><div class="line">    let masterEmail = &apos;125153450@qq.com&apos;</div><div class="line">    return &#123;</div><div class="line">        send(subject, html, to) &#123;</div><div class="line">            mailTransport.sendMail(&#123;</div><div class="line">                to: to ? to : masterEmail,</div><div class="line">                from,</div><div class="line">                subject,</div><div class="line">                html,</div><div class="line">            &#125;, (err, info) =&gt; &#123;</div><div class="line">                if (err) &#123;</div><div class="line">                    return console.log(&apos;send email error:&apos; + err);</div><div class="line">                &#125;;</div><div class="line">                console.log(&apos;send email info:&apos; + info.response);</div><div class="line">            &#125;);</div><div class="line">        &#125;,</div><div class="line">        errorSend(message, filename, exception) &#123;</div><div class="line">            let html = `&lt;h1&gt;site error:&lt;/h1&gt;message:$&#123;message&#125;&lt;br&gt;`;</div><div class="line">            if (filename) &#123;</div><div class="line">                html += `filename:$&#123;filename&#125;&lt;br&gt;`;</div><div class="line">            &#125;</div><div class="line">            if (exception) &#123;</div><div class="line">                html += `exception;$&#123;exception&#125;`;</div><div class="line">            &#125;</div><div class="line">            mailTransport.sendMail(&#123;</div><div class="line">                from,</div><div class="line">                to: masterEmail,</div><div class="line">                subject: &apos;site error&apos;,</div><div class="line">                html,</div><div class="line">            &#125;)</div><div class="line">        &#125;,</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="未完待续……"><a href="#未完待续……" class="headerlink" title="未完待续……"></a>未完待续……</h2>]]></content>
    
    <summary type="html">
    
      how to build vpn or vps by youself
    
    </summary>
    
      <category term="程序员" scheme="http://shudery.cn/categories/%E7%A8%8B%E5%BA%8F%E5%91%98/"/>
    
    
      <category term="记录" scheme="http://shudery.cn/tags/%E8%AE%B0%E5%BD%95/"/>
    
      <category term="web前端" scheme="http://shudery.cn/tags/web%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>简易的RSS格式输出工具</title>
    <link href="http://shudery.cn/2016/11/20/%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/%E7%AE%80%E6%98%93%E7%9A%84RSS%E6%A0%BC%E5%BC%8F%E8%BE%93%E5%87%BA%E5%B7%A5%E5%85%B7/"/>
    <id>http://shudery.cn/2016/11/20/方法总结/简易的RSS格式输出工具/</id>
    <published>2016-11-19T16:00:00.000Z</published>
    <updated>2017-03-14T09:09:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>RSS即简易信息聚合，当一个网站发布一个RSS文件后，这个RSS-Feed中包含的信息就能直接被其他站点调用，而且由于这些数据都是标准的XML格式，所以也能在其他的终端和服务中使用，是一种描述和同步网站内容的格式。<br><a id="more"></a></p>
<p>由于我习惯用mac触摸手势的操作，以及不喜欢在浏览器里点击位于不同收藏夹里的标签，用RSS阅读器这种内容聚合方式，极大提升了我阅读文章，获取资源的效率，但是现在许多我喜欢的站点不开放RSS格式的输出源，或者已经停止维护老旧的RSS地址了，因此我将这些站点先进行爬取，提取相应内容，然后结合标准的RSSXML模板将其输出，使其能够被RSS阅读器正常的订阅。</p>
<p>下面我就介绍一下这个工具：<a href="https://github.com/shudery/RSS-feed-spider">github地址</a></p>
<h2 id="RSS-feed-spider"><a href="#RSS-feed-spider" class="headerlink" title="RSS-feed-spider"></a>RSS-feed-spider</h2><h4 id="功能介绍"><a href="#功能介绍" class="headerlink" title="功能介绍"></a>功能介绍</h4><p>可以自己制作各大网站，内容频道的文章RSS格式输出源，通过爬虫工具抓取内容，输出RSS阅读器能够识别的XML格式，部署在PASS平台可以供阅读器订阅。目前由于很多站点二次爬取模板还没开发，故详情内容要跳转到原站，这对手势操作以及原本就想看原站的人没有大多影响，当然了，这意味着没法离线阅读内容，或者说事先缓存文章（只有标题）</p>
<h4 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h4><p>利用site目录下存好的各站点基本信息，根据页面结构修改选择器，利用爬虫爬取页面，抓取相关信息填入RSS-XML模板中，将结果的XML文件返回到客户端，服务端使用Node.js和web应用快速搭建框架express，爬虫用superagent，pass平台使用heroku(国外不太稳定)</p>
<h4 id="查询参数"><a href="#查询参数" class="headerlink" title="查询参数"></a>查询参数</h4><p>每个RSS订阅源的格式为：<a href="https://daguo-rss.herokuapp.com/?site={}">https://daguo-rss.herokuapp.com/?site={}</a><br>可以在订阅url后面添加查询参数，如?site=jianshu&amp;num=20&amp;desc=true</p>
<ul>
<li>site：站点名字  </li>
<li>num：抓取文章数量，默认10，没有翻页逻辑，最多主页全部文章  </li>
<li>desc：是否抓取描述，需要二次爬取，不稳定，默认不开</li>
</ul>
<h4 id="扩展方法"><a href="#扩展方法" class="headerlink" title="扩展方法"></a>扩展方法</h4><p>直接在项目site目录下生成相应的站点爬取脚本，脚本名字即对应的查询参数里site={}需要填写的字符串。单次爬取的模板都一样，只需要配置相应的RSS基本信息，修改getItems函数中相应字段的选择器，这里用cheerio获取DOM节点。</p>
<h4 id="完成站点"><a href="#完成站点" class="headerlink" title="完成站点"></a>完成站点</h4><ul>
<li><a href="https://daguo-rss.herokuapp.com/?site=jianshu">简书热门频道</a></li>
<li><a href="https://daguo-rss.herokuapp.com/?site=guoke">果壳</a></li>
<li><a href="https://daguo-rss.herokuapp.com/?site=juejin">掘金前端</a></li>
<li><a href="https://daguo-rss.herokuapp.com/?site=ted">TED</a></li>
<li><a href="https://daguo-rss.herokuapp.com/?site=zaoduke">前端早读课</a></li>
<li><a href="https://daguo-rss.herokuapp.com/?site=hacker">Hacker News</a></li>
<li><del>电子科技大学UESTC新闻</del></li>
<li><del>下厨房流行菜谱</del></li>
<li><del>卢松松好文分享</del></li>
<li><del>微信自媒体</del></li>
<li><del>开发者头条</del></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;RSS即简易信息聚合，当一个网站发布一个RSS文件后，这个RSS-Feed中包含的信息就能直接被其他站点调用，而且由于这些数据都是标准的XML格式，所以也能在其他的终端和服务中使用，是一种描述和同步网站内容的格式。&lt;br&gt;
    
    </summary>
    
      <category term="方法总结" scheme="http://shudery.cn/categories/%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="JavaScript编程" scheme="http://shudery.cn/tags/JavaScript%E7%BC%96%E7%A8%8B/"/>
    
      <category term="web前端" scheme="http://shudery.cn/tags/web%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>基于openCV的计算机视觉研究</title>
    <link href="http://shudery.cn/2016/11/08/%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/%E5%9F%BA%E4%BA%8EopenCV%E7%9A%84%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E7%A0%94%E7%A9%B6/"/>
    <id>http://shudery.cn/2016/11/08/方法总结/基于openCV的计算机视觉研究/</id>
    <published>2016-11-07T16:00:00.000Z</published>
    <updated>2016-11-23T15:39:27.000Z</updated>
    
    <content type="html"><![CDATA[<p>计算机视觉随着AR，VR，自动驾驶，人工智能等技术的崛起，已经成为一个迅速发展并且富有前景的领域。openCV，计算机视觉开源库，与前端工程师经常打交道的openGL算是兄弟函数库。</p>
<p>openGL作为专业的图形编程接口，为程序员提供了功能强大，调用方便的底层图形库。openCV则致力于提供实现图像处理和计算机视觉的通用算法，降低了学习计算机设觉领域的门槛，让开发者可以更快的收获机器视觉带来的乐趣。<br><a id="more"></a><br>说了这么多然而我是一个前端工程师啊，我更关心人类的视觉体验，无缘无故怎么会闲的蛋疼跑来弄计算机视觉呢；好吧这其实是我的毕业设计题目，之前没有事先找老师拿题目，在选择毕业设计的那个早晨，我睡过了。。许多我擅长的软件题目都被选了，所以我还感兴趣的就剩下了比较难啃的计算机视觉还有深度学习相关的课题，老师说如果我下学期要去实习，推荐我选相对简单的计算机视觉。选好题目和实验室学长打过招呼拿了一些学习资料后，由于各种事情搁置了一段时间，最近闲起来，决定开始学习这个火热的领域。</p>
<p>回到正题，openCV是用C++编写的，但是依然有大量的C语言接口。该库也有大量的Python,Java,MATLAB的接口，由于我最近刚好在复习C语言，平时写算法如果不能用ES6也都是用C，所以我觉得用C语言来完成后续的编程工作。</p>
<p>学习过程中，感受到了很多资料的缺失和落后，国外要好一点，而且社区也远远没有前端技术社区的氛围，有一些小坑解决起来还挺浪费时间的，今天我已经把openCV在macOS的开发环境，包括xCode的一些设置，作为前端ST信仰粉，一直秉持不到万不得已不用IDE的态度，然而这次为了调试还是用xCode吧，基于sublime text的latex论文书写环境也配置好了，接下来就是一边理论学习，一边实践操作的过程了，希望年前能有一个比较好的完成度，同时对这个领域能有一些比较深入的见解。</p>
<hr>
<p>下面记录一下搭建环境的过程，后续会继续记录基于openCV的计算机视觉的研究成果~</p>
<h3 id="macOS搭建基于Xcode的openCV开发环境"><a href="#macOS搭建基于Xcode的openCV开发环境" class="headerlink" title="macOS搭建基于Xcode的openCV开发环境"></a>macOS搭建基于Xcode的openCV开发环境</h3><h4 id="下载源码："><a href="#下载源码：" class="headerlink" title="下载源码："></a>下载源码：</h4><p>mac下运用openCV的函数需要自行编译源代码，官方的解释是由于包括linux和macOS的各类Unix系统各自带的编译器不同，所以需要多几个步骤，可以从官网上选择相应版本的zip下载。openCV是使用非常宽松的BSD协议的开源项目，BSD比起MIT而言在修改代码，重新封装之后不要求一定要公开源码，现在计算机视觉开发尚未普及，这么做也是保护使用openCV公司的商业机密，让开发者可以毫无顾虑的使用openCV这个视觉库，所以也可以直接从github上下载openCV，</p>
<h4 id="编译源码："><a href="#编译源码：" class="headerlink" title="编译源码："></a>编译源码：</h4><p>下载mac编译源码的工具cmake，直接一行homebrew代码搞定：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">brew install cmake</div></pre></td></tr></table></figure></p>
<p>然后解压下载的zip源代码，进入解压后的文件目录，创建一个存放openCV函数的目录release，在该目录下执行命令开始编译。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">mkdir release</div><div class="line">cd release</div><div class="line">cmake -G &quot;Unix Makefiles&quot;</div><div class="line">make</div><div class="line">make install</div></pre></td></tr></table></figure>
<p>部分命令可能需要sudo权限。</p>
<h4 id="Xcode开发环境："><a href="#Xcode开发环境：" class="headerlink" title="Xcode开发环境："></a>Xcode开发环境：</h4><p>新建命令行command line tool工程，选择C或者C++语言，<br>可以复制下面这段<code>hello world</code>式的开始程序来调试，用通常的打印信息的函数可以检验大多数编程环境，但是由于这里涉及到代码库是否成功引入等问题，所以运用一些openCV的通用函数来看能否成功运行。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">#include &lt;highgui.h&gt;</div><div class="line">int main(int argc, char **argv)</div><div class="line">&#123;</div><div class="line">    IplImage *img = cvLoadImage( argv[1],-1);</div><div class="line">    cvNamedWindow( &quot;Example1&quot;, CV_WINDOW_AUTOSIZE);</div><div class="line">    cvShowImage( &quot;Example1&quot;, img);</div><div class="line">    cvWaitKey(0);</div><div class="line">    cvReleaseImage( &amp;img);</div><div class="line">    cvDestroyWindow( &quot;Example1&quot;);</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这段代码功能很简单，可以读取本地的一张图片并展示出来，这里参数argv[1]需要替换为要显展示图片的地址，第二个参数有三个取值：-1为默认读取图像的原通道数；0为强制转化读取图像为灰度图；1为读取彩色图，每个函数的用途非常简单好用：<code>IplImage</code> 是一个存储图片的结构体，<code>cvLoadImage</code> 为存储图片的方式，<code>cvNamedWindow</code> 创建一个名字为<code>Example1</code>的窗口，第二个参数<code>CV_WINDOW_AUTOSIZE</code>表示窗口大小根据加载的图片自动变化，<code>cvWaitKey(0)</code>含义是读取到键盘操作继续进行程序，<code>cvReleaseImage</code>和<code>cvDestroyWindow</code>是释放结构体和窗口的空间，可以省略，加上更严谨。</p>
<p>然后开始运行左上角的三角按钮，或者cmd+B构建，会提示找不到highgui.h的文件，所以我们还需要给这个项目配置头文件路径。</p>
<h4 id="配置头文件路径："><a href="#配置头文件路径：" class="headerlink" title="配置头文件路径："></a>配置头文件路径：</h4><p>点一下左侧文件的项目根，中间代码区域找到Bulid Setting，在搜索栏中输入search<br>找到Header search Paths这一项添加openCV三个默认的编译存储地址：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">/usr/local/include</div><div class="line">/usr/local/include/opencv</div><div class="line">/usr/local/include/opencv2</div></pre></td></tr></table></figure></p>
<p>Library search Paths这一项添加<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/usr/local/lib</div></pre></td></tr></table></figure></p>
<p><img src="/pic/1-2.png" alt=""></p>
<p>完成之后编译运行程序，正常来说，应该还有报错和40多个warning警告，警告大部分是未使用的函数报警，这个无关紧要，分析错误查了一波资料哦后发现还缺少在项目中引入一些openCV的<code>.dylib</code>文件。</p>
<h4 id="引入-dylib文件："><a href="#引入-dylib文件：" class="headerlink" title="引入.dylib文件："></a>引入.dylib文件：</h4><p><code>.dylib</code>位于编译目录release的lib目录中，在项目根右击创建一个新组lib，添加所有的<code>.dylib</code>文件进去即可成功实现第一个<code>helloworld</code>程序。<br><img src="/pic/1-1.png" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;计算机视觉随着AR，VR，自动驾驶，人工智能等技术的崛起，已经成为一个迅速发展并且富有前景的领域。openCV，计算机视觉开源库，与前端工程师经常打交道的openGL算是兄弟函数库。&lt;/p&gt;
&lt;p&gt;openGL作为专业的图形编程接口，为程序员提供了功能强大，调用方便的底层图形库。openCV则致力于提供实现图像处理和计算机视觉的通用算法，降低了学习计算机设觉领域的门槛，让开发者可以更快的收获机器视觉带来的乐趣。&lt;br&gt;
    
    </summary>
    
      <category term="方法总结" scheme="http://shudery.cn/categories/%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="程序员" scheme="http://shudery.cn/tags/%E7%A8%8B%E5%BA%8F%E5%91%98/"/>
    
  </entry>
  
  <entry>
    <title>运用钩子：监听npm仓库和包更新</title>
    <link href="http://shudery.cn/2016/11/07/%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/%E8%BF%90%E7%94%A8%E9%92%A9%E5%AD%90%EF%BC%9A%E7%9B%91%E5%90%ACnpm%E4%BB%93%E5%BA%93%E5%92%8C%E5%8C%85%E6%9B%B4%E6%96%B0/"/>
    <id>http://shudery.cn/2016/11/07/方法总结/运用钩子：监听npm仓库和包更新/</id>
    <published>2016-11-06T16:00:00.000Z</published>
    <updated>2016-11-30T07:41:54.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>本文由我翻译在<a href="http://www.zcfy.cc/claim">众成</a>翻译平台，<a href="http://www.zcfy.cc/article/introducing-hooks-get-notifications-of-npm-registry-and-package-changes-as-they-happen-1610.html">文章地址</a></strong></p>
<p>今天我很高兴地给大家介绍一种简单强大的方法，可以用于追踪npm仓库变更，构建自己的开发环境的工具：钩子。</p>
<a id="more"></a>
<h2 id="What"><a href="#What" class="headerlink" title="What?"></a>What?</h2><p>钩子是你订阅的npm仓库事件的通知者，运用钩子，你能构建可以响应npm仓库中软件包更改的处理各种任务的集成环境。</p>
<p>每一次软件包变化，钩子会发送一个HTTP的POST请求给一个你在钩子中配置的URI地址，你可以添加钩子来监听特别的软件包，监听包发布者的动态，或者监听一个组织里的所有软件包和用户。</p>
<p>举个栗子，你可以通过给<strong>@npm</strong>设置一个钩子，监视npm所有上传的软件包，如果你只想监视lodash这个包，同样可以给<strong>@lodash</strong>设置钩子。</p>
<h2 id="When"><a href="#When" class="headerlink" title="When?"></a>When?</h2><p>如果你有一个paid，<a href="http://t.umblr.com/redirect?z=https%3A%2F%2Fwww.npmjs.com%2Fnpm%2Fprivate-packages&amp;t=MGY4N2Q4OWRmYTljZDg2YzViMzQzZGY5YmE4ZWJiOGI3MDg2M2QwOSxycTRWMHI1eA%3D%3D">个人或者组织的npm账号</a>，那么你可以马上运用钩子。</p>
<p>每一个用户可以配置总共100个钩子，至于要如何使用它们，这就取决你了：你可以将它们都用于监听同一个软件包，或者监听100个不同的包。如果你用一个钩子监听某一个范围，那么算作一个单一的钩子，不论这个范围内有多少个软件包。你可以监视npm代码库中任何开源的软件包，以及任何你可以控制的私人包，你只能收到有权限访问的软件包的钩子通知。</p>
<h2 id="How"><a href="#How" class="headerlink" title="How?"></a>How?</h2><p><img src="http://p0.qhimg.com/t01252b2385f2f7beb8.png" alt="!full Slack integration"></p>
<p>现在用<a href="http://t.umblr.com/redirect?z=https%3A%2F%2Fwww.npmjs.com%2Fpackages%2Fwombat&amp;t=Y2JjNDUwNzc2ZWZiY2Q3NDMxZjVhM2ZmZTM2NGE3ZTU0Njc0MmEyMSxycTRWMHI1eA%3D%3D">wombat</a>命令行工具创建你的第一个钩子。</p>
<p>首先，用通用的方法下载wombat</p>
<p><code>npm install -g wombat</code></p>
<p>然后开始设置一些钩子。</p>
<p><strong>1. 监听npm的软件包：</strong></p>
<p><code>wombat hook add npm</code></p>
<p><a href="http://t.umblr.com/redirect?z=https%3A%2F%2Fexample.com%2Fwebhooks&amp;t=ZDA5NzVhODQ0MjQ0ZmI2MzhmOGMzZjYwZTljZGEzYTBkMjIwZmU3YSxycTRWMHI1eA%3D%3D">https://example.com/webhooks</a> shared-secret-text</p>
<p><strong>2. 监听@slack组织客户API的更新：</strong></p>
<p><code>wombat hook add @slack</code></p>
<p><a href="http://t.umblr.com/redirect?z=https%3A%2F%2Fexample.com%2Fwebhooks&amp;t=ZDA5NzVhODQ0MjQ0ZmI2MzhmOGMzZjYwZTljZGEzYTBkMjIwZmU3YSxycTRWMHI1eA%3D%3D">https://example.com/webhooks</a> but-sadly-not-very-secret</p>
<p><strong>3. 监听ever-prolific substack:</strong> </p>
<p><code>wombat hook add --type=owner substack</code></p>
<p><a href="http://t.umblr.com/redirect?z=https%3A%2F%2Fexample.com%2Fwebhooks&amp;t=ZDA5NzVhODQ0MjQ0ZmI2MzhmOGMzZjYwZTljZGEzYTBkMjIwZmU3YSxycTRWMHI1eA%3D%3D">https://example.com/webhooks</a> this-secret-is-very-shared</p>
<p><strong>4. 查看你的所有钩子以及它们上一次触发的时间:</strong></p>
<p><code>wombat hook ls</code></p>
<p> 提示：Wombat还有几个有趣的用法。<code>wombat --help</code>会告诉你还有哪些用法。</p>
<p>我们也提供了公共的API来运行钩子，更多的细节以及如何运用API而不用wombat来管理你的钩子可以参考<a href="http://t.umblr.com/redirect?z=https%3A%2F%2Fgithub.com%2Fnpm%2Fregistry%2Ftree%2Fmaster%2Fdocs%2Fhooks&amp;t=MDE2Y2IzMjJjMGVlOGVkMGY0ZDAwZDhhMzhjMTVmNjJjZGNiOWI4MCxycTRWMHI1eA%3D%3D">文档</a>.</p>
<h2 id="Why"><a href="#Why" class="headerlink" title="Why?"></a>Why?</h2><p>你能运用钩子来触发集成测试，触发代码部署，在聊天频道发布通知或者触发你自己软件包的更新</p>
<p>为了帮助你更好地上手，提供给你一些我们在开发钩子的时候整理的资料。</p>
<ul>
<li><p><a href="http://t.umblr.com/redirect?z=https%3A%2F%2Fwww.npmjs.com%2Fpackage%2Fnpm-hook-receiver&amp;t=OGRjZGI4YmEyYzQ0NDY0YzZjOTdiMzEzOGY5ZTE2MzM2ODViZThkOSxycTRWMHI1eA%3D%3D">npm-hook-receiver</a>: 一个用钩子监听HTTP的post请求的<a href="http://t.umblr.com/redirect?z=https%3A%2F%2Fwww.npmjs.com%2Fpackage%2Frestify&amp;t=OTI5YzEwOGFhNGE2NjhkYzg0ZWNjMzY5OTI5N2Y3YjM0YmNiZjc2YSxycTRWMHI1eA%3D%3D">例子</a>，<a href="http://t.umblr.com/redirect?z=https%3A%2F%2Fgithub.com%2Fnpm%2Fnpm-hook-receiver&amp;t=Yjk3ZWI1OWE5YTg5ZmQ2NWM4Yzk4N2YwOGYwYjVlYTM1ZWE0NjZiNCxycTRWMHI1eA%3D%3D">源码点这里</a>.</p>
</li>
<li><p><a href="http://t.umblr.com/redirect?z=https%3A%2F%2Fgithub.com%2Fnpm%2Fnpm-hook-slack&amp;t=MGY1NTdjMjUwZjZkODJlZGI1YTFiNDJhNWI5YzNkZDcyOTc5NWI5YSxycTRWMHI1eA%3D%3D">npm-hook-slack</a>: 世界上最简单的播报Slack包事件的Slackbot，用npm-hook-receiver构建.</p>
</li>
<li><p><a href="http://t.umblr.com/redirect?z=https%3A%2F%2Fgithub.com%2Fnpm%2Fcaptain-hook&amp;t=ZDc3ZDU2MDZjMjRlNjRkMGIyYmMyZDA2OTFkNjA3NGFhY2JmMmRiOSxycTRWMHI1eA%3D%3D">captain-hook</a>: 一个有趣的工具帮你管理你的web钩子以及接收posts.</p>
</li>
<li><p><a href="http://t.umblr.com/redirect?z=https%3A%2F%2Fwww.npmjs.com%2Fpackage%2Fwombat&amp;t=NDBiZDBlZDM0OGY0OGYwOGFlNGU5YzdjYWJkNTUxNzgzMWZiOTU1OSxycTRWMHI1eA%3D%3D">wombat</a>: 一个CLI命令行工具，用于检查和编辑你的钩子，这个客户端运用所有的钩子API，<a href="http://t.umblr.com/redirect?z=https%3A%2F%2Fgithub.com%2Fnpm%2Fwombat-cli&amp;t=YzQxZTJiYWVkYTBhYmIyYmQzMTc4M2Y2ZTVmMjc3ZGMxOWRiNDY5MyxycTRWMHI1eA%3D%3D">源码点这里</a>.</p>
</li>
<li><p><a href="http://t.umblr.com/redirect?z=https%3A%2F%2Fgithub.com%2Fnpm%2Fifttt-hook-translator&amp;t=NjliNTU2YjkyZDVkNDEyOWMwZGFkODMxNGE5MzU5OWMzODVjMGQ4NSxycTRWMHI1eA%3D%3D">ifttt-hook-translator</a>: 一个可以接收web钩子已经将其转化为<a href="http://t.umblr.com/redirect?z=https%3A%2F%2Fifttt.com%2F&amp;t=ZWI1MzhmMzYxOGVlNTExNjYwYWY1ZWNlMWNhZDdiOTQ5ZmU5ZjBlMixycTRWMHI1eA%3D%3D">IFTTT</a>事件的工具, 可以用它触发任何你能在IFTTT做的事情</p>
</li>
<li><p><a href="http://t.umblr.com/redirect?z=https%3A%2F%2Fgithub.com%2Fbcoe%2Fcitgm-harness%2Fpulls&amp;t=Mzk1MDA1MDUxNGE3NDAyMTljNzYxYTgyMDkxNWQ0Y2RhZTA4YmZhZixycTRWMHI1eA%3D%3D">citgm-harness</a>: <a href="http://t.umblr.com/redirect?z=https%3A%2F%2Fgithub.com%2Fnodejs%2Fcitgm&amp;t=ZTJkM2YzMzZmYzk5MWI3N2YyZTA0ZDRmZGE2N2ZmY2QyYmViMjJkMixycTRWMHI1eA%3D%3D">Canary in the Gold Mine suite</a> 一个Nodejs运用钩子来驱动包测试的工具，详细的包信息触发不同项目持续的集成测试，是一个测试是否破坏由顶自下依赖条件的方法</p>
</li>
</ul>
<h2 id="What-do-you-think"><a href="#What-do-you-think" class="headerlink" title="What do you think?"></a>What do you think?</h2><p>我们公布的是钩子的Beta版本，从哪里获得它就行。我们如何看待它？你们还有其他想要的监听的事件？100个钩子的提供太多还是太少？</p>
<p>我们对你的看法真的非常感兴趣，如果你构建了一些有用的或者用处不大的钩子工具，不要害羞与我们<a href="http://t.umblr.com/redirect?z=http%3A%2F%2Finfo%40npmjs.com&amp;t=MGIzMWQ2MGMxZGVhODlkYTFkYmExNGFmZmYyNDQzNTBjZjg3YzQzZSxycTRWMHI1eA%3D%3D">交流</a>或者在<a href="https://twitter.com/npmjs">推特</a>上面@我们。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;本文由我翻译在&lt;a href=&quot;http://www.zcfy.cc/claim&quot;&gt;众成&lt;/a&gt;翻译平台，&lt;a href=&quot;http://www.zcfy.cc/article/introducing-hooks-get-notifications-of-npm-registry-and-package-changes-as-they-happen-1610.html&quot;&gt;文章地址&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;今天我很高兴地给大家介绍一种简单强大的方法，可以用于追踪npm仓库变更，构建自己的开发环境的工具：钩子。&lt;/p&gt;
    
    </summary>
    
      <category term="方法总结" scheme="http://shudery.cn/categories/%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="翻译" scheme="http://shudery.cn/tags/%E7%BF%BB%E8%AF%91/"/>
    
      <category term="工具" scheme="http://shudery.cn/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>程序员的苦与乐</title>
    <link href="http://shudery.cn/2016/10/19/%E7%A8%8B%E5%BA%8F%E5%91%98/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%8B%A6%E4%B8%8E%E4%B9%90/"/>
    <id>http://shudery.cn/2016/10/19/程序员/程序员的苦与乐/</id>
    <published>2016-10-19T15:32:17.000Z</published>
    <updated>2016-10-20T14:19:59.000Z</updated>
    
    <content type="html"><![CDATA[<p>前段时间准备秋招，思考着如何回答一些主观题，比如为什么做前端，平时如何持续学习，未来职业的规划等。<br>要不是为了准备面试，平时根本没有好好想过这些问题，找工作面试这一过程还真是蛮锻炼人的。<br>最近刚好读了软件著作《人月神话》，深受鼓舞，尝试着结合里面关于程序员职业的思考和自己学习编程的经历，去回答类似为什么当一个程序员这样的问题。<br>下文是我摘录自Dr.Brooks著名的软件管理书籍《人月神话》中的文章以及自己的一些想法。</p>
<a id="more"></a>
<hr>
<h3 id="职业的乐趣"><a href="#职业的乐趣" class="headerlink" title="职业的乐趣"></a>职业的乐趣</h3><p>编程为什么有趣，作为回报，它的从业者期望得到什么样的快乐？</p>
<p>首先，这种快乐是一种创建实物的纯粹快乐。如同小孩在玩泥巴时感到快乐一样，成年人喜欢创建事物，特别是自己进行设计，我想这种快乐是上帝创建世界的折射，一种呈现在每片独特的，崭新的树叶和雪花上的喜悦。</p>
<p>其次，这种快乐来自于开发对他人有用的东西。内心深处，我们期望我们的劳动成果能够被他人使用，并能对他们有所帮助。从这一角度而言，这同小孩用黏土为爸爸的办公室捏制铅笔盒没有任何本质的区别。</p>
<p>第三，快乐来自于整个过程体现出的一种强大的魅力，将互相齿合的零部件组装在一起，看到它们以精妙的方式运行着，并收到了预期到效果。比起弹球游戏机或自动点唱机所具有的迷人魅力，程序化计算机毫不逊色。</p>
<p>第四，这种快乐是持续学习的快乐，它来自于这项工作的非重复特性。人们所面临的问题总有这样那样的不同，因而解决问题的人可以从中学习新的事物，有时是实践上的，有时是理论上的，或者兼而有之。</p>
<p>最后，这种快乐还来自于在基于驾驭的介质上工作。程序员，就像诗人一样，几乎仅仅在单纯的思考中工作。程序员凭空地运用自己的想象，来建造自己的城堡。很少有创造介质如此灵活，如此易于精练和重建，如此容易实现概念上的设想，不过我们也将看到，容易驾驭的特性也有它自己的问题。</p>
<p>然而程序毕竟和诗歌不同，它是实实在在的东西：它可以移动和运行，能独立产生可见的输出，它能打印结果，绘制图形，发出声音，移动支架。神话和传说中的魔术在我们的时代已经变成了现实。在键盘上输入正确的咒语，屏幕会互动，变幻，显示出前所未有的也不可能存在的事物。</p>
<p>编程的快乐在于它不仅满足了我们内心深处进行创造的渴望，而且还唤醒了每个人内心的情感。</p>
<hr>
<h3 id="职业的苦恼"><a href="#职业的苦恼" class="headerlink" title="职业的苦恼"></a>职业的苦恼</h3><p>然而这个过程并不全是快乐的。我们只有事先了解一些编程固有的苦恼，这样，当它们真的出现时，才能更加坦然地面对。</p>
<p>首先，苦恼来自追求完美。因为计算机是以这样的方式来变戏法的：如果咒语中的一个字符，一个停顿，没有与正确的形式完全一致，魔术就不会出现，现实中，很少有人类活动会要求如此完美，所以人类对它本来就是不习惯的，实际上，我认为，学习编程最困难的部分，是将做事的方式向追求完美的方向调整。</p>
<p>其次，苦恼来自由他人设定目标，供给资源和提供信息。编程人员很少能控制工作环境和工作目标，用管理的术语来说，个人权威和他所承担的责任是不匹配的，不过，似乎在所有的领域中，对要完成的工作，很少能提供与责任相一致的正式权威。而实际情况中，实际相对于形式的权威来自于每次任务的完成。</p>
<p>对系统编程人员而言，对其他人的依赖是一件非常痛苦的事情。依靠其他人的程序，而这些程序往往设计得并不合理，实现拙劣，发布不完整，没有源代码和测试用例，或者文档记录糟糕，所以系统编程人员不得不花费时间去研究和修改，而它们在理想情况下本应该可以是完整的，可靠的。</p>
<p>下一个苦恼，概念性设计是有趣的，但寻找琐碎的Bug却是一项重复性的活动。伴随着创造性活动的，往往是枯燥沉闷的时间和艰苦的劳动。程序编制工作也不例外。</p>
<p>另外，人们发现调试和差错往往是线性收敛的，或者更糟糕的是，具有二次方的复杂度。结果，测试一拖再拖，寻找最后一个错误比第一个错误将花费更多的时间。</p>
<p>最后一个苦恼，有时也是一种无奈，当投入了大量辛苦的劳动，产品在即将完成或者终于完成的时候，却已显得陈旧过时。可能是同事和竞争对手已在追逐新的，更好的构思，也许替代方案不仅仅是在构思，而且已经在安排了。</p>
<p>现实情况比上面说的通常好一点。当产品开发完成时，更优秀的新产品通常还不能投入使用，而仅仅是为大家所谈论而已，另外，它同样需要数月的开发时间。事实上，只有实际需要时，才会用到最新的设想，因为所实现的系统已经能满足要求，并体现了回报。</p>
<p>诚然，产品开发所基于的技术在不断的进步。一旦设计被冻结，在概念上就已经开始陈旧了。不过，实际产品需要一步一步按阶段实现。实现落后与否的判断应根据其他已有的系统，而不是未实现的概念，因此，我们所面临的挑战和任务是在实际的进度和有有效的资源范围内的，寻找解决实际问题的切实可行方案。</p>
<p>这就是编程，一个许多人痛苦挣扎的焦油坑以及一种乐趣和苦恼共存的创造性活动。对许多人比如我而言，其中的快乐远大苦恼。其实作者文中讲到的苦恼，大多我还没有实际遇到过，因为我还没有足够的经历涉及到大型的团队项目，而这些苦恼无一例外在团队和项目变得庞大的时候也将随之放大，值得一提的是，在作者写这本著作的几十年前，估计不知道当今互联网发展如此快速吧，不然我猜他一定会在职业的苦恼加上一条惨无人道的加班时间吧。</p>
<p>总结来说，于我而言，编程赋予我创造工具，提供服务的能力，给我体现自身价值和满足成就感的机会，现在它即将成为我立足社会，赚钱混饭的技能，就这三点已经可以充分支撑我在程序员这条道路不断前行了。至于文中说的持续学习的快乐，作为一个团队项目不可或缺的一个部件之类的，随着我持续专注的学习，我想以后我一定能更切实的体会到那种愉悦吧。至于加班的事情，作为一个华为战士，我就不说什么了，已经准备好了。</p>
]]></content>
    
    <summary type="html">
    
      work
    
    </summary>
    
      <category term="程序员" scheme="http://shudery.cn/categories/%E7%A8%8B%E5%BA%8F%E5%91%98/"/>
    
    
      <category term="程序员" scheme="http://shudery.cn/tags/%E7%A8%8B%E5%BA%8F%E5%91%98/"/>
    
  </entry>
  
  <entry>
    <title>offer已拿，我要浪起来</title>
    <link href="http://shudery.cn/2016/09/30/%E9%9A%8F%E7%AC%94/offer%E5%B7%B2%E6%8B%BF%EF%BC%8C%E6%88%91%E8%A6%81%E6%B5%AA%E8%B5%B7%E6%9D%A5/"/>
    <id>http://shudery.cn/2016/09/30/随笔/offer已拿，我要浪起来/</id>
    <published>2016-09-29T16:00:00.000Z</published>
    <updated>2016-12-06T11:59:33.000Z</updated>
    
    <content type="html"><![CDATA[<p>在找工作的第二个月月末终于收到了大厂的offer了，不枉这段时间的努力准备啊，终于可以松口气啦。</p>
<p>稍微整理一下，把我找工作这段时间的一些感悟，吐槽还有一些有趣的事情记录一下，一些技术方面的问题我整理放在了<a href="https://shudery.gitbooks.io/front-end-offer/content/">gitbook</a>上面了，主要是一些前端热点知识和计算机数据结构基础。</p>
<p>我找工作时，整体感觉大厂的招聘流程确实要成熟一些，即使投简历的人很多，仍然非常高效，这个不关乎成本，其实就是招聘规划是否合理的问题，很多小公司招聘投入没有大公司多，招聘规划也不做好准备。<br><a id="more"></a><br>最基本的就是中间流程拖太久，终面之后拖很久可以理解，但是一面和二面为什么要隔20天呢，我去面试TP-link的时候就是跑很远到酒店面试，一面就问了几个简单的小问题，才十几分钟就结束了，问过了的话二面什么时候，居然要等2周。</p>
<p>总结一下这段时间面试的感悟，我觉得做技术这一块，除了技术问题肯定是得了解之外，还是有不少的应聘技巧的，前期大量的刷职业相关的技术热点题目，配合几篇面试经验帖子。</p>
<p>刷题目让你重温了一遍许多技术点，刷的时候讲究理解，不要死记，技术问题就按照是什么，有何有点，如何实现这样一条线去理清就行了，按这种方式了解了一定数目的技术题后，你会打从心里充满自信的。而且这和考试不太一样，考试中的知识点很多都是理论的东西，你没用过也不知道怎么用，技术问题不一样，你充分理解后，可以对以前做过的一些项目，遇到的技术问题做提炼，还可以诞生新的想法在以后的实践中，简单来说考试的知识点很多考完试就没用了，但是面试技术岗学习的东西，你很可能面完试后在以后做项目需要和遇到困难的时候想到。</p>
<p>刷技术问题过程还可以更加进阶地准备，在对应的技术问题上结合自己曾经做过的项目，加上自己独特的理解和充分对比不同技术的应用场景都是可以加分的。<br>刷面试经验不用太多，这个我觉得主要是让你充分了解相应的招聘流程以及在面试过程中可能发生的情况，以便你更加自如的应对，一个简单的例子，你如果刷面经可能就知道某某公司是喜欢让应聘者直接打代码的，这样你在面试前就要做好这方面的准备，免得面试过程中一下懵逼。</p>
<p>后期有一定的经验后要将这些经验总结起来，包括面试过程中遇到的技术问题，自己表现的一些不足，踩了哪些面试地雷等等，然后下一次面试格外注意这些地方，就会越战越勇。然后技术方面的问题以及职业规划，项目实践等这些说烂了的解释和介绍，自己可以琢磨这如何更有逼格地或者更加通俗地说明。</p>
<p>再说说些有意思的事情，我之前投递了一家游戏公司，收到了图形测试题，硬性规定要过某一个分数才可以面试，我看那些图形都快看瞎了，但还是想尽力做吧，最后没过，HR又给我发一次，还跟我说他发题太晚了，估计我精神状态不好，还跟我道歉，总之就是让我重做，然后我又没过，HR又一次发了题给我，感觉被这个公司秀了智商。</p>
<p>还有一次我大老远跑到一个酒店面试，进去之后我发现居然是视频面试，我在面试的过程中就直接问对方视频面试我在寝室面不行吗，为什么还要应聘者跑过来，对方解释说是需要用对方公司的内部账号和视频软件什么的，至今无法理解。</p>
<p>我在内推腾讯TST的时候不知道是出了什么乌龙，一个月内大概一共电话面试了5次，不清楚到底发生了什么。可以肯定的是我被多次刷掉，然后放回资源池中，又被其他的面试官看中，然后联系我，一直在被面试官虐，心疼自己；听说腾讯面试完即时被刷也会给面试者的简历备注上很完备的信息，方便下一个面试官去面试，如果面试我的面试官都认真备注了，那我的简历备注应该记爆了吧（摊手。</p>
<p>面试小公司的时候，如果你是985高校或者实习经验牛逼或者项目经历牛逼，对方总会给你一种很没有自信的感觉，他们会觉得你不太可能会去他们公司，所以会花很多时间了解你为什么要为什么想去小公司，为什么想去那个城市。无论是技术面还是HR，都要问你，为什么不去大厂之类的话，其实很多时候我都想直说我就是来练练手，顺便拿个offer保底啊大哥。后来我嫌麻烦发现一个回答，可以很好的答为什么想去那个城市，就说你女朋友是那里的人就行了（逃，对方基本就放心了不会再问了。</p>
<p>好了，先这样，呼应标题，我要想想怎么去浪了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在找工作的第二个月月末终于收到了大厂的offer了，不枉这段时间的努力准备啊，终于可以松口气啦。&lt;/p&gt;
&lt;p&gt;稍微整理一下，把我找工作这段时间的一些感悟，吐槽还有一些有趣的事情记录一下，一些技术方面的问题我整理放在了&lt;a href=&quot;https://shudery.gitbooks.io/front-end-offer/content/&quot;&gt;gitbook&lt;/a&gt;上面了，主要是一些前端热点知识和计算机数据结构基础。&lt;/p&gt;
&lt;p&gt;我找工作时，整体感觉大厂的招聘流程确实要成熟一些，即使投简历的人很多，仍然非常高效，这个不关乎成本，其实就是招聘规划是否合理的问题，很多小公司招聘投入没有大公司多，招聘规划也不做好准备。&lt;br&gt;
    
    </summary>
    
      <category term="随笔" scheme="http://shudery.cn/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="随笔" scheme="http://shudery.cn/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript如何真正实现原型链继承</title>
    <link href="http://shudery.cn/2016/09/29/%E5%AD%A6%E4%B9%A0%E6%84%9F%E6%82%9F/JavaScript%E5%A6%82%E4%BD%95%E7%9C%9F%E6%AD%A3%E5%AE%9E%E7%8E%B0%E5%8E%9F%E5%9E%8B%E9%93%BE%E7%BB%A7%E6%89%BF/"/>
    <id>http://shudery.cn/2016/09/29/学习感悟/JavaScript如何真正实现原型链继承/</id>
    <published>2016-09-29T13:32:17.000Z</published>
    <updated>2017-03-14T09:09:00.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>本文由我翻译在<a href="http://www.zcfy.cc/claim">众成</a>翻译平台，<a href="http://www.zcfy.cc/article/javascript-how-prototypal-inheritance-really-works-1337.html">文章地址</a></strong></p>
<p>在网上的很多地方我们可以得知javascript是基于原型链继承的，其实Javascript只提供一种特殊的方法来实现原型链继承，就是通过new操作。但是很多解读都令人难以理解，这篇文章旨在说明到底什么是原型链继承以及如何在Javascript中真正地运用它。<br><a id="more"></a></p>
<h3 id="原型链继承的定义"><a href="#原型链继承的定义" class="headerlink" title="原型链继承的定义"></a>原型链继承的定义</h3><p>当你读到有关于Javascript原型链继承的内容时，经常看到这样的定义：</p>
<blockquote>
<p>当对象存取一个属性时，Javascript会沿着原型链向上查询直到找到要存取的属性名（或原型链顶端）<a href="http://bonsaiden.github.com/JavaScript-Garden/#object.prototype">Javascript Garden</a></p>
</blockquote>
<p>许多Javascript实践运用 <a href="https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Object/proto"><strong>proto</strong></a> 属性来表示原型链上的下一个对象，我们会在下文看看__proto__和prototype之间有什么区别。</p>
<p><strong>提示</strong>: __proto__不是一种标准，不应该将它运用在你的实际代码里，它在文章只是用来解释Javascript如何实现继承。</p>
<p>下面的代码展示了javascript引擎是如何获取属性的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">function getProperty(obj, prop) &#123;</div><div class="line">  if (obj.hasOwnProperty(prop))</div><div class="line">    return obj[prop]</div><div class="line">  else if (obj.__proto__ !== null)</div><div class="line">    return getProperty(obj.__proto__, prop)</div><div class="line">  else</div><div class="line">    return undefined</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们举个通常的栗子：一个2D的点，一个点有两个坐标值x和y，以及一个print方法。</p>
<p>根据前面原型链继承的定义，我们将构造一个对象表示点，拥有三个属性x，y，print，为了创建一个新的点，我们只需要让新的对象的__proto__设为Point：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var Point = &#123;</div><div class="line">  x: 0,</div><div class="line">  y: 0,</div><div class="line">  print: function () &#123; console.log(this.x, this.y); &#125;</div><div class="line">&#125;;</div><div class="line">var p = &#123;x: 10, y: 20, __proto__: Point&#125;;</div><div class="line">p.print(); // 10 20</div></pre></td></tr></table></figure>
<h3 id="Javascript原型链继承的奇特之处"><a href="#Javascript原型链继承的奇特之处" class="headerlink" title="Javascript原型链继承的奇特之处"></a>Javascript原型链继承的奇特之处</h3><p>令人疑惑的是，每一个教别人Javascript原型链继承的人都不用上面的代码，他们会使用如下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">function Point(x, y) &#123;</div><div class="line">  this.x = x;</div><div class="line">  this.y = y;</div><div class="line">&#125;</div><div class="line">Point.prototype = &#123;</div><div class="line">  print: function () &#123; console.log(this.x, this.y); &#125;</div><div class="line">&#125;;</div><div class="line">var p = new Point(10, 20);</div><div class="line">p.print(); // 10 20</div></pre></td></tr></table></figure>
<p>这和之前的代码完全不同，Point是一个函数，用到prototype属性，new操作符，这是什么意思？</p>
<h4 id="new是如何运作的"><a href="#new是如何运作的" class="headerlink" title="new是如何运作的"></a>new是如何运作的</h4><p><a href="http://brendaneich.com/">Brendan Eich</a> 希望Javascript看起来更像传统的面向对象语言，比如Java 和C++，因此用new操作符来创建一个类的实例，于是他给Javascript添加了new操作符。</p>
<ul>
<li>C++中有关于构造的概念，是用来初始化实例属性，因此new操作符必须指向一个函数。</li>
<li>我们需要在一些地方用到对象的方法，由于我们使用的是一门原型语言，可将方法放在函数的原型属性上。</li>
</ul>
<p>new操作符创建函数F和参数arguments : new F(arguments…)，进行简单的三步操作：</p>
<ol>
<li><strong>创建一个实例</strong>，它是一个空对象，其__proto__属性被设为F.prototype。</li>
<li><strong>实例初始化</strong>，将函数F的参数传递到实例上，F的this(上下文)被设为指向实例。</li>
<li><strong>返回实例</strong>。</li>
</ol>
<p>现在我们明白new操作符做了什么，我们可以在Javascript中实践它。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">function New (f) &#123;</div><div class="line"> var n = &#123; &apos;__proto__&apos;: f.prototype &#125;;</div><div class="line"> return function () &#123;</div><div class="line">   f.apply(n, arguments);</div><div class="line">   return n;</div><div class="line"> &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>一个小测试看看它如何运行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">function Point(x, y) &#123;</div><div class="line">  this.x = x;</div><div class="line">  this.y = y;</div><div class="line">&#125;</div><div class="line">Point.prototype = &#123;</div><div class="line">  print: function () &#123; console.log(this.x, this.y); &#125;</div><div class="line">&#125;;</div><div class="line">var p1 = new Point(10, 20);</div><div class="line">p1.print(); // 10 20  </div><div class="line">console.log(p1 instanceof Point); // true    </div><div class="line">var p2 = New (Point)(10, 20);</div><div class="line">p2.print(); // 10 20</div><div class="line">console.log(p2 instanceof Point); // true</div></pre></td></tr></table></figure>
<h3 id="Javascript真正的原型链继承"><a href="#Javascript真正的原型链继承" class="headerlink" title="Javascript真正的原型链继承"></a>Javascript真正的原型链继承</h3><p>在<a href="http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-262.pdf">Javascript specifications</a> 只给了我们一种基于new操作符的实现方法 ,但是Douglas Crockford 还是找到一种利用new操作符实现原型继承的方法，他写了一个<a href="http://javascript.crockford.com/prototypal.html">Object.create</a>函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Object.create = function (parent) &#123;</div><div class="line">  function F() &#123;&#125;</div><div class="line">  F.prototype = parent;</div><div class="line">  return new F();</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这看起来非常奇怪，但它的原理其实非常简单。将创建的一个新对象的prototype属性设置为你想要继承的对象，如果允许使用__proto__，那么可以改写为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Object.create = function (parent) &#123;</div><div class="line">  return &#123; &apos;__proto__&apos;: parent &#125;;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>下面就是用真正的原型链继承来实现的Point例子的继承过程。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var Point = &#123;</div><div class="line">  x: 0,</div><div class="line">  y: 0,</div><div class="line">  print: function () &#123; console.log(this.x, this.y); &#125;</div><div class="line">&#125;;</div><div class="line">var p = Object.create(Point);</div><div class="line">p.x = 10;</div><div class="line">p.y = 20;</div><div class="line">p.print(); // 10 20</div></pre></td></tr></table></figure>
<h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>我们已经知道了什么是原型链继承以及Javascript怎样通过一种特殊的方式实现它。</p>
<p>但是，这种原型链继承方法(Object.create and __proto__) 有一些缺点：</p>
<ul>
<li><strong>没有标准</strong>: __proto__不是标准甚至是被反对的. 包括通用的Object.create和Douglas Crockford实践都没有确定的标准形式。</li>
<li><strong>没有优化</strong>: Object.create比起new操作方式显得更加笨重，这一点被证明于<a href="http://jsperf.com/object-create-vs-crockford-vs-jorge-vs-constructor/16">10 times slower</a>.</li>
</ul>
<h4 id="参考阅读："><a href="#参考阅读：" class="headerlink" title="参考阅读："></a>参考阅读：</h4><ul>
<li><a href="http://javascript.crockford.com/prototypal.html">Douglas Crockford: Prototypal Inheritance</a></li>
<li><a href="https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Object/proto">MDC Documentation: <strong>proto</strong></a></li>
<li><a href="http://ejohn.org/blog/objectgetprototypeof/">John Resig: getPrototypeOf</a></li>
<li><a href="http://bonsaiden.github.com/JavaScript-Garden/#object.prototype">Javascript Garden: Object.prototype</a></li>
<li><a href="http://dmitrysoshnikov.com/ecmascript/chapter-7-2-oop-ecmascript-implementation/">Dmitry Shoshnikov: OOP: ECMAScript Implementation</a></li>
<li><a href="http://javascriptweblog.wordpress.com/2010/06/07/understanding-javascript-prototypes/">Angus Croll: Understanding Javascript prototypes</a></li>
<li><a href="http://yehudakatz.com/2011/08/11/understanding-javascript-function-invocation-and-this/">Yehuda Katz: Understanding JavaScript Function Invocation and “this”</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      work
    
    </summary>
    
      <category term="学习感悟" scheme="http://shudery.cn/categories/%E5%AD%A6%E4%B9%A0%E6%84%9F%E6%82%9F/"/>
    
    
      <category term="JavaScript编程" scheme="http://shudery.cn/tags/JavaScript%E7%BC%96%E7%A8%8B/"/>
    
      <category term="翻译" scheme="http://shudery.cn/tags/%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>HTTP缓存及众多的web储存概念之小整理</title>
    <link href="http://shudery.cn/2016/08/12/%E5%AD%A6%E4%B9%A0%E6%84%9F%E6%82%9F/HTTP%E7%BC%93%E5%AD%98%E5%8F%8A%E4%BC%97%E5%A4%9A%E7%9A%84web%E5%82%A8%E5%AD%98%E6%A6%82%E5%BF%B5%E4%B9%8B%E5%B0%8F%E6%95%B4%E7%90%86/"/>
    <id>http://shudery.cn/2016/08/12/学习感悟/HTTP缓存及众多的web储存概念之小整理/</id>
    <published>2016-08-11T17:46:57.000Z</published>
    <updated>2016-11-30T07:42:17.000Z</updated>
    
    <content type="html"><![CDATA[<p>缓存对于一个网站来说非常重要，可以提高网站性能，减少冗余的数据传输，增加服务器负担，web存储则给浏览器提供了更加强大的保存文件的接口。<br>有相当一段时间一直混淆了HTTP缓存相关的属性，HTML5离线存储和本地储存的一些关系，最近好好地整理了一下这些Web存储相关的东西</p>
<p>先列出一些相关属性和概念，看看能否理清它们之间的区别和联系？<br><a id="more"></a></p>
<ul>
<li>manifest</li>
<li>cache-control</li>
<li>expires</li>
<li>304(no modified)</li>
<li>ETag</li>
<li>If-None-Match</li>
<li>Last-Modified</li>
<li>If-Modified-Since</li>
<li>http-equiv</li>
<li>webstorage</li>
<li>cookie/session</li>
</ul>
<p>是不是感觉有点凌乱，那就跟着我整理的笔记走一遍吧：）<br>首先说一说HTTP缓存相关的东西:<br>　　<br>　　<br><code>Cache-Control</code><br>每一个用HTTP请求的资源都可以在响应头用Cache-Control来给浏览器定义缓存策略，通过设置一些属性值它可以控制谁可以，在什么条件下可以缓存响应，还有缓存的有效期，这个属性的一些常用值如下</p>
<p><code>no-cache：</code>表示不使用缓存，先和服务器确认要返回的资源是否有修改<br><code>no-store：</code>表示禁止浏览器和所有中继缓存响应的资源<br><code>max-age=100：</code>表示缓存的有效期，单位是秒，这一段时间内，除非缓存文件发生一些变动，否则会直接使用之前的缓存，注意这段时间内是不会发Etag等方法去验证的资源有没有修改的。缓存的文件发生变动，主要有这些情况：资源名更改，资源地址更改，缓存被删除，网页强制刷新等；资源名更改，给文件名添加版本hash值，比如给image.png修改为image-hash.png，可以保证每次更新文件时用户可以重新发出请求，获取最新的资源。资源路径更改，修改文件的请求路径，比如给image.png添加查询参数修改为image.png?hash，max-age的时间设置根据每个网站的实际情况不同去设置，一种极端的做法是把这个值设置很大，然后通过修改资源名或者给资源请求地址添加查询参数，来告诉浏览器该更新资源了，一般用在很久才更新网站的情况<br><code>public：</code>用max-age即是默认public了，不用设置<br><code>private：</code>私人缓存，中继缓存不被允许，但是可以在浏览器缓存</p>
<p><code>PS：expires：</code>表示存在的时间，使客户端在这个设置的时间之前不用去请求资源，类似于max-age，但是expires表示的是一个固定时间，而且可能有服务器和客户端时间不一致的问题，主要用于HTTP1.0版本，在HTTP1.1版本完全可以用功能更强的Cache-Control来替代，和max-age同时存在时expiers会被覆盖掉<br><code>PS：http-equiv：</code>缓存有两种控制机制，一种是请求头信息控制，另外一种就是利用meta标签；可以在HTML文档中为meta标签设置http-equiv为相应属性名，content为值来设置缓存，例如<br><code>&lt;meta http-equiv=&quot;Expires&quot; content=&quot;Mon, 20 Jul 2009 23:00:00 GMT&quot; /&gt;</code>，不过只对改网页的HTML文件有缓存作用，对该页面的其他资源以及其他页面的HTML文件都没有作用<br>　　<br>　　<br>那么max-age（expires）到期之后，在no-cache下的资源会先和服务器确认返回的资源是否有修改，如何实现这一过程？<br><code>ETag/If-None-Match，Last-Modified/If-Modified-Since</code><br>ETag (Entity Tag)其实就是一个验证令牌，用来标识一个资源，可能是一个hash值，也可能是一个版本号，每当资源有修改的时候ETag的值就会改变<br>浏览器第一次请求之后会保存响应头的ETag值，以便下一次发送请求的时候校验Etag是否有更改。<br>　　<br>　　<br>那么下一次浏览器如何告诉服务器本地已经存有Etag和相应的资源了呢？If-None-Match<br>通过在请求头添加If-None-Match(如果存在ETag，浏览器会自动添加)，赋值为上一次请求后在本地存储的Etag值，服务器会和服务端最新资源的Etag比对，如果没有更改会直接返回304 no modified给浏览器，浏览器就直接使用本地缓存的文件</p>
<p><code>PS：Last-Modified/If-Modified-Since</code>的作用等同于<code>ETag/If-None-Match，</code>不过前者是通过规定一个时间来比对，最小的单位是秒，后者通过一个唯一标识符，所以可以看出来如果原站在一秒内有多次更新，那么前者就不顶用啦。<br>ETag的验证要优先于Last-Modified，此外ETag也是有缺点的，在分布式的环境中，Etag在不同服务器上的同步问题可能会给服务器带来一些压力。<br>　　<br>　　<br><code>HTTP缓存</code>是和每一个HTTP请求直接相关的，每一个请求资源的响应都有相应的缓存策略，它们往往是相似的，是否可以通过其他的机制，直接告诉浏览器去缓存哪一些文件呢？<br><code>HTML5离线存储</code>闪亮出场</p>
<p>H5离线存储：服务器通过一份.manifest文件给浏览器提供一份完备的缓存名单，名单包括需要缓存的文件，不需要缓存的文件的列表之外，还有一些其他的功能，比如给资源设置备选的请求地址，设置404页面等</p>
<p>实现：利用H5的标签新属性manifest，只需要在HTML文件添加<code>&lt;html manifest=&quot;test.manifest&quot;&gt;，</code>服务器则将manifest文件的mime-type设置为text/cache-manifest类型即可，浏览器每次请求会检查<code>manifest</code>是否有更新，服务端通过修改manifest文件，即可在浏览器下一次请求资源的时候通知其更新相应的资源。<br>作用：通过本地离线存储可以在没有网络的情况下访问网站事先保存的文件资源，在有网络的情况下直接使用本地资源也可以减少请求连接的压力，提高网页的加载速度，注意这里和HTTP缓存的区别，它是直接使用本地资源，请求返回的是200（from cache）,由于有manifest来统一管理，所以不需要发请求查看是否有更新，也没有过期时间。<br>　<br><code>PS：</code>这里关于manifest文件自身的更新问题，还是要走HTTP缓存，或者直接不缓存这个文件。<br>　　<br>　　<br>前面提到的概念主要都是缓存请求文件这一块的东西，它们的目的都是为了提高网页的性能，可以说是一种优化型的存储，可以给用户带来更流畅的体验<br>但是我们印象中还有一种存储，它可以给我们提供更多的可能和效果的实现，是功能型的存储，如H5本地储存<code>Webstorage，cookie，session</code><br>　　<br>　　<br><code>cookie，session</code><br>众所周知，HTTP是无状态的协议，每一次请求都是独立没有联系的，浏览器和服务器都没有办法维持用户的状态，判断用户是不是依然是之前的那个用户。<br>很容易可以想到，在同一个用户的每个请求头添加一个唯一标识符，通过判断这个标识符就可以维持用户的一些信息和状态<br>会话信息被用来作为标识符解决这个问题，cookie机制采用的是在客户端保持状态的方案，而session机制采用的是在服务器端保持状态的方案（服务端保持状态也需要客户端保持状态，所以一般session都要基础cookie或者sessionstorage）</p>
<p>总的来说：cookie数据放在客户端，session数据放在服务端，cookie可以设置期限，session则是关闭浏览器时销毁（cookie默认也是），cookie不安全，session可能会影响服务器性能</p>
<p><code>Cookie：</code>通常用Javascript封装一个setCookie的函数来创建，有大小限制，可能会导致请求头过于臃肿，浏览器发送请求时，检查本地cookie，如果该cookie声明的范围大于发送请求的url地址时，就会自动在请求上添加cookie字段</p>
<p><code>session：</code>服务器每次会检查浏览器请求头的session标识，如果有则将这个session id在服务器的数据库（散列表）查找，找到后才进行相应权限的操作<br>如果没有这个请求标识，则为客户端新建一个，返回给客户端后，客户端可以通过cookie或者sessionstorage来保存这个session id，通过请求头的cookie字段来给服务器提供sessionId，当cookie被禁止时就需要一些其他方法，通常是采用添加到url路径中，添加表单隐藏域等方法</p>
<p>cookie作为HTTP协议规范的一部分，主要还是用来储存用户信息的，用来和服务端交互，大小也有限制，仅仅只是一种会话级别的存储<br>　　<br>　　<br><code>localstorage，sessionstorage</code><br><code>webstorage</code>为了更大的存储文件设计，与Cookie负责记录用户信息相比，webStorage专注于本地存储，通过封装好的setItem，getItem等方法即可使用<br>localstorage是一种持久化的存储，除非主动删除，否则永远存在，sessionstorage主要用来存储会话（session），关闭浏览器就会销毁，是一种非持久化的存储<br>　　<br>　　<br>除了上面这些的概念之外，还有诸如像IndexDB，FileSystem等存储方法，关于Web存储的知识真的非常多，看上去坑也是不少，还需要实践慢慢来掌握。</p>
]]></content>
    
    <summary type="html">
    
      this is a article for my way of studying front-end
    
    </summary>
    
      <category term="学习感悟" scheme="http://shudery.cn/categories/%E5%AD%A6%E4%B9%A0%E6%84%9F%E6%82%9F/"/>
    
    
      <category term="web前端" scheme="http://shudery.cn/tags/web%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>ES5和ES6中对于继承的实现方法</title>
    <link href="http://shudery.cn/2016/07/23/%E5%AD%A6%E4%B9%A0%E6%84%9F%E6%82%9F/ES5%E5%92%8CES6%E4%B8%AD%E5%AF%B9%E4%BA%8E%E7%BB%A7%E6%89%BF%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95/"/>
    <id>http://shudery.cn/2016/07/23/学习感悟/ES5和ES6中对于继承的实现方法/</id>
    <published>2016-07-23T15:32:17.000Z</published>
    <updated>2017-03-14T09:08:47.000Z</updated>
    
    <content type="html"><![CDATA[<p>在ES5继承的实现非常有趣的，由于没有传统面向对象类的概念，Javascript利用原型链的特性来实现继承，这其中有很多的属性指向和需要注意的地方。<br>原型链的特点和实现已经在之前的一篇整理说过了，就是通过将子类构造函数的原型作为父类构造函数的实例，这样就连通了子类-子类原型-父类，原型链的特点就是逐层查找，从子类开始一直往上直到所有对象的原型Object.prototype，找到属性方法之后就会停止查找，所以下层的属性方法会覆盖上层。<br><a id="more"></a><br>一个基本的基于原型链的继承过程大概是这样的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">//先来个父类，带些属性</div><div class="line">function Super()&#123;</div><div class="line">    this.flag = true;</div><div class="line">&#125;</div><div class="line">//为了提高复用性，方法绑定在父类原型属性上</div><div class="line">Super.prototype.getFlag = function()&#123;</div><div class="line">    return this.flag;</div><div class="line">&#125;</div><div class="line">//来个子类</div><div class="line">function Sub()&#123;</div><div class="line">    this.subFlag = false;</div><div class="line">&#125;</div><div class="line">//实现继承</div><div class="line">Sub.prototype = new Super;</div><div class="line">//给子类添加子类特有的方法，注意顺序要在继承之后</div><div class="line">Sub.prototype.getSubFlag = function()&#123;</div><div class="line">    return this.subFlag;</div><div class="line">&#125;</div><div class="line">//构造实例</div><div class="line">var es5 = new Sub;</div></pre></td></tr></table></figure></p>
<p>原型链实现的继承主要有几个问题：<br>1、本来我们为了构造函数属性的封装私有性，方法的复用性，提倡将属性声明在构造函数内，而将方法绑定在原型对象上，但是现在子类的原型是父类的一个实例，自然父类的属性就变成子类原型的属性了；<br>这就会带来一个问题，我们知道构造函数的原型属性在所有构造的实例中是共享的，所以原型中属性的改变会反应到所有的实例上，这就违背了我们想要属性私有化的初衷；<br>2、创建子类的实例时，不能向父类的构造函数传递参数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">function Super()&#123;</div><div class="line">    this.flag = true;</div><div class="line">&#125;</div><div class="line">function Sub()&#123;</div><div class="line">   this.subFlag = false;</div><div class="line">&#125;</div><div class="line">Sub.prototype = new Super;</div><div class="line">var obj = new Sub();</div><div class="line">obj.flag = flase;  /* 修改之后，由于是原型上的属性，之后创建的所有实例都会受到影响 */</div><div class="line">var obj_2 = new Sub();</div><div class="line">console.log(obj.flag)  //false；</div></pre></td></tr></table></figure></p>
<p>为了解决以上两个问题，有一个叫借用构造函数的方法<br>只需要在子类构造函数内部使用apply或者call来调用父类的函数即可在实现属性继承的同时，又能传递参数，又能让实例不互相影响<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">function Super()&#123;</div><div class="line">    this.flag = true;</div><div class="line">&#125;</div><div class="line">function Sub()&#123;</div><div class="line">    Super.call(this);  /* 如果父类可以需要接收参数，这里也可以直接传递 */</div><div class="line">&#125;;</div><div class="line">var obj = new Sub();</div><div class="line">obj.flag = flase;</div><div class="line">var obj_2 = new Sub();</div><div class="line">console.log(obj_2.flag)  //依然是true，不会相互影响</div></pre></td></tr></table></figure></p>
<p>结合借用构造函数和原型链的方法，可以实现比较完美的继承方法，可以称为组合继承：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">function Super()&#123;</div><div class="line">    this.flag = true;</div><div class="line">&#125;</div><div class="line">Super.prototype.getFlag = function()&#123;</div><div class="line">    return this.flag;     /* 继承方法 */</div><div class="line">&#125;</div><div class="line">function Sub()&#123;</div><div class="line">    this.subFlag = flase</div><div class="line">    Super.call(this)    /* 继承属性 */</div><div class="line">&#125;</div><div class="line">Sub.prototype = new Super;</div><div class="line">var obj = new Sub();</div><div class="line">Super.prototype.getSubFlag = function()&#123;</div><div class="line">    return this.flag;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里还有个小问题，Sub.prototype = new Super;  会导致Sub.prototype的constructor指向Super;<br>然而constructor的定义是要指向原型属性对应的构造函数的，Sub.prototype是Sub构造函数的原型，所以应该添加一句纠正：<br>Sub.prototype.constructor = Sub;</p>
<p>看完ES5的实现，再来看看ES6的继承实现方法，其内部其实也是ES5组合继承的方式，通过call借用构造函数，在A类构造函数中调用相关属性，再用原型链的连接实现方法的继承<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">class B extends A &#123;</div><div class="line">  constructor() &#123;</div><div class="line">    return A.call(this);  //继承属性</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">A.prototype = new B;  //继承方法</div></pre></td></tr></table></figure></p>
<p>ES6封装了class，extends关键字来实现继承，内部的实现原理其实依然是基于上面所讲的原型链，不过进过一层封装后，Javascript的继承得以更加简洁优雅地实现<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">class ColorPoint extends Point &#123;</div><div class="line">  constructor(x, y, color) &#123;</div><div class="line">    super(x, y); /* 等同于parent.constructor(x, y) */</div><div class="line">    this.color = color;</div><div class="line">  &#125;</div><div class="line">  toString() &#123;</div><div class="line">    return this.color + &apos; &apos; + super.toString(); // 等同于parent.toString()</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>通过constructor来定义构造函数，用super调用父类的属性方法</p>
<p>ES6中Class充当了ES5中，构造函数在继承实现过程中的作用<br>同样有原型属性prototype，以及在ES5中用来指向构造函数原型的<code>__proto__</code>属性，这个属性在ES6中的指向有一些主动的修改。<br>一个继承语句同时存在两条继承链：一条实现属性继承，一条实现方法继承。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">class A extends B &#123;&#125;</div><div class="line">A.__proto__ === B;  /* 继承属性 */</div><div class="line">A.prototype.__proto__ === B.prototype;  //继承方法</div></pre></td></tr></table></figure></p>
<p>ES6的子类的<code>__proto__</code>是父类，子类的原型的<code>__proto__</code>是父类的原型<br>第二条继承链理解起来没有什么问题，对应到ES5中的A.prototype = new B;A.prototype作为B构造的实例，指向构造函数B的原型B.prototype，<br>但是在ES5中A.<code>__proto__</code>是指向Function.prototype的，因为每一个构造函数其实都是Function这个对象构造的，ES6中子类的<code>__proto__</code>指向父类可以实现属性的继承，在ES5中在没有用借用继承的时候由于父类属性被子类原型继承，所有的子类实例实际上都是同一个属性引用。<br>在ES6中实现了子类继承父类属性，在构造实例的时候会直接拿到子类的属性，不需要查找到原型属性上面去，ES6新的静态方法和静态属性（只能在构造函数上访问）也是通过这样类的直接继承来实现，至于普通复用方法还是放到原型链上，道理和实现和ES5是一样的。<br>此外我认为这里修改A.<code>__proto__</code>的指向是有意区分ES6中继承和实例化，同时建立子类和父类直接的关系，ES5的子类的构造函数通过子类的原型与父类的构造函数连接，不存在直接的关系；<br>可以这么说，在ES5继承和构造实例，ES6构造实例的时候可以理解<code>__proto__</code>原型指针是用来指向构造函数的原型的，但是在ES6继承中，<code>__proto__</code>指继承自哪个类或原型，在A继承B之后，构造一个实例 var obj = new A; 会发现它所有的属性指向都是和ES5一致的。</p>
<p>有个有趣的地方：ES6继承是在父类创建this对象，在子类constructor中来修饰父类的this，ES5是在子类创建this，将父类的属性方法绑定到子类，由于原生的构造函数（Function，Array等）没有this，子类无法通过call/apply(this)获得其内部属性，所以在ES5无法继承，ES6实现后可以为原生构造函数封装一些有趣的接口，比方说阮一峰老师的这个给Array实例封装一个版本记录和回滚的方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">class VersionedArray extends Array &#123;</div><div class="line">  constructor() &#123;</div><div class="line">    super();</div><div class="line">    this.history = [[]];</div><div class="line">  &#125;</div><div class="line">  commit() &#123;</div><div class="line">    this.history.push(this.slice());</div><div class="line">  &#125;</div><div class="line">  revert() &#123;</div><div class="line">    this.splice(0, this.length, ...this.history[this.history.length - 1]);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">var x = new VersionedArray();</div><div class="line">x.push(1);</div><div class="line">x.push(2);</div><div class="line">x // [1, 2]</div><div class="line">x.history // [[]]</div><div class="line">x.commit();</div><div class="line">x.history // [[], [1, 2]]</div><div class="line">x.push(3);</div><div class="line">x // [1, 2, 3]</div><div class="line">x.revert();</div><div class="line">x // [1, 2]</div></pre></td></tr></table></figure></p>
<p>JS继承小结：<br>ES5最经典的继承方法是用组合继承的方式，原型链继承方法，借用函数继承属性，ES6也是基于这样的方式，但是封装了更优雅简洁的api，让Javascript越来越强大，修改了一些属性指向，规范了继承的操作，区分开了继承实现和实例构造，此外ES6继承还能实现更多的继承需求和场景。</p>
]]></content>
    
    <summary type="html">
    
      develop cross-platform GUI app with electron
    
    </summary>
    
      <category term="学习感悟" scheme="http://shudery.cn/categories/%E5%AD%A6%E4%B9%A0%E6%84%9F%E6%82%9F/"/>
    
    
      <category term="记录" scheme="http://shudery.cn/tags/%E8%AE%B0%E5%BD%95/"/>
    
      <category term="JavaScript编程" scheme="http://shudery.cn/tags/JavaScript%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript关键概念理解之闭包</title>
    <link href="http://shudery.cn/2016/07/10/%E5%AD%A6%E4%B9%A0%E6%84%9F%E6%82%9F/JavaScript%E5%85%B3%E9%94%AE%E6%A6%82%E5%BF%B5%E7%90%86%E8%A7%A3%E4%B9%8B%E9%97%AD%E5%8C%85/"/>
    <id>http://shudery.cn/2016/07/10/学习感悟/JavaScript关键概念理解之闭包/</id>
    <published>2016-07-10T13:59:48.000Z</published>
    <updated>2017-03-14T09:12:22.000Z</updated>
    
    <content type="html"><![CDATA[<p>JavaScript作为一种多范式编程语言，和许多函数式编程语言一样拥有闭包的概念。<br>闭包是一个老生常谈的问题，前端面试必问，要理解闭包的原理，必须知道什么是词法作用域，理解词法作用域，又需要对Javascript另外两个关键概念的掌握和理解~</p>
<a id="more"></a>
<h4 id="执行环境和作用域链"><a href="#执行环境和作用域链" class="headerlink" title="执行环境和作用域链"></a>执行环境和作用域链</h4><p>执行环境：红宝书将执行环境称为Javascript这么编程语言最为重要的一个概念，一开始我是不服的，屌屌的闭包和原型链呢？后来一番整理，才发现原来闭包和原型链的实现都是依赖于执行环境。<br>执行环境定义了变量或者函数有权访问的数据，决定了它们各自的行为，每个执行环境拥有一个变量对象来保存环境中定义的所有变量和函数。<br>每个函数都有自己的执行环境，每次执行语句进入函数后，就会将相应函数的执行函数压入环境栈中，执行完函数之后就会弹出，将控制权交给原来的执行环境。</p>
<p>作用域链：作用域链用来保证执行环境中，对所有环境有权访问的变量或者函数的有序访问。每一个执行环境会为自身的变量对象创建一个作用域链，作用域的前端始终是当前执行环境的变量对象，会一直向外延伸到全局作用环境，执行环境查询变量和函数的顺序遵循从局部到全局，一旦找到就会停止查找。</p>
<p>执行环境和作用域是很多概念和一些实现方法的基础，在Javascript里，执行环境决定了访问的权限，作用域链决定了访问的顺序。</p>
<h4 id="闭包和词法作用域"><a href="#闭包和词法作用域" class="headerlink" title="闭包和词法作用域"></a>闭包和词法作用域</h4><p>闭包：闭包就是一个作用域内定义的一个函数，由于Javascript没有块级作用域，局部作用域的形成依赖于函数来实现，所以也可以说闭包是一个函数里定义的一个函数。由于闭包的一个作用就是用来访问其他函数作用域中的变量，所以它又有一种定义：闭包指有权访问另一个函数作用域中变量的一个函数。<br>先看一段代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">name = &apos;hi&apos;;</div><div class="line">function close()&#123;</div><div class="line">    name = &apos;hello&apos;;</div><div class="line">    return function sayName()&#123;</div><div class="line">        console.log(name)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">var sayName = close();</div><div class="line">sayName();</div></pre></td></tr></table></figure></p>
<p>词法作用域：在这段代码中console出来的是hello，也就是说sayName执行过程中的name值取得是close函数内部的Name，而不是外部全局环境的name；根据上面对执行环境的理解，当进入sayName这个函数之后，执行环境就由全局进入局部环境，注意到每次定义函数的同时就会生成该函数的执行环境，所以sayName是在哪里声明的，它的外部执行环境就是谁，在这里就是close这个函数的执行环境，再根据上面对作用域链的理解，sayName对于name变量的查询将到此为止，不会到全局去，所以name的值就是hello，而不是hi，简单的说，sayName这个函数所属的作用域是声明它的时候所在的作用域，而不是运行它的时候，高端地说，这就是Javascript的词法作用域。</p>
<p>依照作用域链的原理，本来全局执行环境是没有办法访问到局部执行环境的，但是由于词法作用域的原因，使得sayName这个闭包（全局环境）拥有了访问close内部name变量（局部环境）的能力。</p>
<h4 id="闭包和this关键字"><a href="#闭包和this关键字" class="headerlink" title="闭包和this关键字"></a>闭包和this关键字</h4><p>闭包经常会和this关键字配合使用，每个函数在被调用的时候都会自动获得两个特殊变量，一个是arguments，另一个就是this，所以在一些多层嵌套return的闭包中，无法同过this来正确获得外层的this，因为作用域链在最里层的函数找到this后就停止了，所以一般都需要用一个中间变量来存储或者用bind方法绑定外层的this指向<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">var name = &apos;hi&apos;;</div><div class="line">var obj = &#123;</div><div class="line">    name:&apos;hello&apos;;</div><div class="line">    getName:function()&#123;</div><div class="line">        //var that = this;</div><div class="line">        return function()&#123;</div><div class="line">            return this.name;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>关于this的指向问题，只需要认准this当前所在函数的调用方式即可，当函数作为一个对象的方法调用时，this指向为这个对象，当作为一个函数调用时，this在非严格模式下指向全局，严格模式下返回undefined</p>
<p>闭包的作用：<br>特权方法：通过上面的闭包的概念理解，已经可以知道闭包的一个作用就是作为一个公有方法用来访问私有变量的，有权访问私有变量和函数的公有方法也叫做特权方法；Javascript中虽然没有传统面向对象中的类，也没有私有成员的概念，不过对于一个函数而言，其函数参数，内部声明的变量或者函数就是私有的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">function Person()&#123;</div><div class="line">    var name = &apos;daguo&apos;;</div><div class="line">    var getAge  = function()&#123;</div><div class="line">        return console.log(&apos;22&apos;);</div><div class="line">    &#125;</div><div class="line">    this.publicMethod = function()&#123;</div><div class="line">        console.log(name)</div><div class="line">        return getAge()</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>保留变量：通常函数的作用域和其所有变量会在函数执行结束之后就销毁，但是当这个函数返回一个闭包时，只要闭包还存在，那么声明闭包的这个作用域内的变量就不会被销毁，原因就是闭包依然保有对这些变量的引用，使它们不会被JS垃圾回收标记清除。这是一个可以利用的地方，也可能是一个造成内存泄漏的原因。所以不能过多创建闭包</p>
]]></content>
    
    <summary type="html">
    
      none
    
    </summary>
    
      <category term="学习感悟" scheme="http://shudery.cn/categories/%E5%AD%A6%E4%B9%A0%E6%84%9F%E6%82%9F/"/>
    
    
      <category term="JavaScript编程" scheme="http://shudery.cn/tags/JavaScript%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Javascript开发跨平台桌面app</title>
    <link href="http://shudery.cn/2016/06/23/%E7%A8%8B%E5%BA%8F%E5%91%98/Javascript%E5%BC%80%E5%8F%91%E8%B7%A8%E5%B9%B3%E5%8F%B0%E6%A1%8C%E9%9D%A2app/"/>
    <id>http://shudery.cn/2016/06/23/程序员/Javascript开发跨平台桌面app/</id>
    <published>2016-06-23T15:32:17.000Z</published>
    <updated>2017-03-14T09:09:26.000Z</updated>
    
    <content type="html"><![CDATA[<p>electron原本是atom shell的项目，由于集成node丰富的本地系统级API，<br>提供了与操作系统交互的功能，所以归结起来，现在javascrpit的技术栈之所以如此宽广，<br>要得益于NodeJS将其中浏览器的环境中分离出来</p>
<p>不过需要特别说明的是，这里生成的桌面应用，<br>实际上是Electron生成的一个由Javascrpit控制管理的迷你浏览器Chromeinum，<br>它其实是一个Chrome浏览器的试验版本，当然用的也是V8的内核<br><a id="more"></a><br>不管怎么说，这对于喜欢前端，熟悉javascript的同学来说，<br>能够用前端和一点后台的知识去接触，尝试各种不同的领域，实在是不要太爽</p>
<p>Electron的入门也符合前端知识领域的特点，几乎没有门槛，<br>只要你有一点JS和Node的基础就行了，开发目录的文件层次结构也很简单，<br>后面会有打包工具帮助我们一键打包生成层次比较复杂的项目文件，<br>作为桌面GUI应用，当然也包括.exe的启动文件，</p>
<p>让我们看看如何开发一个桌面应用，或者说一个能和操作本地系统的web页面的基本方法~<br>你可以跟着步骤完成一些基本的文件，也可以直接下载<a href="https://github.com/shudery/electron/archive/master.zip">快速开始的demo</a><br>基本的文件层次很简单，用app存放一个具体的桌面应用，具体结构是这样的</p>
<p><img src="https://raw.githubusercontent.com/shudery/public/master/Pictures/article/GUI_1.png" alt=""></p>
<p>OutApp用来存放打包输出的exe文件<br>至于为什么有两个<code>package.json</code>文件，后面打包操作时你就知道了</p>
<h3 id="1、首先安装electron"><a href="#1、首先安装electron" class="headerlink" title="1、首先安装electron"></a>1、首先安装electron</h3><p>命令行进入根目录，先用npm安装electron，如果还没有就先<a href="https://nodejs.org/en/">安装node</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install -g electron-prebuilt</div></pre></td></tr></table></figure></p>
<h3 id="2、生成package-json配置文件"><a href="#2、生成package-json配置文件" class="headerlink" title="2、生成package.json配置文件"></a>2、生成<code>package.json</code>配置文件</h3><p>运行<code>npm init</code> 生成一个<code>package.json</code>文件来存放应用的相关配置，这个是第一个<code>package.json</code>文件，位于外层根目录下的，运行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install --save-dev electron-prebuilt</div></pre></td></tr></table></figure></p>
<p>会在devDependencies中生成依赖信息，方便后面打包<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  &quot;name&quot;: &quot;firstGUI&quot;,</div><div class="line">  &quot;version&quot;: &quot;1.0.0&quot;,</div><div class="line">  &quot;main&quot;: &quot;app/main.js&quot;,//js入口文件</div><div class="line">  &quot;scripts&quot;: &#123;</div><div class="line">    &quot;build&quot;: &quot;electron-packager ./app firstApp --platform=win32 --arch=x64 --out ./OutApp --version 0.37.3 --overwrite --icon=./app/img/daguo. jpg&quot;,</div><div class="line">    //打包命令，后面打包可以简化代码</div><div class="line">  &#125;,</div><div class="line">  &quot;devDependencies&quot;: &#123;</div><div class="line">    &quot;electron-prebuilt&quot;: &quot;^1.2.0&quot;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="3、新建main-js"><a href="#3、新建main-js" class="headerlink" title="3、新建main.js"></a>3、新建main.js</h3><p>生成一个入口的js文件来作为控制GUI窗口的主进程程序</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">const electron = require(&apos;electron&apos;);</div><div class="line">const &#123;app&#125; = electron;</div><div class="line">// 创建本地浏览器窗口的模块</div><div class="line">const &#123;BrowserWindow&#125; = electron;</div><div class="line">let win;</div><div class="line">function createWindow() &#123;</div><div class="line">  win = new BrowserWindow(&#123; width: 360, height: 572 &#125;);</div><div class="line">  win.loadURL(&apos;file://&apos;+__dirname+&apos;/html/index.html&apos;);</div><div class="line">  win.on(&apos;closed&apos;, () =&gt; &#123;</div><div class="line">  // 存放窗口对象，在窗口关闭的时候应当删除相应的元素。</div><div class="line">  win = null;</div><div class="line">  &#125;);</div><div class="line">&#125;</div><div class="line">app.on(&apos;ready&apos;, createWindow);</div><div class="line">// 当所有的窗口被关闭后退出应用</div><div class="line">app.on(&apos;window-all-closed&apos;, () =&gt; &#123;</div><div class="line">  if (process.platform !== &apos;darwin&apos;) &#123;</div><div class="line">    app.quit();</div><div class="line">  &#125;</div><div class="line">&#125;);</div><div class="line">app.on(&apos;activate&apos;, () =&gt; &#123;</div><div class="line">  if (win === null) &#123;</div><div class="line">    createWindow();</div><div class="line">  &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>在这个文件后面你可以直接包含你应用特定的由主进程运行的代码，也可以把这些代码放在另一个文件中然后在这里导入。</p>
<h3 id="4、index-html"><a href="#4、index-html" class="headerlink" title="4、index.html"></a>4、index.html</h3><p>GUI窗口（web页面）渲染的Html文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&lt;!DOCTYPE html&gt;</div><div class="line">&lt;html&gt;</div><div class="line">  &lt;head&gt;</div><div class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</div><div class="line">    &lt;title&gt;firstGUI&lt;/title&gt;</div><div class="line">  &lt;/head&gt;</div><div class="line">  &lt;body&gt;</div><div class="line">    &lt;h1 style=&gt;Hello World!&lt;/h1&gt;</div><div class="line">  &lt;/body&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure></p>
<h3 id="5、运行桌面app"><a href="#5、运行桌面app" class="headerlink" title="5、运行桌面app"></a>5、运行桌面app</h3><p>大公告成，没错就是如此之快，运行<code>electron .</code>（跟一个空格和小点），或者<code>electron app/main</code><br>打开制作好的GUI界面，so cool~</p>
<p><img src="https://raw.githubusercontent.com/shudery/public/master/Pictures/article/GUI_2.png" alt=""></p>
<h3 id="6、进行打包"><a href="#6、进行打包" class="headerlink" title="6、进行打包"></a>6、进行打包</h3><p>既然是桌面应用，那肯定是要一键运行的，不需要安装什么依赖模块，<br>也不需要运行命令行程序的，所以为了提升逼格，让更多的人可以方便实用你的桌面app，<br>需要对app文件夹进行打包，安装打包程序 <code>electron-packager</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install --save-dev electron-packager</div></pre></td></tr></table></figure></p>
<p>打包的基本命令是<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">electron-packager &lt;location of project&gt; &lt;name of project&gt; &lt;platform&gt; &lt;architecture&gt; &lt;electron version&gt;&lt;optional options&gt;</div></pre></td></tr></table></figure></p>
<p>上面已经在<code>package.json</code>的script里配置了简化的命令，可以根据自身情况对名称，操作系统，应用图标进行修改，<br>注意啦开始打包前，一定要复制一份<code>package.json</code>到app文件，<br>前面说了桌面应用不用下载依赖，其实是因为打包的时候就将依赖一同打包到文件包里了，<br>所以我们要打包app文件夹下的文件，需要一个<code>package.json</code>  来说明依赖项，注意修改里面的路径，要往下一级，然后运行<code>npm packager</code></p>
<p><img src="https://raw.githubusercontent.com/shudery/public/master/Pictures/article/GUI_3.png" alt=""></p>
<p>完成打包后可以看到OutApp里头已经有了相应的文件，<br>运行里面的exe文件会生成和本地测试时一样的GUI窗口~</p>
<p>一个简单的基于前端技术栈的桌面app算是完成了，后续的asar文件加密，<br>用nsis制作一个安装引导等等~有兴趣的可以继续完善~</p>
<p>一个桌面级app当然不是用来显示<code>hello world</code>的，那样和web页面有什么区别，<br>这里只是我入门的一个学习记录，一个基于electron的桌面应用<br>还有着非常丰富的与系统交互功能可以设计和开发~<br>更加详细的用法和配置有兴趣的同学不妨看看官方的<a href="http://electron.atom.io/">api演示文档</a>，<br>它也是一个基于electron做的桌面app</p>
]]></content>
    
    <summary type="html">
    
      develop cross-platform GUI app with electron
    
    </summary>
    
      <category term="程序员" scheme="http://shudery.cn/categories/%E7%A8%8B%E5%BA%8F%E5%91%98/"/>
    
    
      <category term="JavaScript编程" scheme="http://shudery.cn/tags/JavaScript%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>chrome扩展程序入门手记</title>
    <link href="http://shudery.cn/2016/06/14/%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/chrome%E6%89%A9%E5%B1%95%E7%A8%8B%E5%BA%8F%E5%85%A5%E9%97%A8%E6%89%8B%E8%AE%B0/"/>
    <id>http://shudery.cn/2016/06/14/方法总结/chrome扩展程序入门手记/</id>
    <published>2016-06-14T15:08:15.000Z</published>
    <updated>2016-11-30T07:41:33.000Z</updated>
    
    <content type="html"><![CDATA[<p>chrome是我非常喜欢的浏览器，它除了速度飞快，对前端代码支持友好的优点外，<br>还有非常丰富的扩展程序资源，提供了大量方便强大的web页面应用插件<br>这两天由于朋友的业务需求，接触了一些chrome扩展程序(即俗称插件)的有关代码<br>基于对谷歌开发者文档的学习，随手记录了写chrome插件的基本方法~<br><a id="more"></a><br>每一个基本的Chrome插件,首先都有一个manifest.json<br>的配置文件用来存储插件的基本信息 </p>
<p><code>&quot;manifest_version&quot;: 2,
  &quot;name&quot;: &quot;Getting started example&quot;,
  &quot;description&quot;: &quot;This extension shows a Google Image search result for the current page&quot;,
  &quot;version&quot;: &quot;1.0&quot;</code></p>
<p>包括manifest的版本，扩展插件的名字，描述，版本</p>
<p>弹窗页面的信息browser_action, 在里面配置一个插件弹窗html页面代码，一般名字是popup.html，<br>浏览器界面显示的扩展图标位置，以及鼠标hover的title</p>
<p><code>&quot;browser_action&quot;: {
    &quot;default_icon&quot;: &quot;images/icon.png&quot;,
    &quot;default_popup&quot;: &quot;popup.html&quot;,
    &quot;default_title&quot;: &quot;Click here!&quot;
  }</code></p>
<p>可选的页面注入代码，一般名字是contentscript.js，<br>可选多个文件，匹配页面的matches，只对匹配到的注入代码</p>
<p><code>&quot;content_scripts&quot;: [{
    &quot;js&quot;: [&quot;jquery.min.js&quot;, &quot;contentscript.js&quot;],
    &quot;matches&quot;: [&quot;http://*/*&quot;,&quot;https://*/*&quot;]
  }]</code></p>
<p>还有插件要求的权限和要使用该插件的网页的匹配</p>
<p><code>&quot;permissions&quot;: [
    &quot;tabs&quot;,
    &quot;http://*/&quot;
  ]</code></p>
<p>关于manifest的更多字段配置信息，可以查看360翻译谷歌的<a href="http://open.chrome.360.cn/extension_dev/manifest.html">开发者文档</a></p>
<p>从上面的配置可以看到，一个简单插件除了有manifest之外<br>还有一个browser_action, 即popup.html来渲染点击插件之后的弹窗页面，<br>这个页面可以分离出来popup.js popup.css等文件，<br>这些文件可以放在同一个根目录下，文件中的引用跟普通项目一致可以取相对路径</p>
<p>如果要实现与浏览器打开页面的交互就必须还有一个注入脚本文件，<br>一般取名contentscript.js，弹窗页面popup page通过相应api实现和注入脚本的交互<br>再由注入脚本实现对web page的交互<br>在popup page（popup.js）中的输入代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">chrome.tabs.query(&#123;</div><div class="line">      active: true</div><div class="line">    &#125;, function(tab) &#123;</div><div class="line">       var data = &apos;&apos;;</div><div class="line">        //要传递给注入脚本文件的信息</div><div class="line">      chrome.tabs.sendMessage(tab[0].id, &apos;hello, content script, from background page. there are some data:&apos; + data);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>第二个参数为发送的信息，在注入脚本中通过request参数拿到<br>在contentscript.js中输入以下代码，开启对popup.js的信息发送监听，拿到信息request</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">chrome.extension.onMessage.addListener(function(request) &#123;</div><div class="line">  //request是popup page传来的信息</div><div class="line">   console.log(&apos;get the message from popup.js&apos;+request)</div><div class="line">   //收到popup page的信息后要做的事情</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>注入脚本contentscript.js和浏览器打开的网页脚本web page运行在不同的环境之下，<br>所以他们的变量名和全局对象不会有冲突，<br>但是他们共享一个DOM树，也就是可以通过修改注入脚本的DOM结构来改变页面的DOM，<br>这也就是注入脚本同web page交互的方式</p>
<p>最后贴一个我练手写的一个<a href="https://github.com/shudery/daguoNote">chrome插件</a>，<br>实现简单的便签功能，界面用amazeUI做的，<br>用React渲染，后台处理用Express搭建，数据结果直接保存一份JSON文件来管理</p>
]]></content>
    
    <summary type="html">
    
      share my record after learning how to build a plugin for chrome.
    
    </summary>
    
      <category term="方法总结" scheme="http://shudery.cn/categories/%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="记录" scheme="http://shudery.cn/tags/%E8%AE%B0%E5%BD%95/"/>
    
      <category term="web前端" scheme="http://shudery.cn/tags/web%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>搭建属于自己的vpn服务器</title>
    <link href="http://shudery.cn/2016/06/10/%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/%E5%A6%82%E4%BD%95%E6%90%AD%E5%BB%BA%E5%B1%9E%E4%BA%8E%E8%87%AA%E5%B7%B1%E7%9A%84vps%20vpn%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <id>http://shudery.cn/2016/06/10/方法总结/如何搭建属于自己的vps vpn服务器/</id>
    <published>2016-06-10T13:59:48.000Z</published>
    <updated>2016-11-30T07:41:41.000Z</updated>
    
    <content type="html"><![CDATA[<p>之前实习的时候想着有需要翻墙的时候用着公司的vpn就足够了<br>但是随着马上要去工作，还有对一些国外资源的需求（资源你懂的）<br>然后也前后被一些网上的vpn服务商坑过（各种掉线，不稳定）<br>决定自己租用一台国外的服务器vps<br><a id="more"></a><br>了解一番后知道了国外<a href="http://bandwagonhost.com/">搬瓦工</a>和<a href="www.digitalocean.com/?refcode=3491087221da">digital ocean</a>都有不错的口碑，最终选择DO,<br>最便宜的512MB内存，20GB固态硬盘，1TB流量，</p>
<p>这个好像只是防止恶意使用的，实际上流量是用不完的，<br>在服务器控制版面也没有流量使用情况提示<br>首先注册账号，输入邮箱密码，在邮箱收到确认邮件，<br>来到Payment Methods </p>
<p><img src="https://raw.githubusercontent.com/shudery/public/master/Pictures/article/vpn_1.png" alt=""></p>
<p>这一项我选择的是方便快捷的PayPal，Credit不好设置<br>需要预充5刀PayPal，5刀也是最便宜的服务器的月租价格，<br>如果没有PayPal的话就先注册一次，比这个Credit方便多了<br>注意一些老旧的银联卡号可能提示设置错误，我换了一张卡就好了</p>
<p>然后开始选择服务器，包括价格，地点，系统，<br>我选了最便宜已经够用了的5刀/月，ping后较快的美国西部服务器，<br>以及比较容易操作的ubuntu系统，然后添加主机的SSH密钥，以后方便，</p>
<p>不过也可以先跳过以后再说，买后会收到邮件，<br>得到一个服务器主机Ip，root账户名，以及一个初始密码。<br>vps算是有了，接下来我们在这台服务器上搭建vpn</p>
<p>然后不得吐槽的是网页的console控制台实在有点卡卡，<br>所以我用简单的putty来建立与vps的链接，也可以使用xshell等工具，<br>下载putty后直接输入ip地址，保留默认端口，点击open就进入控制台了</p>
<p>然后输入你的用户名root，然后出现password输入密码，<br>这里注意啦~输入密码的时候，光标是不会动的！<br>所以，慢慢输入，不要输错了，登录成功后显示一些信息</p>
<p><img src="https://raw.githubusercontent.com/shudery/public/master/Pictures/article/vpn_2.png" alt=""></p>
<p>第一次登陆要求重置密码，分别填一次旧密码和两次新密码，注意光标还是不会移动！<br>然后开始一列Linux操作，作为小白的我们就只管输入代码即可，<br>不过我们也是有(yao)追(zhuan)求(bi)的小白，所以也要大概知道这些代码是个什么作用</p>
<h3 id="1、安装vpn服务"><a href="#1、安装vpn服务" class="headerlink" title="1、安装vpn服务"></a>1、安装vpn服务</h3><p>首先我们必须在vps服务器上安装一种vpn服务，这里选择点对点隧道协议pptp,输入</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">apt-get install pptpd</div></pre></td></tr></table></figure>
<h3 id="2、配置文件修改"><a href="#2、配置文件修改" class="headerlink" title="2、配置文件修改"></a>2、配置文件修改</h3><p>用vi编辑器打开配置文件，输入</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">vi /etc/pptpd.conf</div></pre></td></tr></table></figure>
<p>没用过vi的注意啦，要编辑文件必须先输入i，进入INSERT模式，<br>将光标移动到最下面更改</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">localip 10.0.0.1</div><div class="line">remoteip 10.0.0.100-200</div></pre></td></tr></table></figure>
<p>有两段，localip更改为你vps服务器的ip地址，remoteip是以后分配给<br>其他连到你vpn的服务器的ip，可以照着例子分配，写完后保存，<br>vi的文件保存方法是先按Esc然后输入冒号:wq即可，w是写入保存，q是退出vi</p>
<h3 id="3、添加vpn账号"><a href="#3、添加vpn账号" class="headerlink" title="3、添加vpn账号"></a>3、添加vpn账号</h3><p>用vi打开密钥文件，输入</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">vi /etc/ppp/chap-secrets</div></pre></td></tr></table></figure>
<p>依次输入 username pptpd password ###<br>将username, password更换为你的vpn账号和密码，中间是服务名，<br>最后一个是ip通配符，如果要建立多个vpn账号给妹子基友一起用，<br>还一行依次输入即可，输完同样保存</p>
<h3 id="4、设置公共DNS服务，输入"><a href="#4、设置公共DNS服务，输入" class="headerlink" title="4、设置公共DNS服务，输入"></a>4、设置公共DNS服务，输入</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">vi /etc/ppp/pptpd-options</div></pre></td></tr></table></figure>
<p>打开服务选项文件设置找到ms-dns并设置为<br><code>ms-dns 8.8.8.8
ms-dns 8.8.4.4</code></p>
<h3 id="5、重启pptp服务，"><a href="#5、重启pptp服务，" class="headerlink" title="5、重启pptp服务，"></a>5、重启pptp服务，</h3><p>重启服务，刷新配置，输入</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">service pptpd restart</div></pre></td></tr></table></figure>
<h3 id="6、ip转发配置"><a href="#6、ip转发配置" class="headerlink" title="6、ip转发配置"></a>6、ip转发配置</h3><p>打开转发配置文件，输入</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">vi /etc/sysctl.conf</div></pre></td></tr></table></figure>
<p>发现整个文件都带有注释符#,去掉<code># net.ipv4.ip_forward = 1</code><br>前面的注释符#保存,为了使配置生效还需运行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sysctl -p</div></pre></td></tr></table></figure>
<h3 id="7、设置iptables"><a href="#7、设置iptables" class="headerlink" title="7、设置iptables"></a>7、设置iptables</h3><p>设置并保存，运行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE &amp;&amp; iptables-save</div></pre></td></tr></table></figure>
<p>至此搭建好属于你自己的vpn，拿着账号在手机和电脑的vpn设置登录即可<br>注意如果出现vpn隧道协议构建失败，检查一下网络适配器里vpn的安全属性<br>勾选为以下选项</p>
<p><img src="https://raw.githubusercontent.com/shudery/public/master/Pictures/article/vpn_3.jpg" alt=""></p>
]]></content>
    
    <summary type="html">
    
      how to build vpn or vps by youself
    
    </summary>
    
      <category term="方法总结" scheme="http://shudery.cn/categories/%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="记录" scheme="http://shudery.cn/tags/%E8%AE%B0%E5%BD%95/"/>
    
      <category term="工具" scheme="http://shudery.cn/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>用hexo搭建一个博客</title>
    <link href="http://shudery.cn/2016/05/05/%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/%E7%94%A8hexo%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%8D%9A%E5%AE%A2/"/>
    <id>http://shudery.cn/2016/05/05/方法总结/用hexo搭建一个博客/</id>
    <published>2016-05-05T04:00:33.000Z</published>
    <updated>2016-11-30T07:41:45.000Z</updated>
    
    <content type="html"><![CDATA[<p>hexo出自一位台湾大学生之手，是如今搭建，管理博客，发布文章的非常好用的工具，<br>之前一直想搭建一个不依赖后台，便于管理和发布的博客，在朋友推荐下用了hexo<br>确实是简单粗暴好用~<br>基于hexo的博客搭建，对于已经配备了Node环境和git的前端开发人士，<br>搭建出一个博客那就是分分钟的事情，即使还没有弄好这些也不难搭建，<br>下面就从头大致说一说搭建的流程。<br><a id="more"></a></p>
<h3 id="创建一个github账号和博客"><a href="#创建一个github账号和博客" class="headerlink" title="创建一个github账号和博客"></a>创建一个github账号和博客</h3><p>hexo搭建的博客是一个静态页面，可以直接托放到github上面的服务器上，<br>不需要拥有自己的服务器，所以我们要先有一个github账号，<br>然后需要生成一个github的博客，之后我们用自己定制的hexo博客来替换它，<br>如何搭建github技术博客可以看看这篇:<a href="http://blog.csdn.net/renfufei/article/details/37725057/">创建GitHub技术博客全攻略</a></p>
<h3 id="搭建Node环境"><a href="#搭建Node环境" class="headerlink" title="搭建Node环境"></a>搭建Node环境</h3><p>我们还需要一个运行hexo和调试的环境，就是用Nodejs，<br>在<a href="https://nodejs.org/en/">官网地址</a>选一个稳定版或者开发版一键安装好环境。</p>
<h3 id="安装Hexo，生成文章"><a href="#安装Hexo，生成文章" class="headerlink" title="安装Hexo，生成文章"></a>安装Hexo，生成文章</h3><p>准备好nodejs之后打开命令行使用Node的包管理工具npm,直接在命令行运行<br><code>npm install -g hexo</code></p>
<p>下载hexo，然后再在相应的目录运行<br><code>hexo init</code></p>
<p>即可一键生成文件结构，你可以看到在source/_posts里面有一篇默认的helloworld.md文章，<br>在themes里面有一个默认的主题landscape，再继续运行<br><code>hexo generate</code></p>
<h3 id="调试，部署到git"><a href="#调试，部署到git" class="headerlink" title="调试，部署到git"></a>调试，部署到git</h3><p>上面过程之后即可生成一个Public文件，里面会有你的文章内容，然后就可以运行<br><code>hexo server</code></p>
<p>启动localhost:4000，在浏览器输入地址就可以看到你的博客效果了，<br>如果你对默认的配置都满意的话下一步就是运行<br><code>hexo deploy</code></p>
<p>将内容部署到github上面去了，但是我们好像还没有建立hexo和我们账号github仓库的链接，<br>所以要在_config.yml最下面进行一些配置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">deploy:</div><div class="line">  type: git</div><div class="line">  repo: git@github.com:shudery/shudery.github.io.git # 换成你的博客仓库地址</div><div class="line">  branch: master</div></pre></td></tr></table></figure></p>
<p>然后再hexo deploy即可完成部署，注意用ssh地址可以免去输入密码的繁琐，<br>当然前提是要先生成ssh密钥，并且在你的github上面添加这个ssh密钥~<br>hexo博客就已经搭建完成，可以在shudery.github.io上面看到博客页面和文章效果</p>
<h3 id="添加文章，更换主题，修改配置"><a href="#添加文章，更换主题，修改配置" class="headerlink" title="添加文章，更换主题，修改配置"></a>添加文章，更换主题，修改配置</h3><p>基本的东西就是这样，接下来我们可以在_posts里面以markdown的写作形式写文章，<br>然后通过同样的方式生成，部署，可以直接在_posts里新建md文件，<br>也可以用运行<br><code>hexo new [fileStyle] [fileName]</code></p>
<p>的方式来生成文件，后者会以scaffolds中对应的fileStyle的形式，<br>给你生成一个fileName的md文件，里面会包括一些开头的默认字段，<br>会方便记录一些文章的信息，我们还可以在<a href="https://hexo.io/themes/">官网主题</a>里找一个更加符合心意的主题，<br>然后直接<code>git clone/ctrl+c</code> 到我们<code>hexo/themes</code>下面，<br>然后在<code>hexo/_config.yml</code>中的 <code>theme:landscape</code> 改为你下载好的主题名，<br>然后你会发现主题文件夹里还有一个<code>_config.yml</code> 用来修改主题的一些相关配置，<br>你可以参考你下载主题的github,或者官网的介绍来设置这些配置~</p>
<p><strong>由于无法忍受github服务器的延迟，目前已经将git远程仓库改为<a href="http://coding.net">coding.net</a>了，这是一个国内的git仓库托管服务商，主要面向私密项目，和github一样同样有pages的博客搭建服务，只要在配置文件修改一下deploy地址即可</strong></p>
<h3 id="完善博客"><a href="#完善博客" class="headerlink" title="完善博客"></a>完善博客</h3><p>最后你可以根据自己的喜好和需求为博客添加一些你喜欢的挂件和工具，<br>我自己加了多说评论，百度统计，还有就是换了一个逼格高一点的域名，<br>通过添加CNAME域名解析，重定向到github.io的博客地址上面。</p>
<p>搭建过程中一些tips~</p>
<ul>
<li>hexo clean会清理缓存和Public文件夹一般是在hexo generate之前使用，但是不用没啥问题</li>
<li>hexo/_config.yml对于hexo非常重要，但是如果去掉_config.yml你会发现还是依然能运行各种命令</li>
<li>然而一般运行时报错都是config配置有问题，而且很不好定位，<br>所以可以注释掉config.yml里面你觉得应该不会导致报错的配置，然后再运行看结果，<br>重复几次就可以定位到问题了，这对一开始没有什么经验的人来说是一个可行的debug方法。</li>
<li>在做域名重定向的时候，域名解析的CNAME需要指向github.io，<br>此外还要在hexo/source下面也建立一个CNAME文件指向你的设置了重定向的域名地址才行</li>
</ul>
]]></content>
    
    <summary type="html">
    
      如何用hexo来搭建一个博客
    
    </summary>
    
      <category term="方法总结" scheme="http://shudery.cn/categories/%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="记录" scheme="http://shudery.cn/tags/%E8%AE%B0%E5%BD%95/"/>
    
      <category term="工具" scheme="http://shudery.cn/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>javaScript的对象构造和原型链继承</title>
    <link href="http://shudery.cn/2016/04/15/%E5%AD%A6%E4%B9%A0%E6%84%9F%E6%82%9F/javaScript%E7%9A%84%E5%8E%9F%E5%9E%8B%E9%93%BE%E5%8F%8A%E5%85%B6%E7%BB%A7%E6%89%BF/"/>
    <id>http://shudery.cn/2016/04/15/学习感悟/javaScript的原型链及其继承/</id>
    <published>2016-04-15T09:55:58.000Z</published>
    <updated>2017-03-14T09:09:03.000Z</updated>
    
    <content type="html"><![CDATA[<p>这两天仔细地学习了JS的创建对象以及继承的方法，结合红宝石书整理了下笔记。<br>（红宝石这里讲了非常多的模式，看第一遍觉得还蛮乱的）<br>Javascript作为一种动态的面向对象语言，本身却没有类的概念和方法，<br>在创建对象和继承方面有很多有趣的实现和方法<br><a id="more"></a></p>
<h2 id="1-原始绑定和字面量表示："><a href="#1-原始绑定和字面量表示：" class="headerlink" title="1.原始绑定和字面量表示："></a>1.原始绑定和字面量表示：</h2><p><strong>优点</strong>：简洁方便<br><strong>问题</strong>：使用对象字面量的方法创建的对象，若重复创建会产生大量的重复代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var o = new Object();</div><div class="line">o.name = &apos;shudery&apos;;</div><div class="line">o.skill = function()&#123;console.log(&apos;sayHello&apos;)&#125;;</div><div class="line">//这是比较老的方法，一般用下面这种简单粗暴的，直接字面量创建</div><div class="line">var obj = &#123;</div><div class="line">    sex = &apos;man&apos;,</div><div class="line">    skill = function()&#123;console.log(&apos;tucao&apos;)&#125; </div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="2-工厂模式："><a href="#2-工厂模式：" class="headerlink" title="2.工厂模式："></a>2.工厂模式：</h2><p>抽象创建具体对象的过程<br><strong>具体</strong>：用函数来封装对象，然后调用特定接口创建对象<br><strong>优点和问题</strong>：解决代码重复性的问题，但是没有解决对象识别问题<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">function createObj(name)&#123;</div><div class="line">    var obj= &#123;</div><div class="line">        name : name ,</div><div class="line">        skill : function()&#123;console.log(&apos;tucao&apos;)&#125;</div><div class="line">    &#125;;</div><div class="line">    return obj;</div><div class="line">&#125;</div><div class="line">var obj_1 = createObj(&apos;shudery&apos;);</div><div class="line">var obj_2 = createObj(&apos;Lin&apos;); </div><div class="line">//Object类型的对象</div></pre></td></tr></table></figure></p>
<h2 id="3-构造函数模式："><a href="#3-构造函数模式：" class="headerlink" title="3.构造函数模式："></a>3.构造函数模式：</h2><p>使用<code>new</code>操作符，没有显式创建对象<br><strong>优点</strong>：解决了代码识别问题，可以将它构造的实例标示为特定类型<br><strong>问题</strong>：多次复用的方法需要在每个实例上重新创建一遍，浪费内存<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">function Myobj(name)&#123;</div><div class="line">        this.name = name,</div><div class="line">        this.skill= function()&#123;console.log(&apos;tucao&apos;)&#125;   </div><div class="line">&#125;</div><div class="line">var obj_1 =  new Myobj(&apos;shudery&apos;);</div><div class="line">var obj_2 =  new Myobj(&apos;Lin&apos;);</div><div class="line">//对象类型名称为myObj，解决了识别的问题，用下面方法可以验证</div><div class="line">console.log(obj_1.constructor === Myobj &amp;&amp; obj_2 instanceof Myobj);//true</div></pre></td></tr></table></figure></p>
<p>这里如果怕遗漏new关键字，可以在<code>myObj</code>函数里头显示地返回一个对象，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">function Myobj(name)&#123;</div><div class="line">        var obj=&#123;&#125;;</div><div class="line">        obj.name=name,</div><div class="line">        obj.method= function()&#123;</div><div class="line">        console.log(&apos;tucao&apos;)</div><div class="line">         &#125;</div><div class="line">    return obj;</div><div class="line">&#125;</div><div class="line">var obj_1 = Myobj(&apos;shudery&apos;);</div><div class="line">var obj_2 = new Myobj(&apos;shudery&apos;);</div></pre></td></tr></table></figure></p>
<p>如果这么做<code>obj_1</code>的<code>constructor</code>指向的是<code>Object</code><br>这样就和工程模式一样不能识别对象，<br>但是功能上两个对象相同，这也被叫寄生构造函数模式，一般不用它<br>此外在构造函数模式下如果没有引用this和new，那就是稳妥构造函数模式，<br>一般用在安全的环境</p>
<h2 id="4-原型模式："><a href="#4-原型模式：" class="headerlink" title="4.原型模式："></a>4.原型模式：</h2><p>在构造函数模式下如果直接提取出方法函数到全局环境下，<br>在方法变多时容易污染命名空间，<br>此外不利于我们自定义的引用类型的封装。<br>我们可以用JS的一大特色原型属性来挂载属性方法。<br><strong>优点</strong>：我们可以将复用的方法绑定到每一个构造函数定义的原型属性prototype上来，这样所有的对象实例都可以共享这个挂在这个原型下的属性和方法。<br><strong>问题</strong>：实例失去本身的特点和封装，公用一套属性和方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">function Myobj()&#123;</div><div class="line">       </div><div class="line">&#125;</div><div class="line">Myobj.prototype.name =&apos;shudery&apos;;</div><div class="line">Myobj.prototype.age = &apos;22&apos;;</div><div class="line">Myobj.prototype.method = function()&#123;</div><div class="line">    console.log(&apos;tucao&apos;)</div><div class="line">&#125;</div><div class="line">var obj =  new Myobj();</div></pre></td></tr></table></figure></p>
<p>也可用对象字面量形式，不过要注意顺序，字面量的形式相当于重写整个对象，<br>构造函数原型的<code>constructor</code>属性（指向对象类型）会被重写为<code>Object</code>,<br>而不是<code>Myobj</code>了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">function Myobj()&#123;</div><div class="line">       </div><div class="line">&#125;</div><div class="line">var obj =  new Myobj();//先实例化</div><div class="line">Myobj.prototype=&#123;</div><div class="line">//重写后这个原型和Myobj这个构造函数就没有关系了</div><div class="line">    name: &apos;shudery&apos;,</div><div class="line">    age:&apos;22&apos;,</div><div class="line">    method : function()&#123;</div><div class="line">    console.log(&apos;tucao&apos;)</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line">obj.name;//undefined，联系被切断了</div></pre></td></tr></table></figure></p>
<p>如果在重写之后实例化一个对象，虽然还存在联系，<br>但是<code>obj</code>实例就不是<code>Myobj</code>类型了<br>不在乎对象识别问题的话，也可以直接这样重写，仍能调用obj.name等属性和方法</p>
<h2 id="5-终极模式：构造函数-原型模式"><a href="#5-终极模式：构造函数-原型模式" class="headerlink" title="5.终极模式：构造函数+原型模式"></a>5.终极模式：构造函数+原型模式</h2><p> 最为常用的创建对象的方式，结合两种模式的优点，<br> 实现对象属性的封装和对象方法的复用，<br>平衡了对象的独立性和多态复用节省内存的问题。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">function Myobj(name,age)&#123;</div><div class="line">    this.name =name;</div><div class="line">    this.age = age</div><div class="line">&#125;</div><div class="line">Myobj.prototype.method = function()&#123;</div><div class="line">    console.log(&apos;tucao&apos;)</div><div class="line">&#125;</div><div class="line">var obj =  new Myobj(&apos;shudery&apos;,22);</div></pre></td></tr></table></figure></p>
<p>如此一来对象就拥有自定义的属性和可共享复用的方法啦<br>有句话这样说，当我们把程序中变化的部分封装好之后，剩下的就是稳定可复用的了<br>这也是很多种设计模式里推崇的，放到创建对象的方法里也是一样的做法。</p>
<p>说完对象的创建，接下来是继承~<br>JS是没有类的关键字和概念的，它的继承是基于原型链的，类似上面的原型模式<br>我们先简单了解下原型链：</p>
<p><img src="https://raw.githubusercontent.com/shudery/public/master/clipboard.png" alt=""></p>
<p>每个构造函数都有一个原型对象，构造的实例有一个指向原型对象的指针，<br>如果我们把父类的实例赋值给原型对象，那么子类的原型对象就是父类的实例，<br>那么这个实例还是有一个指向父类原型的指针，<br>这些指针连起了子类和父类的实例（子类构造函数的原型），就是原型链。</p>
<p>对象的方法和属性会循着原型链进行访问，直到查找到相应的属性和方法名，<br>或者到达原型链的终点<code>Object.prototype</code>,这也就实现了继承</p>
]]></content>
    
    <summary type="html">
    
      javascript的对象构造和原型链继承
    
    </summary>
    
      <category term="学习感悟" scheme="http://shudery.cn/categories/%E5%AD%A6%E4%B9%A0%E6%84%9F%E6%82%9F/"/>
    
    
      <category term="JavaScript编程" scheme="http://shudery.cn/tags/JavaScript%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>说说最近的npm模块风波</title>
    <link href="http://shudery.cn/2016/04/04/%E9%9A%8F%E7%AC%94/%E8%AF%B4%E8%AF%B4%E6%9C%80%E8%BF%91npm%E6%A8%A1%E5%9D%97%E9%A3%8E%E6%B3%A2/"/>
    <id>http://shudery.cn/2016/04/04/随笔/说说最近npm模块风波/</id>
    <published>2016-04-04T09:53:38.000Z</published>
    <updated>2016-10-19T09:59:23.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近，前端圈子有件事闹得沸沸扬扬，有一个叫做<code>leftpad</code>的npm模块被作者撤下，<br>导致一系列引用该模板的项目出现问题。</p>
<p>其实本来大家对这件事的重点应该是关于NPM管理者对于模块作者著作权的保护不周上的，<br>但是可能由于这个模块的特殊性和他造成的影响之间的对比太强烈，<br>让大家都把注意力放到了这个模块本身和引用这个模块的做法上来了。<br><a id="more"></a><br><strong>这个模块只有短短十一行，仅仅实现一个简单的字符串左侧填充的功能！</strong></p>
<p>如此简单的模块为什么那么多项目都要引用他呢？<br>其实如果不出现作者<code>unpublish</code>的问题，大家不会对这样的做法有太多的疑问，<br>因为NodeJS的特色就是如此嘛，而且npm的引用和配置下载也非常方便，<br>即使是再简单的模块，我若引用也就是<code>require</code>一下，然后将依赖写到json里，<br>还是比自己写实现函数要方便一些，虽然方便得不多。<br>总之就是不出事还好，一出事，那不好意思就得有人负责，<br>这件事没有主要负责人，那么就得有问题被抛出。</p>
<p>所以最近这几天抛出的最多的一个问题就是，<strong>对于简单的代码我们仍要引用模块吗？</strong></p>
<p>首先我觉得像这次又模块被作者下架，这毕竟是少数事件，<br>我们不应该讨论对于npm的信任问题，这样会使我们在引用模块时畏手畏脚，<br>有人说你简单的函数方法自己写嘛，复杂的再引用别人的，<br>就是减少引用，就减少了出了事摊上你的概率，<br>我只想说在小概率事件中减小该事件的概率–无关痛痒。</p>
<p>总之我对npm模块的引用还是持比较乐观的态度，<br>npm的社区非常繁荣，拥有大批的贡献者，我觉得就是即使是再小的一个模块，<br>你写出来了就可以<code>publish</code>上去，就可以给别人引用，每个人都有发光发热的机会，<br>这给作者多大的鼓励和成就感啊，别人用后也会给你反馈，你再去不断改善，<br>大家也可以在<code>review</code>其他模块代码中得到非常多的编程技术和思想。</p>
<p>与对引用小模块的质疑相反，我觉得引用大模块的问题似乎更多，<br>一个项目中引用的大模块往往并不需要里面的很多功能，<br>所以NodeJS才在新版中将核心模块分割成多份，大家需要用啥再引用那个模块，<br>这样就避免了项目庞大引起的各模块之间可能出现的兼容问题，<br>也不至于使得代码太臃肿，至于对小模块引用可能导致require和模块依赖过大，<br>但是代码依然比较精简，代码的冗余也比较少。</p>
<p>最后，关于npm模块的引用，小模块如果有用过或已经知道的精巧模块，<br>不仿大胆引用，若是不清楚也不必特意查询，简单的功能自己想方法实现即可，<br>大模块如果与项目的配合不好，该分解的最好分解，结合项目和自身的编程习惯，<br>高效的完成项目。<br>以上仅仅是个人愚昧的一些看法。</p>
]]></content>
    
    <summary type="html">
    
      npm导致我们不会写代码了？
    
    </summary>
    
      <category term="随笔" scheme="http://shudery.cn/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="随笔" scheme="http://shudery.cn/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
</feed>
